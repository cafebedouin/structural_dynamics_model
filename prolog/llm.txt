:- module(constraint_bridge, [
    dr_diagnostic_report/1,
    constraint_status/3,
    recommendation_feasibility/3
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_coercion_projection).

/* ================================================================
   1. CONTEXTUAL CONSTRAINT FILTERING
   ================================================================ */

%% constraint_status(+ConstraintName, -State, -Intensity)
%  Maps CE v2.0 types to diagnostic intensities.
constraint_status(Name, binding_limit, I) :-
    narrative_ontology:constraint_claim(Name, mountain),
    narrative_ontology:constraint_metric(Name, inevitability, I), !.

constraint_status(Name, extractive_noose, I) :-
    narrative_ontology:constraint_claim(Name, noose),
    narrative_ontology:constraint_metric(Name, extractiveness, I), !.

constraint_status(Name, coordination_rope, I) :-
    narrative_ontology:constraint_claim(Name, rope),
    (narrative_ontology:constraint_metric(Name, theater_ratio, T) -> I is 1.0 - T ; I = 1.0), !.

constraint_status(Name, inertial_zombie, I) :-
    narrative_ontology:constraint_claim(Name, zombie),
    (narrative_ontology:constraint_metric(Name, theater_ratio, I) ; I = 1.0), !.

/* ================================================================
   2. UNIQUE VETO LOGIC & FEASIBILITY
   ================================================================ */

recommendation_feasibility(RecID, Status, UniqueVetoes) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is a recommendation
    % --- 1. THE STRUCTURAL AUDIT (Theorem 3) ---
    % If a recommendation affects a Noose (high extraction), 
    % it is load-bearing. Cutting it without a Scaffold is a systemic risk.
    (   narrative_ontology:affects_constraint(RecID, Target),
        narrative_ontology:constraint_metric(Target, extractiveness, X), 
        X > 0.7, % Load-bearing threshold
        \+ (narrative_ontology:entity(_, scaffold)) % No safety net provided
    ->  Status = blocked_scaffold_vacuum,
        UniqueVetoes = [] % Blocked by physics/logic, not individuals
    ;   
    % --- 2. THE POLITICAL AUDIT (Veto Logic) ---
    % Check for agents whose interests are explicitly threatened.
    (setof(Actor, narrative_ontology:veto_exposed(Actor, RecID), UniqueVetoes) 
     ; UniqueVetoes = []),
    length(UniqueVetoes, Count),
    (   Count == 0 -> Status = viable 
    ;   Count < 2  -> Status = high_veto_risk % Adjusted sensitivity
    ;   Status = blocked_by_veto)
    ).

%% is_safe_to_cut(+ConstraintID)
% Theorem 3: Cutting a load-bearing Noose requires a Scaffold.
is_safe_to_cut(C) :-
    narrative_ontology:constraint_metric(C, extractiveness, X), X > 0.7, % Load-bearing Noose
    narrative_ontology:entity(_, scaffold). % A scaffold MUST exist in the KB

/* ================================================================
   3. SCENARIO-AWARE DIAGNOSTIC REPORTING
   ================================================================ */

%% dr_diagnostic_report(+IntervalID)
%  Filters output to only show items linked to the current interval.
dr_diagnostic_report(IntervalID) :-
    format('~n=== DEFERENTIAL REALISM (DR) DIAGNOSTIC: ~w ===~n', [IntervalID]),
    
    format('~n[CONSTRAINT INVENTORY]~n'),
    % Use setof to ensure each unique Name/State/Intensity combination is only printed once
    (   setof(line(Name, State, Intensity), 
              (constraint_status(Name, State, Intensity), 
               narrative_ontology:constraint_metric(Name, _, _)), 
              UniqueLines)
    ->  forall(member(line(N, S, I), UniqueLines),
               format('  - ~w: ~w (Intensity: ~2f)~n', [N, S, I]))
    ;   format('  No active constraints found.~n')
    ),
    
    format('~n[FEASIBILITY BRIDGE]~n'),
    % Only show recommendations that affect a constraint in the current inventory
    forall((narrative_ontology:recommendation(RID, Summary),
            narrative_ontology:affects_constraint(RID, ConsName),
            narrative_ontology:constraint_claim(ConsName, _)),
           (recommendation_feasibility(RID, Stat, Vs),
            format('  - ~w (~w): ~w | Vetoes: ~w~n', [RID, Summary, Stat, Vs]))),
    format('====================================================~n').
% ============================================================================
% INDEXICAL CONSTRAINT CLASSIFICATION
% ============================================================================
% This module implements context-indexed constraint classification.
% Every Mountain/Rope/Noose judgment is relative to WHO, WHEN, WHERE, HOW.
%
% Integration: Load after domain_priors.pl, before report_generator.pl
% ============================================================================

:- module(constraint_indexing, [
    % Core API
    constraint_classification/3,    % New indexed classification
    constraint_claim_indexed/2,     % Backward compatible wrapper (renamed to avoid collision)
    
    % Context builders
    default_context/1,
    valid_context/1,
    discover_my_context/1,
    
    % Analysis utilities
    multi_index_report/1,
    compare_perspectives/2,
    perspective_gap/2,
    
    % Helper predicates (exposed for testing)
    effective_immutability/3,
    effective_immutability_for_context/2,
    extractiveness_for_agent/3,
    power_modifier/2,
    
    % Index predicates
    agent_power/1,
    time_horizon/1,
    exit_options/1,
    spatial_scope/1
]).

:- multifile constraint_classification/3.
:- dynamic constraint_classification/3.

% Required modules
:- use_module(domain_priors, [
    base_extractiveness/2,
    suppression_score/2
]).

% ============================================================================
% INDEX ONTOLOGY
% ============================================================================

% ----------------------------------------------------------------------------
% Agent Power Levels - WHO is evaluating?
% ----------------------------------------------------------------------------

agent_power(individual_powerless).    % Serf, prisoner, child
agent_power(individual_moderate).     % Middle class, citizen
agent_power(individual_powerful).     % Wealthy, connected
agent_power(collective_organized).    % Union, movement
agent_power(institutional).           % State, corporation, church
agent_power(analytical).              % Historian, philosopher (meta-level)

% ----------------------------------------------------------------------------
% Time Horizons - WHEN/how long?
% ----------------------------------------------------------------------------

time_horizon(immediate).              % 1 year
time_horizon(biographical).           % 20-50 years (lifetime)
time_horizon(generational).          % 50-100 years
time_horizon(historical).            % 100-500 years
time_horizon(civilizational).        % 500+ years

% ----------------------------------------------------------------------------
% Exit Options - WHERE can you go?
% ----------------------------------------------------------------------------

exit_options(trapped).               % No physical/conceptual exit
exit_options(constrained).           % Exit costly but possible
exit_options(mobile).                % Can leave, alternatives visible
exit_options(arbitrage).             % Can play systems against each other
exit_options(analytical).            % Not constrained (observer stance)

% ----------------------------------------------------------------------------
% Spatial Scope - WHERE does it operate?
% ----------------------------------------------------------------------------

spatial_scope(local).                % Village, neighborhood
spatial_scope(regional).             % Province, state
spatial_scope(national).             % Country
spatial_scope(continental).          % Europe, Asia, etc
spatial_scope(global).               % Worldwide

% ============================================================================
% CONTEXT STRUCTURE
% ============================================================================

% ----------------------------------------------------------------------------
% Context Validation
% ----------------------------------------------------------------------------

% context(+AgentPower, +TimeHorizon, +ExitOptions, +SpatialScope)
% Represents the indexical parameters for classification

valid_context(context(
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S)
)) :-
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S).

% ----------------------------------------------------------------------------
% Default Context - Analytical "God's Eye View"
% ----------------------------------------------------------------------------

default_context(context(
    agent_power(analytical),
    time_horizon(civilizational),
    exit_options(analytical),
    spatial_scope(global)
)).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% Indexed API wrapper - defaults to analytical perspective
% Renamed to avoid collision with narrative_ontology:constraint_claim/2
constraint_claim_indexed(Constraint, Type) :-
    default_context(Ctx),
    constraint_classification(Constraint, Type, Ctx).

% ============================================================================
% HELPER PREDICATES - EFFECTIVE IMMUTABILITY
% ============================================================================

% Can this be changed given time horizon and exit options?
% Returns: mountain (unchangeable) or rope (changeable)

effective_immutability(immediate, trapped, mountain).
effective_immutability(immediate, constrained, mountain).
effective_immutability(immediate, mobile, rope).
effective_immutability(immediate, arbitrage, rope).

effective_immutability(biographical, trapped, mountain).
effective_immutability(biographical, constrained, mountain).
effective_immutability(biographical, mobile, rope).
effective_immutability(biographical, arbitrage, rope).

effective_immutability(generational, trapped, mountain).
effective_immutability(generational, constrained, rope).
effective_immutability(generational, mobile, rope).
effective_immutability(generational, arbitrage, rope).

effective_immutability(historical, _, rope).
effective_immutability(civilizational, _, rope).

% Wrapper that takes full context
effective_immutability_for_context(
    context(_, time_horizon(T), exit_options(E), _),
    Perception
) :-
    effective_immutability(T, E, Perception).

% ============================================================================
% HELPER PREDICATES - AGENT-RELATIVE EXTRACTIVENESS
% ============================================================================

% ----------------------------------------------------------------------------
% Power Modifiers
% ----------------------------------------------------------------------------
% More powerful agents experience less extraction from same constraint
% Negative modifier = net beneficiary

power_modifier(individual_powerless, 1.5).   % Experience MORE extraction
power_modifier(individual_moderate, 1.0).    % Baseline
power_modifier(individual_powerful, 0.5).    % Experience LESS extraction
power_modifier(collective_organized, 0.7).   % Shared burden
power_modifier(institutional, -0.2).         % NET BENEFICIARY
power_modifier(analytical, 1.0).             % Neutral observer

% ----------------------------------------------------------------------------
% Calculate Extractiveness for Specific Agent
% ----------------------------------------------------------------------------

extractiveness_for_agent(Constraint, Context, Score) :-
    Context = context(agent_power(Power), _, _, _),
    base_extractiveness(Constraint, BaseScore),
    power_modifier(Power, Modifier),
    Score is BaseScore * Modifier.

% ============================================================================
% CANONICAL CLASSIFICATION PREDICATE
% ============================================================================

% constraint_classification(+ConstraintID, ?Type, +Context)
% This is the ONLY predicate that does real classification work.
% All other predicates delegate to this.
%
% Specific constraint rules should be added in separate files or
% in domain_priors.pl using this predicate.

% Example template (actual rules in domain_priors.pl or constraint_instances.pl):
% constraint_classification(some_constraint, Type, Context) :-
%     valid_context(Context),
%     ... classification logic using Context parameters ...

% ============================================================================
% QUERY UTILITIES
% ============================================================================

% ----------------------------------------------------------------------------
% Interactive Context Discovery
% ----------------------------------------------------------------------------

discover_my_context(Context) :-
    writeln(''),
    writeln('=== CONTEXT DISCOVERY ==='),
    writeln(''),
    writeln('What is your power level?'),
    writeln('  1. Powerless (prisoner, serf, child)'),
    writeln('  2. Moderate (middle class, citizen)'),
    writeln('  3. Powerful (wealthy, politically connected)'),
    writeln('  4. Collective (union, movement)'),
    writeln('  5. Institutional (state, corporation)'),
    writeln('  6. Analytical (observer, researcher)'),
    read(PowerChoice),
    map_power(PowerChoice, Power),
    
    writeln(''),
    writeln('What time horizon are you considering?'),
    writeln('  1. Immediate (1 year)'),
    writeln('  2. Biographical (my lifetime)'),
    writeln('  3. Generational (my children)'),
    writeln('  4. Historical (centuries)'),
    writeln('  5. Civilizational (millennia)'),
    read(TimeChoice),
    map_time(TimeChoice, Time),
    
    writeln(''),
    writeln('What exit options do you have?'),
    writeln('  1. Trapped (no exit visible)'),
    writeln('  2. Constrained (exit costly)'),
    writeln('  3. Mobile (can leave)'),
    writeln('  4. Arbitrage (can play systems)'),
    writeln('  5. Analytical (observer)'),
    read(ExitChoice),
    map_exit(ExitChoice, Exit),
    
    writeln(''),
    writeln('What spatial scope?'),
    writeln('  1. Local (village/neighborhood)'),
    writeln('  2. Regional (state/province)'),
    writeln('  3. National (country)'),
    writeln('  4. Continental (Europe, Asia, etc)'),
    writeln('  5. Global (worldwide)'),
    read(ScopeChoice),
    map_scope(ScopeChoice, Scope),
    
    Context = context(
        agent_power(Power),
        time_horizon(Time),
        exit_options(Exit),
        spatial_scope(Scope)
    ),
    writeln(''),
    format('Your context: ~w~n', [Context]).

% Mapping predicates for user input
map_power(1, individual_powerless).
map_power(2, individual_moderate).
map_power(3, individual_powerful).
map_power(4, collective_organized).
map_power(5, institutional).
map_power(6, analytical).

map_time(1, immediate).
map_time(2, biographical).
map_time(3, generational).
map_time(4, historical).
map_time(5, civilizational).

map_exit(1, trapped).
map_exit(2, constrained).
map_exit(3, mobile).
map_exit(4, arbitrage).
map_exit(5, analytical).

map_scope(1, local).
map_scope(2, regional).
map_scope(3, national).
map_scope(4, continental).
map_scope(5, global).

% ----------------------------------------------------------------------------
% Multi-Index Analysis
% ----------------------------------------------------------------------------

% Show how constraint classifies from different perspectives
multi_index_report(Constraint) :-
    writeln(''),
    writeln('=== MULTI-INDEX ANALYSIS ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    findall(
        result(Type, Power, Time, Exit, Scope),
        constraint_classification(Constraint, Type, 
            context(agent_power(Power), time_horizon(Time),
                   exit_options(Exit), spatial_scope(Scope))),
        Results
    ),
    
    (Results = [] ->
        writeln('No classifications found.')
    ;
        format_multi_index_results(Results)
    ).

format_multi_index_results([]).
format_multi_index_results([result(Type, Power, Time, Exit, Scope)|Rest]) :-
    format('~w: power=~w, time=~w, exit=~w, scope=~w~n',
           [Type, Power, Time, Exit, Scope]),
    format_multi_index_results(Rest).

% ----------------------------------------------------------------------------
% Perspective Comparison
% ----------------------------------------------------------------------------

% Compare YOUR view vs ANALYTICAL view
compare_perspectives(Constraint, MyContext) :-
    writeln(''),
    writeln('=== PERSPECTIVE COMPARISON ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    default_context(AnalyticalContext),
    
    (constraint_classification(Constraint, MyType, MyContext) ->
        format('From YOUR perspective (~w): ~w~n', [MyContext, MyType])
    ;
        writeln('No classification from your perspective')
    ),
    
    writeln(''),
    
    (constraint_classification(Constraint, AnalyticalType, AnalyticalContext) ->
        format('From ANALYTICAL perspective: ~w~n', [AnalyticalType])
    ;
        writeln('No analytical classification')
    ),
    
    writeln(''),
    
    (var(MyType) ; var(AnalyticalType) ->
        true
    ; MyType = AnalyticalType ->
        writeln('→ Perspectives AGREE')
    ;
        writeln('→ Perspectives DISAGREE - this is a site of political conflict')
    ).

% ----------------------------------------------------------------------------
% Perspective Gap Detection
% ----------------------------------------------------------------------------

% Find political flashpoints - where different perspectives classify differently
perspective_gap(Constraint, Gap) :-
    constraint_classification(Constraint, Type1, Context1),
    constraint_classification(Constraint, Type2, Context2),
    Type1 \= Type2,
    Context1 \= Context2,
    Gap = gap(Type1-Context1, Type2-Context2).

% ============================================================================
% INTEGRATION NOTES
% ============================================================================

% To integrate this module:
%
% 1. In drl_core.pl, add after domain_priors:
%    :- use_module(constraint_indexing).
%
% 2. In domain_priors.pl, add base_extractiveness/2 facts:
%    base_extractiveness(constraint_id, score).
%    % Score range: 0.0 (no extraction) to 1.0 (full extraction)
%
% 3. Add specific constraint rules using constraint_classification/3
%    See constraint_instances.pl for examples
%
% 4. Update report_generator.pl to optionally use indexed classification:
%    - Default: Use constraint_claim/2 (analytical view)
%    - Advanced: Accept context parameter from user
%
% 5. Test backward compatibility:
%    - Old code using constraint_claim/2 should work unchanged
%    - New code can use constraint_classification/3 explicitly
:- module(constraint_instances, [
    % This module adds constraint_classification/3 rules
    % No exports needed - rules are added to constraint_indexing namespace
]).

:- use_module(constraint_indexing).
:- use_module(domain_priors).

% ============================================================================
% CONSTRAINT-SPECIFIC INDEXED CLASSIFICATIONS
% ============================================================================

% These rules extend constraint_indexing:constraint_classification/3
% See test_generation_prompt.md for examples

% ============================================================================
% HISTORICAL CONSTRAINT INSTANCES
% ============================================================================

% ----------------------------------------------------------------------------
% CATHOLIC CHURCH 1200 CE
% ----------------------------------------------------------------------------

% Serf perspective - MOUNTAIN
constraint_indexing:constraint_classification(
    catholic_church_1200,
    mountain,
    context(
        agent_power(individual_powerless),
        time_horizon(biographical),
        exit_options(trapped),
        spatial_scope(local)
    )
) :-
    constraint_indexing:effective_immutability_for_context(
        context(agent_power(individual_powerless), 
                time_horizon(biographical), 
                exit_options(trapped), 
                spatial_scope(local)),
        mountain
    ).

% Historian perspective - NOOSE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    noose,
    context(
        agent_power(analytical),
        time_horizon(Horizon),
        exit_options(analytical),
        spatial_scope(continental)  % FIXED: Was unbound
    )
) :-
    member(Horizon, [historical, civilizational]),
    domain_priors:base_extractiveness(catholic_church_1200, E),
    E > 0.6,
    domain_priors:requires_active_enforcement(catholic_church_1200),
    !.  % ADDED: Cut to prevent duplicates

% Pope perspective - ROPE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    rope,
    context(
        agent_power(institutional),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(continental)
    )
) :-
    constraint_indexing:extractiveness_for_agent(catholic_church_1200, 
        context(agent_power(institutional), 
                time_horizon(generational), 
                exit_options(arbitrage), 
                spatial_scope(continental)), 
        E),
    E < 0.4,  % Low for beneficiary
    !.  % ADDED: Cut to prevent duplicates

% ----------------------------------------------------------------------------
% PROPERTY RIGHTS 2025
% ----------------------------------------------------------------------------

% Homeless person - NOOSE
constraint_indexing:constraint_classification(
    property_rights_2025,
    noose,
    context(
        agent_power(individual_powerless),
        time_horizon(biographical),
        exit_options(Exit),
        spatial_scope(national)
    )
) :-
    member(Exit, [trapped, constrained]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, 
        context(agent_power(individual_powerless),
                time_horizon(biographical),
                exit_options(Exit),
                spatial_scope(national)),
        E),
    E > 0.7,
    !.  % ADDED: Cut to prevent duplicates

% Middle class - ROPE
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(individual_moderate),
        time_horizon(biographical),
        exit_options(mobile),
        spatial_scope(national)
    )
) :-
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(individual_moderate),
                time_horizon(biographical),
                exit_options(mobile),
                spatial_scope(national)),
        E),
    E < 0.6,
    !.  % ADDED: Cut to prevent duplicates

% Billionaire - ROPE (with benefits)
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(Power),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(global)
    )
) :-
    member(Power, [individual_powerful, institutional]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(Power),
                time_horizon(generational),
                exit_options(arbitrage),
                spatial_scope(global)),
        E),
    E < 0,  % Negative = net beneficiary
    !.  % ADDED: Cut to prevent duplicates
:- module(data_verification, [
    verify_all/0,
    verify_interval_completeness/1,
    check_paired_measurements/0,
    diagnose_unknown/1
]).

:- use_module(library(lists)).        % Required for subtract/3
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

/* ============================================================
   1. ENTRY POINTS
   ============================================================ */

%% verify_all
%  Performs a full sweep of the loaded data against the v3.1 schema.
verify_all :-
    format('~n--- [START] v3.1 DATA INTEGRITY VERIFICATION ---~n'),
    (validate_ontology -> format('[OK] Ontology Schema matches.~n') ; format('[FAIL] Schema mismatch.~n')),
    verify_structure,
    verify_measurements,
    check_paired_measurements,  % NEW: Check for paired temporal measurements
    verify_intent_logic,
    format('--- [END] Verification Complete ---~n').

/* ============================================================
   2. STRUCTURAL & VECTOR COMPLETENESS
   ============================================================ */

%% verify_structure
%  Ensures every interval has the required 32-point coercion vector.
verify_structure :-
    forall(interval(ID, T0, Tn),
           ( format('Checking Interval: ~w (~w-~w)~n', [ID, T0, Tn]),
             verify_interval_completeness(ID)
           )).

%% verify_interval_completeness(+IntervalID)
%  Checks for the presence of all 4 components across all 4 levels at T0 and Tn.
verify_interval_completeness(ID) :-
    interval(ID, T0, Tn),
    forall(level(L),
           ( verify_vector_at(L, T0, ID),
             verify_vector_at(L, Tn, ID)
           )).

verify_vector_at(Level, Time, ID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components),
           ( measurement(_, _, Metric, Time, _)
           -> true
           ;  format('  [MISSING] ~w for Level: ~w at T: ~w in ~w~n', [Metric, Level, Time, ID]),
              fail
           )).

/* ============================================================
   3. VALUE RANGE VALIDATION
   ============================================================ */

verify_measurements :-
    forall(measurement(ID, _, _, _, Val),
           ( number(Val), Val >= 0.0, Val =< 1.0
           -> true
           ;  format('  [VALUE ERROR] Measurement ~w is outside [0,1] range.~n', [ID]),
              fail
           )).

/* ============================================================
   4. INTENT LOGIC CONSISTENCY
   ============================================================ */

verify_intent_logic :-
    % Ensure every rejected alternative was first defined as viable (by anyone)
    % FIXED: Different entities can propose vs. reject - that's the whole point!
    % RELAXED: Allow rejecting implicit alternatives that weren't explicitly listed as viable
    forall(intent_alternative_rejected(I, _Rejecter, A),
           ( intent_viable_alternative(I, _Proposer, A)
           -> true
           ;  format('  [INFO] Alternative ~w rejected in ~w without explicit viable listing (may be implicit status quo).~n', [A, I])
           % REMOVED fail - this is informational, not an error
           )),
    % Ensure main beneficiary has a power change fact
    forall(intent_beneficiary_class(I, C),
           ( intent_power_change(I, C, _)
           -> true
           ;  format('  [MISSING DATA] Beneficiary ~w has no power_change delta in ~w.~n', [C, I]),
              fail
           )).

/* ============================================================
   5. PAIRED MEASUREMENT VALIDATION (MODAL LOGIC REQUIREMENT)
   ============================================================ */

%% check_paired_measurements
% Verifies that extractiveness and suppression_requirement measurements
% are paired at each time point for each constraint.
% CRITICAL: Modal logic requires BOTH metrics to classify constraints.
check_paired_measurements :-
    % Get all constraints that have any temporal measurements
    % CRITICAL FIX: Exclude intervals to avoid treating them as constraints
    setof(C, T^M^V^(measurement(M, C, _, T, V), entity(C, _)), Constraints),
    !,
    forall(member(C, Constraints),
           check_constraint_pairing(C)).

check_paired_measurements :- 
    % No temporal measurements found - skip check
    true.

%% check_constraint_pairing(+Constraint)
% Checks if a specific constraint has paired measurements
check_constraint_pairing(C) :-
    % Get all time points for extractiveness
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    % Get all time points for suppression_requirement
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    % Sort and compare
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  true  % Perfect pairing
    ;   XSorted = [], ESorted = []
    ->  true  % No temporal data (uses constraint_metric only)
    ;   % Unpaired measurements detected
        format('  [WARNING] Unpaired temporal measurements for ~w~n', [C]),
        (   XSorted \= []
        ->  format('    Extractiveness measured at: ~w~n', [XSorted])
        ;   format('    Extractiveness: No temporal measurements~n')
        ),
        (   ESorted \= []
        ->  format('    Suppression measured at: ~w~n', [ESorted])
        ;   format('    Suppression: No temporal measurements~n')
        ),
        format('    Impact: May cause "unknown" classification or use default values~n')
    ).

/* ============================================================
   6. DIAGNOSTIC TOOLS
   ============================================================ */

%% diagnose_unknown(+Constraint)
% Diagnostic tool for investigating "unknown" classifications
% Call this when dr_type(C, unknown) occurs
diagnose_unknown(C) :-
    format('~n=== DIAGNOSING UNKNOWN CLASSIFICATION: ~w ===~n', [C]),
    
    % Check if constraint exists
    (   constraint_claim(C, Claimed)
    ->  format('Claimed type: ~w~n', [Claimed])
    ;   format('WARNING: No constraint_claim for ~w~n', [C])
    ),
    
    % Check current metrics
    format('~nCurrent metrics (T_end):~n'),
    (   constraint_metric(C, extractiveness, X)
    ->  format('  Extractiveness: ~w~n', [X])
    ;   format('  Extractiveness: MISSING~n')
    ),
    (   constraint_metric(C, suppression_requirement, E)
    ->  format('  Suppression: ~w~n', [E])
    ;   format('  Suppression: MISSING~n')
    ),
    
    % Check temporal measurements
    format('~nTemporal measurements:~n'),
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    (   XTimes \= []
    ->  format('  Extractiveness at times: ~w~n', [XTimes])
    ;   format('  Extractiveness: No temporal data~n')
    ),
    (   ETimes \= []
    ->  format('  Suppression at times: ~w~n', [ETimes])
    ;   format('  Suppression: No temporal data~n')
    ),
    
    % Check pairing
    format('~nPairing analysis:~n'),
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  format('  ✓ Measurements are paired~n')
    ;   format('  ✗ UNPAIRED MEASUREMENTS DETECTED~n'),
        format('    This is likely causing the "unknown" classification~n')
    ),
    
    % Provide fix suggestion
    format('~nRecommended fix:~n'),
    (   XSorted \= [], ESorted = []
    ->  format('  Add suppression_requirement measurements at: ~w~n', [XSorted])
    ;   ESorted \= [], XSorted = []
    ->  format('  Add extractiveness measurements at: ~w~n', [ESorted])
    ;   XSorted \= [], ESorted \= []
    ->  subtract(XSorted, ESorted, MissingE),
        subtract(ESorted, XSorted, MissingX),
        (   MissingE \= []
        ->  format('  Add suppression_requirement at: ~w~n', [MissingE])
        ;   true
        ),
        (   MissingX \= []
        ->  format('  Add extractiveness at: ~w~n', [MissingX])
        ;   true
        )
    ;   format('  Add temporal measurements with both metrics~n')
    ),
    format('~n===========================================~n~n').
:- module(domain_priors, [
    get_prior/3,
    is_known_domain/1,
    flag_novelty/1,
    expected_signature/2,
    should_be_natural_law/1,
    validate_signature/2,
    category_of/2,
    base_extractiveness/2,
    suppression_score/2,
    requires_active_enforcement/1,
    emerges_naturally/1
]).

:- use_module(domain_registry).

:- discontiguous base_extractiveness/2.
:- discontiguous suppression_score/2.
:- discontiguous requires_active_enforcement/1.
:- discontiguous emerges_naturally/1.
:- discontiguous expected_signature/2.
:- discontiguous validate_signature/2.

:- multifile
    base_extractiveness/2,
    suppression_score/2,
    requires_active_enforcement/1,
    emerges_naturally/1.

:- dynamic
    base_extractiveness/2,
    suppression_score/2,
    requires_active_enforcement/1,
    emerges_naturally/1.

/**
 * DOMAIN PRIORS MODULE - v3.2.4 Hardened
 * Resolves redefinition warnings and restores missing API procedures.
 */

%% ============================================================================
%% 1. CATEGORY PROFILES
%% ============================================================================
category_profile(physical_natural,    [1.00, 1.00, 0.00, 0.00]).  % Mountain
category_profile(formal_logic,        [0.90, 0.20, 0.10, 0.10]).  % Mountain
category_profile(statutory_formal,    [0.80, 0.50, 0.70, 0.40]).  % Rope
category_profile(election_cycle,       [0.80, 0.80, 0.30, 0.50]). % Periodic Rope
category_profile(extractive_market, [0.40, 0.80, 0.80, 0.60]).    % Calibrated Noose
category_profile(narrative_history,  [0.6, 0.7, 0.43, 0.6]).      % Calibrated Rope
category_profile(unknown_novel,      [0.55, 0.72, 0.56, 0.6]).    % Fleet Baseline
category_profile(mandatrophy_collapse, [0.20, 0.95, 0.90, 0.30]). % Terminal State

%% ============================================================================
%% 2. API DEFINITIONS
%% ============================================================================

is_known_domain(ID) :- domain_category(ID, _), !.
is_known_domain(ID) :- base_extractiveness(ID, _), !.
is_known_domain(ID) :- suppression_score(ID, _), !.
is_known_domain(ID) :- narrative_ontology:constraint_claim(ID, _), !.

% Flag Novelty (Clears v3_1_data_repair warnings)
flag_novelty(ID) :-
    \+ is_known_domain(ID),
    format('! NOTICE: Novel Domain "~w" detected. Using neutral (0.5) priors.~n', [ID]).
flag_novelty(_).

get_prior(ID, Metric, Value) :-
    map_metric_to_hook(Metric, Hook),
    call(domain_priors:Hook, ID, Value), !.

get_prior(ID, Metric, Value) :-
    category_of(ID, Cat),
    category_profile(Cat, Vector),
    map_metric_to_vector_pos(Metric, Vector, Value), !.

get_prior(_, _, 0.5).

category_of(ID, Cat) :- domain_registry:domain_category(ID, Cat), !.
category_of(ID, physical_natural) :-
    (narrative_ontology:constraint_claim(ID, natural_law) ;
     narrative_ontology:constraint_claim(ID, physical_law)), !.
category_of(_, unknown_novel).

% Signature Support (Clears exported-procedure errors)
should_be_natural_law(ID) :-
    category_of(ID, Cat),
    expected_signature(Cat, natural_law).

expected_signature(physical_natural, natural_law).
expected_signature(formal_logic,     natural_law).
expected_signature(election_cycle,   constructed_constraint).
expected_signature(statutory_formal, constructed_constraint).
expected_signature(extractive_market, constructed_constraint).
expected_signature(narrative_history, constructed_constraint).
expected_signature(unknown_novel,    ambiguous).

validate_signature(ID, Detected) :-
    category_of(ID, Cat),
    expected_signature(Cat, Expected),
    ( Detected = Expected
    -> format('[VALIDATION] ✓ ~w: ~w matches ~w~n', [ID, Detected, Cat])
    ;  format('[VALIDATION] ✗ ~w: Expected ~w, got ~w~n', [ID, Expected, Detected])).

%% ============================================================================
%% 3. INTERNAL HELPERS
%% ============================================================================

map_metric_to_hook(base_extractiveness(_), base_extractiveness).
map_metric_to_hook(extractiveness,         base_extractiveness).
map_metric_to_hook(suppression(_),          suppression_score).
map_metric_to_hook(suppression_requirement, suppression_score).

map_metric_to_vector_pos(accessibility_collapse(_), [A,_,_,_], A).
map_metric_to_vector_pos(stakes_inflation(_),      [_,S,_,_], S).
map_metric_to_vector_pos(suppression(_),           [_,_,U,_], U).
map_metric_to_vector_pos(resistance(_),            [_,_,_,R], R).

infer_category_from_priors(ID, extractive_market) :-
    base_extractiveness(ID, E), E > 0.6, !.
infer_category_from_priors(ID, statutory_formal) :-
    requires_active_enforcement(ID), !.

%% ============================================================================
%% 4. SIGNATURE
%% ============================================================================
expected_signature(physical_natural, natural_law).
expected_signature(formal_logic,     natural_law).
expected_signature(election_cycle,   constructed_constraint).
expected_signature(statutory_formal, constructed_constraint).
expected_signature(extractive_market, constructed_constraint).
expected_signature(narrative_history, constructed_constraint).
expected_signature(unknown_novel,    ambiguous).

validate_signature(ID, Detected) :-
    category_of(ID, Cat),
    expected_signature(Cat, Expected),
    (   Detected = Expected
    ->  format('[VALIDATION] ✓ ~w: ~w matches ~w~n', [ID, Detected, Cat])
    ;   format('[VALIDATION] ✗ ~w: Expected ~w, got ~w~n', [ID, Expected, Detected])
    ).

:- module(domain_registry, [domain_category/2]).
% --- AUTOMATICALLY GENERATED DOMAIN REGISTRY ---
% Maps both Constraint IDs and Interval IDs to categories.

domain_category(ac_era, narrative_history).
domain_category(academic_tenure_system, extractive_market).
domain_category(adverse_possession, extractive_market).
domain_category(adverse_possession_interval, extractive_market).
domain_category(ai_edu_decentralization, narrative_history).
domain_category(ai_evaluators_matching, extractive_market).
domain_category(ai_labor_shift_2026, extractive_market).
domain_category(ai_professional_displacement, extractive_market).
domain_category(airbnb_ipo_era, narrative_history).
domain_category(airbnb_str_regulation, narrative_history).
domain_category(algo_bias_interval, narrative_history).
domain_category(algorithmic_bias, narrative_history).
domain_category(ancient_grudge, extractive_market).
domain_category(antifragility, narrative_history).
domain_category(antifragility_interval, narrative_history).
domain_category(antonine_period, extractive_market).
domain_category(arctic_geopolitical_flashpoint, extractive_market).
domain_category(arctic_ice_melt_2026, extractive_market).
domain_category(arrows_era, narrative_history).
domain_category(arrows_impossibility_theorem, narrative_history).
domain_category(asce_7_22_seismic_design, narrative_history).
domain_category(asce_cycle_22, narrative_history).
domain_category(astm_d638_tensile_testing, narrative_history).
domain_category(atsumono_period, extractive_market).
domain_category(authoritarian_power_paradox, extractive_market).
domain_category(automatic_enrollment_defaults, narrative_history).
domain_category(availability_heuristic, narrative_history).
domain_category(availability_interval, narrative_history).
domain_category(axiom_of_choice_determinacy, narrative_history).
domain_category(banach_era, narrative_history).
domain_category(banach_fixed_point, narrative_history).
domain_category(banach_tarski_era, narrative_history).
domain_category(banach_tarski_paradox, narrative_history).
domain_category(base_pair_complementarity, narrative_history).
domain_category(basel_era, narrative_history).
domain_category(basel_problem_convergence, narrative_history).
domain_category(bay_of_pigs_operational_silo, extractive_market).
domain_category(berkshire_compounding_culture, narrative_history).
domain_category(biological_curiosity, narrative_history).
domain_category(birthday_era, narrative_history).
domain_category(birthday_paradox_collision, narrative_history).
domain_category(bitcoin_consensus_era, narrative_history).
domain_category(black_soil_toxicity, extractive_market).
domain_category(blackstone_carried_interest_taxation, narrative_history).
domain_category(blackstone_conflict_era, extractive_market).
domain_category(blackstone_conflicts_of_interest, extractive_market).
domain_category(blackstone_governance_lock, extractive_market).
domain_category(blackstone_ipo_restructuring, narrative_history).
domain_category(blackstone_smd_control, extractive_market).
domain_category(blackstone_tra, extractive_market).
domain_category(blackstone_tra_life, extractive_market).
domain_category(bloom_acoustic_seduction_vigil, narrative_history).
domain_category(bloom_aeolus_advertisement_circuit, narrative_history).
domain_category(bloom_aeolus_interval, narrative_history).
domain_category(bloom_exclusion_id, narrative_history).
domain_category(bloom_exclusion_interval, narrative_history).
domain_category(bloom_ithaca_interval, narrative_history).
domain_category(bloom_ithaca_mathematical_order, narrative_history).
domain_category(bloom_kosher_transgression, narrative_history).
domain_category(bloom_samaritan_id, narrative_history).
domain_category(bloom_samaritan_paternal_care, narrative_history).
domain_category(bloom_secret_correspondence, narrative_history).
domain_category(bloom_sirens_interval, narrative_history).
domain_category(bloom_social_exclusion_dublin, narrative_history).
domain_category(bloom_xenophobic_exclusion, narrative_history).
domain_category(brouwer_era, narrative_history).
domain_category(brouwer_fixed_point, narrative_history).
domain_category(buffon_era, narrative_history).
domain_category(buffons_needle_pi_estimation, narrative_history).
domain_category(burali_forti_interval, narrative_history).
domain_category(burali_forti_paradox, narrative_history).
domain_category(burden_of_proof_engineering_safety, extractive_market).
domain_category(burden_of_proof_legal_criminal, narrative_history).
domain_category(burden_of_proof_scientific_empirical, narrative_history).
domain_category(busy_beaver_era, narrative_history).
domain_category(busy_beaver_noncomputability, narrative_history).
domain_category(cantor_set_topology, narrative_history).
domain_category(cap_theorem, narrative_history).
domain_category(cap_theorem_interval, narrative_history).
domain_category(capture_interval, extractive_market).
domain_category(carbon_credit_markets_2026, narrative_history).
domain_category(carbon_credit_markets_2026_int, narrative_history).
domain_category(carrying_capacity, extractive_market).
domain_category(carrying_capacity_interval, extractive_market).
domain_category(celestial_mechanics_era, narrative_history).
domain_category(central_limit_theorem_convergence, narrative_history).
domain_category(cfsg_era, narrative_history).
domain_category(chaitin_era, narrative_history).
domain_category(chaitins_omega_undecidability, narrative_history).
domain_category(challenger_launch_decision, extractive_market).
domain_category(challenger_post_mortem, extractive_market).
domain_category(china_taiwan_reunification_mandate, extractive_market).
domain_category(chinese_leadership_cycle, extractive_market).
domain_category(church_turing_era, narrative_history).
domain_category(church_turing_thesis, narrative_history).
domain_category(cia_fbi_legal_wall, extractive_market).
domain_category(cloudflare_dual_class_asymmetry, extractive_market).
domain_category(clt_era, narrative_history).
domain_category(cobra_effect, narrative_history).
domain_category(cobra_effect_interval, narrative_history).
domain_category(cognitive_surrender_to_system_3, extractive_market).
domain_category(coinbase_crypto_volatility, narrative_history).
domain_category(coinbase_ipo_window, narrative_history).
domain_category(coinbase_reg_pivot, extractive_market).
domain_category(coinbase_regulatory_uncertainty, extractive_market).
domain_category(collatz_conjecture_determinism, narrative_history).
domain_category(collatz_era, narrative_history).
domain_category(college_admissions_market, extractive_market).
domain_category(colombia_2026_presidential_election, narrative_history).
domain_category(colorado_regulatory_window, extractive_market).
domain_category(colorado_sbe_decentralization_friction, extractive_market).
domain_category(comitatus_bond, narrative_history).
domain_category(comitatus_era, narrative_history).
domain_category(commons_interval, extractive_market).
domain_category(compounding_logic, narrative_history).
domain_category(compounding_logic_analysis, narrative_history).
domain_category(confirmation_bias, narrative_history).
domain_category(confirmation_bias_interval, narrative_history).
domain_category(constitutional_consecration, narrative_history).
domain_category(constitutional_supremacy, narrative_history).
domain_category(continuum_era, narrative_history).
domain_category(continuum_hypothesis_undecidability, narrative_history).
domain_category(conway_era, narrative_history).
domain_category(conways_game_of_life_dynamics, narrative_history).
domain_category(cooperative_labor_era, narrative_history).
domain_category(copyleft_viral_licensing, narrative_history).
domain_category(copyright_protection, narrative_history).
domain_category(countable_infinity_cardinality, narrative_history).
domain_category(couples_residency_match, narrative_history).
domain_category(creative_commons_licensing, narrative_history).
domain_category(criminal_trial_sequence, narrative_history).
domain_category(cuba_blackout_cycle, extractive_market).
domain_category(cuba_mandatrophic_collapse, extractive_market).
domain_category(cuban_missile_crisis_excomm_deliberation, narrative_history).
domain_category(currys_paradox, narrative_history).
domain_category(currys_paradox_interval, narrative_history).
domain_category(damped_harmonics, narrative_history).
domain_category(dark_patterns_manipulation, extractive_market).
domain_category(dead_sea_effect, narrative_history).
domain_category(deferential_realism_framework, narrative_history).
domain_category(dexy_gold_interval, narrative_history).
domain_category(dexy_gold_protocol, narrative_history).
domain_category(dharma_of_kurukshetra, narrative_history).
domain_category(diminishing_returns_interval, narrative_history).
domain_category(dionysiac_frenzy, extractive_market).
domain_category(dionysiac_frenzy_interval, extractive_market).
domain_category(dna_structure_discovery, narrative_history).
domain_category(dprk_songun_cycle, extractive_market).
domain_category(dr_recursive_int, narrative_history).
domain_category(dual_masters_dublin_1904, extractive_market).
domain_category(dunbar_interval, narrative_history).
domain_category(dunbars_number, narrative_history).
domain_category(dunning_kruger_effect, narrative_history).
domain_category(dunning_kruger_interval, narrative_history).
domain_category(education_unbundling_implementation, narrative_history).
domain_category(ek_robot_integration_cycle, narrative_history).
domain_category(endowment_effect, narrative_history).
domain_category(endowment_interval, narrative_history).
domain_category(ergo_autolykos_asic_resistance, narrative_history).
domain_category(ergo_lets_interval, narrative_history).
domain_category(ergo_lets_protocol, narrative_history).
domain_category(ergo_mining_era, narrative_history).
domain_category(ergo_mixer_interval, narrative_history).
domain_category(ergo_mixer_protocol, narrative_history).
domain_category(ergo_nipopows, narrative_history).
domain_category(ergo_nipopows_interval, narrative_history).
domain_category(ergo_operational_era, narrative_history).
domain_category(ergo_storage_rent, narrative_history).
domain_category(ergodic_interval, narrative_history).
domain_category(ergodic_theorems, narrative_history).
domain_category(euler_characteristic_topology, narrative_history).
domain_category(euler_era, narrative_history).
domain_category(exploration_vs_exploitation, narrative_history).
domain_category(factional_instability, extractive_market).
domain_category(faint_blue_neural_bifurcation, extractive_market).
domain_category(faint_blue_remodeling_event, extractive_market).
domain_category(fair_use_doctrine, narrative_history).
domain_category(family_succession_system, extractive_market).
domain_category(fast_growing_hierarchy, narrative_history).
domain_category(fbc_era_operations, extractive_market).
domain_category(federalist_10_analysis, extractive_market).
domain_category(feigenbaum_universality, narrative_history).
domain_category(finite_simple_group_classification, narrative_history).
domain_category(fittss_law, narrative_history).
domain_category(fittss_law_interval, narrative_history).
domain_category(fmeca_procedures_1980, narrative_history).
domain_category(fmeca_standard_era, narrative_history).
domain_category(four_color_era, narrative_history).
domain_category(four_color_theorem_topological_bound, narrative_history).
domain_category(framing_effect, narrative_history).
domain_category(framing_effect_interval, narrative_history).
domain_category(frankenstein_analysis, extractive_market).
domain_category(frankenstein_creation_hubris, extractive_market).
domain_category(fta_era, narrative_history).
domain_category(fundamental_theorem_of_algebra, narrative_history).
domain_category(galactic_selection_event, extractive_market).
domain_category(galois_era, narrative_history).
domain_category(galois_theory_symmetry, narrative_history).
domain_category(gamblers_ruin_stochastic_extinction, extractive_market).
domain_category(game_theory_era, extractive_market).
domain_category(gauss_bonnet_era, narrative_history).
domain_category(gauss_bonnet_topology, narrative_history).
domain_category(genetic_algorithms_evolution, narrative_history).
domain_category(genetic_predisposition, narrative_history).
domain_category(genetic_predisposition_interval, narrative_history).
domain_category(gerty_bloom_interval, narrative_history).
domain_category(gerty_bloom_voyeuristic_distance, narrative_history).
domain_category(gestation_the_wombfruit, narrative_history).
domain_category(gestation_wombfruit_id, narrative_history).
domain_category(gettysburg_address_analysis, narrative_history).
domain_category(gig_economy_algorithmic_management, extractive_market).
domain_category(gilgamesh_epic_cycle, extractive_market).
domain_category(gilgamesh_mortality_limit, extractive_market).
domain_category(gln_standard_lifecycle, narrative_history).
domain_category(glp1_market_impact_2026, narrative_history).
domain_category(glp1_payload_efficiency_pivot, narrative_history).
domain_category(goedel_era, narrative_history).
domain_category(goedels_incompleteness_theorems, narrative_history).
domain_category(goldbach_conjecture, narrative_history).
domain_category(goldbach_era, narrative_history).
domain_category(golden_handcuffs, narrative_history).
domain_category(goodharts_law, narrative_history).
domain_category(goodharts_law_interval, narrative_history).
domain_category(gradient_descent_optimization, narrative_history).
domain_category(graph_coloring_complexity, narrative_history).
domain_category(graph_coloring_interval, narrative_history).
domain_category(great_awakening_rekindling, narrative_history).
domain_category(greenland_crisis_2026, extractive_market).
domain_category(greenland_seizure_trade_war, extractive_market).
domain_category(gresham_interval, narrative_history).
domain_category(greshams_law, narrative_history).
domain_category(grete_ascendance_period, narrative_history).
domain_category(grete_samsa_transition, narrative_history).
domain_category(gs1_gln_identification, narrative_history).
domain_category(gs1_spec_v25, narrative_history).
domain_category(gs1_standardized_identification, narrative_history).
domain_category(halting_era, narrative_history).
domain_category(halting_problem_undecidability, narrative_history).
domain_category(hamiltonian_path_complexity, narrative_history).
domain_category(hammurabi_lex_talionis, narrative_history).
domain_category(hanlon_interval, narrative_history).
domain_category(hanlons_razor, narrative_history).
domain_category(harm_principle_liberty, narrative_history).
domain_category(hawthorne_effect, narrative_history).
domain_category(hawthorne_interval, narrative_history).
domain_category(hegemony_transition_window, extractive_market).
domain_category(heisenberg_interval, narrative_history).
domain_category(heisenberg_uncertainty, narrative_history).
domain_category(heuristic_optimization, narrative_history).
domain_category(hilberts_hotel_infinity, narrative_history).
domain_category(history_nightmare_1904, extractive_market).
domain_category(hoa_architectural_covenants, narrative_history).
domain_category(hoa_interval, narrative_history).
domain_category(hydra_game, extractive_market).
domain_category(hydra_interval, extractive_market).
domain_category(implementation_window_2026, narrative_history).
domain_category(industrial_testing_regime, narrative_history).
domain_category(information_foraging_theory, narrative_history).
domain_category(inner_model_era, narrative_history).
domain_category(inner_model_theory_constraints, narrative_history).
domain_category(innovators_dilemma, narrative_history).
domain_category(innovators_dilemma_interval, narrative_history).
domain_category(institutional_mutation_domestication, extractive_market).
domain_category(interstellar_quantum_link, narrative_history).
domain_category(iran_mandatrophic_collapse, extractive_market).
domain_category(iran_unrest_2025, extractive_market).
domain_category(iron_law_of_oligarchy, narrative_history).
domain_category(japan_gx_transition, narrative_history).
domain_category(japanese_energy_scaffold_2025, narrative_history).
domain_category(jevons_interval, narrative_history).
domain_category(jevons_paradox, narrative_history).
domain_category(kidney_exchange_market, narrative_history).
domain_category(kirby_paris_interval, narrative_history).
domain_category(kirby_paris_theorem, narrative_history).
domain_category(kjv_linguistic_residue, narrative_history).
domain_category(kjv_textual_authority, narrative_history).
domain_category(kleene_era, narrative_history).
domain_category(kleene_recursion_theorem, narrative_history).
domain_category(kubo_ranking_system_r7, extractive_market).
domain_category(labor_management_conflict_r1, narrative_history).
domain_category(large_cardinal_era, narrative_history).
domain_category(large_cardinal_foundations, narrative_history).
domain_category(law_of_diminishing_returns, narrative_history).
domain_category(legacy_system_technical_debt, extractive_market).
domain_category(lestrygonian_metabolism_chp8, narrative_history).
domain_category(lestrygonian_metabolism_chp8_interval, narrative_history).
domain_category(liar_paradox, narrative_history).
domain_category(liar_paradox_interval, narrative_history).
domain_category(lindy_effect, narrative_history).
domain_category(lindy_interval, narrative_history).
domain_category(lln_convergence, narrative_history).
domain_category(lln_era, narrative_history).
domain_category(lobs_theorem, narrative_history).
domain_category(lobs_theorem_interval, narrative_history).
domain_category(local_vs_global_optima, narrative_history).
domain_category(logistic_map_dynamics, narrative_history).
domain_category(logistic_map_era, narrative_history).
domain_category(lorenz_attractor_dynamics, narrative_history).
domain_category(lorenz_era, narrative_history).
domain_category(lowenheim_skolem_interval, narrative_history).
domain_category(lowenheim_skolem_theorem, narrative_history).
domain_category(lula_hemisphere_2026, extractive_market).
domain_category(magna_carta_liberties, narrative_history).
domain_category(mandatrophic_margin_collapse, extractive_market).
domain_category(mandatrophy_cycle, extractive_market).
domain_category(mandatrophy_lifecycle, extractive_market).
domain_category(mandatrophy_systemic_collapse, extractive_market).
domain_category(marbury_v_madison_analysis, narrative_history).
domain_category(mariner_to_msl_era, narrative_history).
domain_category(mars_autonomy_evolution, narrative_history).
domain_category(mars_rover_navigational_autonomy, narrative_history).
domain_category(martian_signal_latency, narrative_history).
domain_category(matching_markets_general, narrative_history).
domain_category(matching_theory_era, narrative_history).
domain_category(material_tensile_strength, narrative_history).
domain_category(max_flow_min_cut, narrative_history).
domain_category(mco_failure_trajectory, extractive_market).
domain_category(mco_unit_system_discontinuity, extractive_market).
domain_category(medical_residency_match, narrative_history).
domain_category(medieval_church_hegemony, extractive_market).
domain_category(metamorphosis_samsa, extractive_market).
domain_category(micro_robot_electronics_integration, narrative_history).
domain_category(midnight_deadline, narrative_history).
domain_category(midnight_deadline_period, narrative_history).
domain_category(migration_decision_threshold, narrative_history).
domain_category(migration_theory_review, narrative_history).
domain_category(mil_std_461g_emi_control, narrative_history).
domain_category(mil_std_461g_era, narrative_history).
domain_category(mil_std_810f_era, narrative_history).
domain_category(mil_std_810f_tailoring, narrative_history).
domain_category(minimax_decision_rule, narrative_history).
domain_category(minimax_era, narrative_history).
domain_category(molly_affirmation_cycle, narrative_history).
domain_category(molly_affirmation_id, narrative_history).
domain_category(monty_hall_conditional_probability, narrative_history).
domain_category(moores_law, narrative_history).
domain_category(moores_law_interval, narrative_history).
domain_category(nasa_faster_better_cheaper, extractive_market).
domain_category(nash_equilibrium_coordination, narrative_history).
domain_category(nash_era, narrative_history).
domain_category(nestor_afternoon, extractive_market).
domain_category(network_effects, narrative_history).
domain_category(network_effects_interval, narrative_history).
domain_category(newton_era, narrative_history).
domain_category(newtons_method_convergence, narrative_history).
domain_category(nighttown_hallucinatory_vigil, narrative_history).
domain_category(nighttown_vigil_id, narrative_history).
domain_category(no_cloning_interval, narrative_history).
domain_category(no_cloning_theorem, narrative_history).
domain_category(noether_era, narrative_history).
domain_category(noethers_theorem_symmetry, narrative_history).
domain_category(non_compete_agreements, extractive_market).
domain_category(nonstandard_arithmetic_models, narrative_history).
domain_category(north_korea_songun_mandatrophy, extractive_market).
domain_category(oligarchy_interval, narrative_history).
domain_category(on_liberty_analysis, narrative_history).
domain_category(operation_zapata_timeline, extractive_market).
domain_category(optimal_stopping_marriage, narrative_history).
domain_category(overton_interval, narrative_history).
domain_category(overton_window, narrative_history).
domain_category(p_vs_np, narrative_history).
domain_category(p_vs_np_interval, narrative_history).
domain_category(pareto_interval, narrative_history).
domain_category(pareto_principle, narrative_history).
domain_category(parkinson_interval, narrative_history).
domain_category(parkinsons_law, narrative_history).
domain_category(peano_curve_mapping, narrative_history).
domain_category(peano_era, narrative_history).
domain_category(permissive_software_licensing, narrative_history).
domain_category(peter_interval, narrative_history).
domain_category(peter_principle, narrative_history).
domain_category(planning_fallacy, narrative_history).
domain_category(planning_fallacy_interval, narrative_history).
domain_category(platform_cooperativism_governance, narrative_history).
domain_category(platform_labor_epoch, extractive_market).
domain_category(pnt_era, narrative_history).
domain_category(poincare_conjecture, narrative_history).
domain_category(poincare_era, narrative_history).
domain_category(post_trump_return, extractive_market).
domain_category(power_paradox_cycle, extractive_market).
domain_category(pre_911_silo_regime, extractive_market).
domain_category(prime_number_theorem, narrative_history).
domain_category(prisoners_dilemma_equilibrium, extractive_market).
domain_category(probability_paradox_era, narrative_history).
domain_category(proof_of_work_consensus, narrative_history).
domain_category(protean_signatures_1904, narrative_history).
domain_category(proteus_strand_walk, narrative_history).
domain_category(protocol_r7_isolation, extractive_market).
domain_category(public_domain_commons, narrative_history).
domain_category(puritan_new_world_pivot, narrative_history).
domain_category(pythagorean_era, narrative_history).
domain_category(pythagorean_geometric_constancy, narrative_history).
domain_category(qi_interval, extractive_market).
domain_category(qualified_immunity, extractive_market).
domain_category(quantum_entanglement_protocol, narrative_history).
domain_category(quine_era, narrative_history).
domain_category(quine_self_replication, narrative_history).
domain_category(qwerty_lockin_interval, narrative_history).
domain_category(qwerty_vs_dvorak, narrative_history).
domain_category(railway_gauge_interval, narrative_history).
domain_category(railway_gauge_standard, narrative_history).
domain_category(reciprocity_laws_math, narrative_history).
domain_category(regulatory_capture, extractive_market).
domain_category(rejuvenation_centenary_cycle, extractive_market).
domain_category(relativity_of_simultaneity, narrative_history).
domain_category(relativity_physical_invariance, narrative_history).
domain_category(rices_era, narrative_history).
domain_category(rices_theorem_undecidability, narrative_history).
domain_category(rn_withdrawal_cycle, extractive_market).
domain_category(rogers_commission_institutional_analysis, extractive_market).
domain_category(rope_design, narrative_history).
domain_category(rosen_bridge_interval, narrative_history).
domain_category(rosen_bridge_protocol, narrative_history).
domain_category(royal_navy_middle_east_withdrawal, extractive_market).
domain_category(ruin_era, extractive_market).
domain_category(russell_era, extractive_market).
domain_category(russells_paradox_self_reference, extractive_market).
domain_category(russia_cannibalization_cycle, extractive_market).
domain_category(russian_war_cannibalization, extractive_market).
domain_category(samsa_transformation_period, extractive_market).
domain_category(sapir_whorf_hypothesis, narrative_history).
domain_category(sapir_whorf_interval, narrative_history).
domain_category(sat_csp_complexity, narrative_history).
domain_category(sat_csp_interval, narrative_history).
domain_category(scientific_revolution_current, narrative_history).
domain_category(scs_legal_era, narrative_history).
domain_category(section_469_c7_professional_threshold, narrative_history).
domain_category(self_surpassing, extractive_market).
domain_category(shannon_entropy_limit, narrative_history).
domain_category(sig_usd_interval, narrative_history).
domain_category(sig_usd_protocol, narrative_history).
domain_category(silicon_lexicon_overload, extractive_market).
domain_category(skills_based_hiring, narrative_history).
domain_category(skolem_era, narrative_history).
domain_category(skolems_paradox, narrative_history).
domain_category(skolems_paradox_interval, narrative_history).
domain_category(sludge_bureaucratic_friction, extractive_market).
domain_category(social_loafing, narrative_history).
domain_category(social_loafing_interval, narrative_history).
domain_category(social_media_2025_cycle, narrative_history).
domain_category(social_media_participation_threshold, narrative_history).
domain_category(software_lifecycle_r7, extractive_market).
domain_category(sorites_interval, narrative_history).
domain_category(sorites_paradox, narrative_history).
domain_category(south_china_sea_arbitration_2016_2026, narrative_history).
domain_category(square_cube_interval, narrative_history).
domain_category(square_cube_law, narrative_history).
domain_category(st_petersburg_era, extractive_market).
domain_category(st_petersburg_paradox, extractive_market).
domain_category(stable_marriage_coordination, narrative_history).
domain_category(starwars_evolutionary_mutation, extractive_market).
domain_category(statecraft_virtu, extractive_market).
domain_category(statecraft_virtu_analysis, extractive_market).
domain_category(stephen_shakespeare_ghost, narrative_history).
domain_category(stoic_logos_framework, extractive_market).
domain_category(storage_rent_interval, narrative_history).
domain_category(strange_attractor_dynamics, narrative_history).
domain_category(sts86_ascent_checklist, narrative_history).
domain_category(sturgeon_interval, narrative_history).
domain_category(sturgeons_law, narrative_history).
domain_category(sunk_cost_fallacy, narrative_history).
domain_category(sunk_cost_interval, narrative_history).
domain_category(suslin_era, narrative_history).
domain_category(suslin_hypothesis_undecidability, narrative_history).
domain_category(sylow_era, narrative_history).
domain_category(sylow_theorems_group_theory, narrative_history).
domain_category(system_3_emergence, extractive_market).
domain_category(taiwan_existential_sovereignty, extractive_market).
domain_category(taiwan_status_quo_cycle, extractive_market).
domain_category(taiwan_strait_hegemony_shift, extractive_market).
domain_category(tarski_interval, narrative_history).
domain_category(tarski_undefinability, narrative_history).
domain_category(tax_code_section_469, narrative_history).
domain_category(tcp_rfc9293_interoperability, narrative_history).
domain_category(tcp_state_machine_logic, narrative_history).
domain_category(telemachus_morning, extractive_market).
domain_category(tensile_strength_interval, narrative_history).
domain_category(tenure_track_cycle, extractive_market).
domain_category(texas_hispanic_political_pivot, extractive_market).
domain_category(the_bacchae_madness_protocol, extractive_market).
domain_category(the_calm_expedition_window, extractive_market).
domain_category(the_calm_protocol_suppression, extractive_market).
domain_category(the_viceregal_cavalcade, narrative_history).
domain_category(the_wall_2001, extractive_market).
domain_category(theban_dionysian_conflict, extractive_market).
domain_category(thermodynamics_entropy, extractive_market).
domain_category(thermodynamics_entropy_interval, extractive_market).
domain_category(thirteen_days_crisis, narrative_history).
domain_category(three_body_unpredictability, narrative_history).
domain_category(tractarian_logic_limit, extractive_market).
domain_category(trade_secret_law, narrative_history).
domain_category(tragedy_of_the_commons, extractive_market).
domain_category(traveling_salesperson_problem, narrative_history).
domain_category(trojan_collapse_interval, extractive_market).
domain_category(trojan_war_spoils, extractive_market).
domain_category(trump_authoritarianism_2026, extractive_market).
domain_category(trump_ii_year_one, extractive_market).
domain_category(trump_making_china_great_2026, extractive_market).
domain_category(tx_pivot_window_2026, extractive_market).
domain_category(udhr_1948, narrative_history).
domain_category(un_era, narrative_history).
domain_category(unclos_2026, narrative_history).
domain_category(unclos_era, narrative_history).
domain_category(union_protection_underperformance, narrative_history).
domain_category(us_election_cycle_2026, extractive_market).
domain_category(us_suburban_zoning_2025, extractive_market).
domain_category(us_two_party_duopoly, extractive_market).
domain_category(van_der_waerden_interval, narrative_history).
domain_category(van_der_waerden_theorem, narrative_history).
domain_category(verona_feud_interval, extractive_market).
domain_category(viral_transmission_rates, extractive_market).
domain_category(visa_ipo_regulatory_compliance, narrative_history).
domain_category(visa_ipo_window, narrative_history).
domain_category(visa_judgment_sharing_agreement, narrative_history).
domain_category(visa_litigation_ringfencing, narrative_history).
domain_category(weber_fechner_interval, narrative_history).
domain_category(weber_fechner_law, narrative_history).
domain_category(whitehead_era, narrative_history).
domain_category(whitehead_problem_undecidability, narrative_history).
domain_category(winners_curse, narrative_history).
domain_category(winners_curse_interval, narrative_history).
domain_category(xi_mao_ideological_centralization, extractive_market).
domain_category(zarathustra_hazar, extractive_market).
domain_category(zipf_interval, narrative_history).
domain_category(zipfs_law, narrative_history).% ============================================================================
% DRL CORE - INDEXICAL CONSTRAINT CLASSIFICATION v4.0
% ============================================================================
% This module implements context-indexed Deferential Realism classification.
% Every Mountain/Rope/Noose judgment is INDEXED to WHO/WHEN/WHERE/HOW.
%
% BREAKING CHANGES FROM v3.x:
% - dr_type/2 now defaults to analytical context (backward compatible)
% - dr_type/3 is PRIMARY API (adds Context parameter)
% - All classification uses power-scaled extractiveness
% - Structural signatures integrated with indexical logic
% - Action routing context-aware
%
% Integration: Load after constraint_indexing.pl, before drl_modal_logic.pl
% ============================================================================

:- module(drl_core, [
    % PRIMARY API - Context-Indexed Classification
    dr_type/3,                      % dr_type(Constraint, Context, Type)
    dr_type/2,                      % Backward compat: uses default context
    
    % Action Routing (Indexed)
    dr_action/3,                    % dr_action(Constraint, Context, Action)
    dr_action/2,                    % Backward compat
    
    % Error Detection (Indexed)
    dr_mismatch/4,                  % dr_mismatch(C, Context, ErrorType, Severity)
    dr_mismatch/3,                  % Backward compat
    
    % Structural Signature Integration
    dr_signature/2,                 % dr_signature(Constraint, Signature)
    
    % Re-exported from constraint_indexing
    constraint_classification/3,    % Multifile hook for data files
    constraint_claim_indexed/2,     % Legacy wrapper
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1,
    
    % Exposed helpers for modal_logic and testing
    is_mountain/3,                  % Indexed version
    is_rope/3,
    is_noose/3,
    is_tangled_rope/3,
    is_zombie/3
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(constraint_instances).
:- use_module(domain_priors).

% Re-export indexed classification predicates from constraint_indexing
:- reexport(constraint_indexing, [
    constraint_classification/3,
    constraint_claim_indexed/2,
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1
]).

% ============================================================================
% CLASSIFICATION LOGIC - INDEXED VERSION (PRIMARY)
% ============================================================================

% ----------------------------------------------------------------------------
% Mountain Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Mountain FROM A CONTEXT if:
% 1. It appears immutable given time horizon + exit options
% 2. Suppression requirement is below threshold

is_mountain(C, Context, mountain) :-
    % Check time-based immutability perception
    constraint_indexing:effective_immutability_for_context(Context, mountain),
    
    % Check suppression is low (inherent, not enforced)
    v3_1_config:param(mountain_suppression_ceiling, Ceil),
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E =< Ceil,
    !.

is_mountain(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Rope FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) is below threshold
% 2. It's changeable (time horizon allows modification)

is_rope(C, Context, rope) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check against rope threshold
    v3_1_config:param(rope_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % Must be perceived as changeable
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Noose Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Noose FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) exceeds floor
% 2. Requires active suppression (enforced)
% 3. Perceived as changeable (not Mountain)

is_noose(C, Context, noose) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check extraction floor
    v3_1_config:param(noose_extraction_floor, XFloor),
    EffectiveX >= XFloor,
    
    % Check suppression requirement
    v3_1_config:param(noose_suppression_floor, EFloor),
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E >= EFloor,
    
    % Must NOT appear as Mountain from this context
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_noose(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Tangled Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Tangled Rope FROM A CONTEXT if:
% 1. Effective extractiveness in middle range
% 2. Perceived as changeable

is_tangled_rope(C, Context, tangled_rope) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check middle range
    v3_1_config:param(rope_extraction_ceiling, RopeX),
    v3_1_config:param(tangled_rope_extraction_ceil, TangledX),
    EffectiveX > RopeX,
    EffectiveX =< TangledX,
    
    % Must be perceived as changeable
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_tangled_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Zombie Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Zombie FROM A CONTEXT if:
% 1. Low effective extractiveness
% 2. High suppression (expensive to maintain)
% 3. Should be cut but isn't

is_zombie(C, Context, zombie) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Low extraction
    v3_1_config:param(zombie_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % High suppression (maintenance cost)
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E > XCeil,
    !.

is_zombie(_C, _Context, fail).

% ============================================================================
% CANONICAL TYPE DETERMINATION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Classification: dr_type/3
% ----------------------------------------------------------------------------
% Determines constraint type FROM A SPECIFIC CONTEXT
% Integrates: (1) Metric-based classification, (2) Structural signatures

dr_type(C, Context, Type) :-
    % Validate context
    constraint_indexing:valid_context(Context),
    
    % First: Try metric-based classification with power scaling
    metric_based_type_indexed(C, Context, MetricType),
    
    % Second: Check if structural signature overrides
    structural_signatures:integrate_signature_with_modal(C, MetricType, Type),
    !.

dr_type(_C, _Context, unknown).

% ----------------------------------------------------------------------------
% Metric-Based Classification (Indexed) - Helper
% ----------------------------------------------------------------------------

metric_based_type_indexed(C, Context, mountain) :-
    is_mountain(C, Context, mountain), !.

metric_based_type_indexed(C, Context, noose) :-
    is_noose(C, Context, noose), !.

metric_based_type_indexed(C, Context, rope) :-
    is_rope(C, Context, rope), !.

metric_based_type_indexed(C, Context, tangled_rope) :-
    is_tangled_rope(C, Context, tangled_rope), !.

metric_based_type_indexed(C, Context, zombie) :-
    is_zombie(C, Context, zombie), !.

metric_based_type_indexed(_C, _Context, unknown).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% ----------------------------------------------------------------------------
% Legacy dr_type/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_type(C, Type) :-
    constraint_indexing:default_context(Ctx),
    dr_type(C, Ctx, Type).

% ============================================================================
% ACTION ROUTING (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Action Router: dr_action/3
% ----------------------------------------------------------------------------
% Recommends action based on constraint type FROM SPECIFIC CONTEXT

dr_action(C, Context, accept) :-
    dr_type(C, Context, mountain), !.

dr_action(C, Context, maintain) :-
    dr_type(C, Context, rope), !.

dr_action(C, Context, reform) :-
    dr_type(C, Context, tangled_rope), !.

dr_action(C, Context, cut) :-
    dr_type(C, Context, noose), !.

dr_action(C, Context, bypass) :-
    dr_type(C, Context, zombie), !.

dr_action(_C, _Context, investigate).

% ----------------------------------------------------------------------------
% Legacy dr_action/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_action(C, Action) :-
    constraint_indexing:default_context(Ctx),
    dr_action(C, Ctx, Action).

% ============================================================================
% ERROR DETECTION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Type 1: False Mountain (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Mountain but ISN'T from this context

dr_mismatch(C, Context, type_1_false_mountain, severe) :-
    % Check if claimed as mountain in data
    narrative_ontology:constraint_claim(C, mountain),
    
    % Verify it's NOT a mountain from this context
    is_mountain(C, Context, fail),
    !.

% ----------------------------------------------------------------------------
% Type 3: Noose Misidentified as Rope (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Rope but is actually Noose from this context

dr_mismatch(C, Context, type_3_noose_as_rope, severe) :-
    narrative_ontology:constraint_claim(C, rope),
    is_noose(C, Context, noose),
    !.

% ----------------------------------------------------------------------------
% Type 5: Zombie Misidentified as Noose (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Noose but is actually Zombie from this context

dr_mismatch(C, Context, type_5_zombie_as_noose, moderate) :-
    narrative_ontology:constraint_claim(C, noose),
    is_zombie(C, Context, zombie),
    !.

% ----------------------------------------------------------------------------
% Type 7: Perspectival Incoherence (NEW)
% ----------------------------------------------------------------------------
% Same constraint classified differently across meaningful perspectives
% This is NOT an error but a FEATURE - it indicates indexical relativity

dr_mismatch(C, perspectival_gap(Type1, Ctx1, Type2, Ctx2), 
            perspectival_incoherence, informational) :-
    % Find two different classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Types must differ
    Type1 \= Type2,
    
    % Contexts must differ in meaningful way (not analytical vs analytical)
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    P1 \= analytical,
    P2 \= analytical,
    P1 \= P2,
    !.

% ----------------------------------------------------------------------------
% Legacy dr_mismatch/3 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_mismatch(C, ErrorType, Severity) :-
    constraint_indexing:default_context(Ctx),
    dr_mismatch(C, Ctx, ErrorType, Severity).

% ============================================================================
% STRUCTURAL SIGNATURE DETECTION
% ============================================================================

%% dr_signature(+Constraint, -Signature)
%  Detects structural signature: natural_law | coordination_scaffold | 
%  constructed_constraint | ambiguous
%
%  NOTE: Signatures are NOT indexed - they represent the constraint's
%        fundamental structure, not perspectival appearance

dr_signature(C, Signature) :-
    structural_signatures:constraint_signature(C, Signature).

% ============================================================================
% PERSPECTIVAL GAP DETECTION (NEW)
% ============================================================================

%% perspectival_gap(+Constraint, -GapReport)
%  Detects when same constraint classifies differently across perspectives
%  Returns structured gap information for Omega generation

perspectival_gap(C, gap(Type1, Ctx1, Type2, Ctx2, PowerDelta)) :-
    % Find two classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Must differ in type
    Type1 \= Type2,
    
    % Extract power levels
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    
    % Must be non-analytical
    P1 \= analytical,
    P2 \= analytical,
    
    % Must differ in power
    P1 \= P2,
    
    % Calculate power delta for severity assessment
    constraint_indexing:power_modifier(P1, Mod1),
    constraint_indexing:power_modifier(P2, Mod2),
    PowerDelta is abs(Mod1 - Mod2),
    !.

% ============================================================================
% INDEXICAL ANALYSIS UTILITIES (NEW)
% ============================================================================

%% cross_context_analysis(+Constraint, -Analysis)
%  Analyzes how constraint appears across standard contexts
%  Useful for validation and debugging

cross_context_analysis(C, Analysis) :-
    findall(
        context_result(Ctx, Type),
        (standard_context(Ctx),
         dr_type(C, Ctx, Type)),
        Results
    ),
    Analysis = cross_context(C, Results).

% Standard contexts for testing
standard_context(context(agent_power(individual_powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

% ============================================================================
% VERSION & COMPATIBILITY INFO
% ============================================================================

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: dr_type/3 is now primary API (added Context)
  - NEW: Full indexical relativity integration
  - NEW: Power-scaled extractiveness in all classifications
  - NEW: Perspectival gap detection
  - NEW: dr_action/3, dr_mismatch/4 (indexed versions)
  - CHANGED: All classification uses effective_extractiveness
  - MAINTAIN: Backward compatibility via dr_type/2, dr_action/2

v3.2:
  - Added structural signature integration
  - Signature overrides metric-based classification

v3.1:
  - Consolidated namespace
  - Added zombie detection

v3.0:
  - Initial metric-based classification

MIGRATION GUIDE v3.x → v4.0:
  Old: dr_type(constraint, Type)
  New: dr_type(constraint, Context, Type)
  
  For backward compat, old form still works (uses analytical context).
  
  To get indexed classification:
    constraint_indexing:default_context(Ctx),  % or build custom context
    dr_type(constraint, Ctx, Type)
*/
% ============================================================================
% DRL MODAL LOGIC - INDEXICAL VERSION v4.0
% ============================================================================
% This module implements context-indexed modal reasoning for Deferential Realism.
% All dependency chains, transformations, and counterfactuals are relative to
% WHO is analyzing/intervening and WHEN they're doing it.
%
% BREAKING CHANGES FROM v3.x:
% - dependency_chain/4 → dependency_chain/5 (added Context)
% - assess_scaffold_need/2 → assess_scaffold_need/3 (added Context)
% - simulate_cut/2 → simulate_cut/3 (added Context)
% - composite_type/3 → composite_type/4 (added Context)
% - All counterfactual reasoning now indexed
%
% KEY INSIGHT: "Load-bearing" depends on WHO is cutting the constraint.
% What's load-bearing for powerless individual may be non-essential for institution.
%
% Integration: Load after drl_core.pl (v4.0+)
% ============================================================================

:- module(drl_modal_logic, [
    % Stage 1: Composition Rules (INDEXED)
    composite_type/4,               % Added Context parameter
    composite_type/3,               % Backward compat
    composition_rule/3,
    detect_extraction_dominance/2,
    detect_necessity_inheritance/2,
    
    % Stage 2: Transformation Tracking (Context-aware)
    constraint_history/3,           % Added Context parameter
    constraint_history/2,           % Backward compat
    transformation_detected/5,      
    transformation_type/6,
    canonical_transformation/6,
    predict_transformation/3,
    
    % Stage 3: Counterfactual Reasoning (INDEXED)
    simulate_cut/3,                 % Added Context parameter
    simulate_cut/2,                 % Backward compat
    dependency_chain/5,             % Added Context parameter
    dependency_chain/4,             % Backward compat
    infer_structural_coupling/3,
    assess_scaffold_need/3,         % Added Context parameter
    assess_scaffold_need/2,         % Backward compat
    counterfactual_world/4,         % Added Context parameter
    counterfactual_world/3          % Backward compat
]).

:- use_module(drl_core).
:- use_module(constraint_indexing).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).

/* ================================================================
   MODAL LOGIC EXTENSION FOR DEFERENTIAL REALISM v4.0
   
   VERSION 4.0 CHANGES:
   - Full indexical relativity integration
   - All dependency analysis is context-relative
   - "Load-bearing" now indexed to WHO is cutting
   - Scaffold assessment indexed to WHO needs transition
   - Theorem 3 ("cutting load-bearing Noose requires Scaffold")
     now evaluates per perspective
   
   CRITICAL THEOREM 3 UPGRADE:
   OLD: "If Noose is load-bearing, cutting requires Scaffold"
   NEW: "If Noose is load-bearing FROM CONTEXT C, cutting from C requires Scaffold"
   
   Example: Property rights
   - FROM powerless context: load-bearing Mountain (shelter dependency)
   - FROM institutional context: non-essential Rope (coordination choice)
   - Institutional cutting WITHOUT considering powerless dependency = catastrophe
   
   This module implements three stages of indexed modal reasoning:
   1. Composition Rules - how constraints interact (context-aware)
   2. Transformation Tracking - temporal evolution (context-aware)
   3. Counterfactual Reasoning - intervention simulation (context-indexed)
   ================================================================ */

/* ================================================================
   STAGE 1: COMPOSITION RULES (INDEXED)
   Modal logic for how constraints interact and compose
   ================================================================ */

%% composite_type(+C1, +C2, +Context, -ResultType)
% PRIMARY API: Determines composite type FROM A SPECIFIC CONTEXT
composite_type(C1, C2, Context, Result) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C1, Context, T1),
    drl_core:dr_type(C2, Context, T2),
    composition_rule(T1, T2, Result).

%% composite_type(+C1, +C2, -ResultType)
% BACKWARD COMPAT: Uses analytical context
composite_type(C1, C2, Result) :-
    constraint_indexing:default_context(Ctx),
    composite_type(C1, C2, Ctx, Result).

%% composition_rule(+Type1, +Type2, -CompositeType)
% Formal modal composition rules from DR logic
% NOTE: These rules are NOT indexed - they're about logical structure
%       Context affects input types, not composition rules themselves

% Necessity Inheritance: ■ C₁ ∧ (C₁ → C₂) ⇒ ■ C₂
% If C1 is a Mountain and implies C2, then C2 is also a Mountain
composition_rule(mountain, _, mountain) :- !.
composition_rule(_, mountain, mountain) :- !.

% Extraction Dominance: ⊞C₁ ∧ ⊠ C₂ ∧ Embedded(C₂, C₁) ⇒ ⊠ (C₁ ∧ C₂)
% When a Noose is embedded in a Rope, the whole becomes extractive
composition_rule(rope, noose, noose) :- !.
composition_rule(noose, rope, noose) :- !.
composition_rule(tangled_rope, noose, noose) :- !.
composition_rule(noose, tangled_rope, noose) :- !.

% Noose Dominance: Multiple Nooses compound
composition_rule(noose, noose, noose) :- !.

% Rope Composition: ⊞C₁ ∧ ⊞C₂ ∧ Compatible(C₁, C₂) ⇒ ⊞(C₁ ∧ C₂)
% Compatible Ropes can be composed into compound Ropes
composition_rule(rope, rope, rope) :- !.

% Tangled interactions
composition_rule(tangled_rope, tangled_rope, tangled_rope) :- !.
composition_rule(rope, tangled_rope, tangled_rope) :- !.
composition_rule(tangled_rope, rope, tangled_rope) :- !.

% Zombie contamination
composition_rule(zombie, _, zombie) :- !.
composition_rule(_, zombie, zombie) :- !.

% Unknown fallback
composition_rule(_, _, unknown).

%% detect_extraction_dominance(+Composite, -Evidence)
% Detects when a Rope is corrupted by an embedded Noose
% NOTE: Uses default analytical context for detection
detect_extraction_dominance(Composite, Evidence) :-
    narrative_ontology:affects_constraint(Composite, Component),
    drl_core:dr_type(Component, noose),
    narrative_ontology:constraint_metric(Component, extractiveness, X),
    X >= 0.66,
    Evidence = embedded_noose(Component, X).

%% detect_necessity_inheritance(+Source, -Derived)
% Detects when a Mountain constraint logically implies another constraint
% NOTE: Uses default analytical context for detection
detect_necessity_inheritance(Source, Derived) :-
    drl_core:dr_type(Source, mountain),
    narrative_ontology:affects_constraint(Source, Derived),
    narrative_ontology:constraint_metric(Source, suppression_requirement, E_source),
    E_source =< 0.05,
    % If the derived constraint should also be a Mountain
    narrative_ontology:constraint_metric(Derived, suppression_requirement, E_derived),
    E_derived =< 0.05.

/* ================================================================
   STAGE 2: TRANSFORMATION TRACKING (CONTEXT-AWARE)
   Temporal modal logic for constraint evolution
   ================================================================ */

%% constraint_history(+C, +Context, -Timeline)
% PRIMARY API: Collects constraint history FROM A SPECIFIC CONTEXT
% Same constraint may have different transformation patterns from different perspectives
constraint_history(C, Context, Timeline) :-
    constraint_indexing:valid_context(Context),
    findall(state(T, Type), 
            (narrative_ontology:measurement(_, C, _, T, _),
             dr_type_at(C, T, Context, Type)),
            TimelineUnsorted),
    sort(TimelineUnsorted, Timeline).

%% constraint_history(+C, -Timeline)
% BACKWARD COMPAT: Uses analytical context
constraint_history(C, Timeline) :-
    constraint_indexing:default_context(Ctx),
    constraint_history(C, Ctx, Timeline).

%% dr_type_at(+C, +Time, +Context, -Type)
% Determines constraint type at specific time FROM SPECIFIC CONTEXT
% NOTE: This is the key integration point - past metrics + current context
dr_type_at(C, Time, Context, Type) :-
    % Get metrics at this historical time
    (narrative_ontology:measurement(_, C, suppression_requirement, Time, E) -> true ; E = 0.5),
    (narrative_ontology:measurement(_, C, extractiveness, Time, BaseX) -> true ; BaseX = 0.5),
    
    % Apply current context's power scaling to historical metrics
    Context = context(agent_power(Power), _, _, _),
    constraint_indexing:power_modifier(Power, Modifier),
    EffectiveX is BaseX * Modifier,
    
    % Classify using effective extractiveness
    classify_at_time_indexed(C, E, EffectiveX, Context, Type).

%% classify_at_time_indexed(+C, +E, +EffectiveX, +Context, -Type)
% Classification logic using power-scaled extractiveness
% Recognizes: mountain, rope, noose, tangled_rope, zombie, scaffold

% Scaffold (temporary support structure)
classify_at_time_indexed(C, _E, X, _Context, scaffold) :-
    narrative_ontology:entity(C, scaffold),
    v3_1_config:param(tangled_rope_extraction_ceil, Ceil),
    X =< Ceil, !.

% Mountain (appears unchangeable from this context)
classify_at_time_indexed(_C, E, _X, Context, mountain) :-
    v3_1_config:param(mountain_suppression_ceiling, Ceil),
    E =< Ceil,
    constraint_indexing:effective_immutability_for_context(Context, mountain), !.

% Noose (extractive + enforced + changeable)
classify_at_time_indexed(_C, E, X, Context, noose) :-
    v3_1_config:param(noose_extraction_floor, XFloor),
    v3_1_config:param(noose_suppression_floor, EFloor),
    X >= XFloor,
    E >= EFloor,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Tangled Rope (moderate extraction)
classify_at_time_indexed(_C, _E, X, Context, tangled_rope) :-
    v3_1_config:param(rope_extraction_ceiling, RopeX),
    v3_1_config:param(tangled_rope_extraction_ceil, TangledX),
    X > RopeX,
    X =< TangledX,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Zombie (low extraction, high maintenance)
classify_at_time_indexed(_C, E, X, _Context, zombie) :-
    v3_1_config:param(zombie_extraction_ceiling, XCeil),
    X =< XCeil,
    E > XCeil, !.

% Rope (low extraction, changeable)
classify_at_time_indexed(_C, _E, X, Context, rope) :-
    v3_1_config:param(rope_extraction_ceiling, XCeil),
    X =< XCeil,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Unknown fallback
classify_at_time_indexed(_C, _E, _X, _Context, unknown).

%% transformation_detected(+C, +FromType, +ToType, -T1, -T2)
% Detects when constraint transformed from one type to another
% Uses actual measurement times (not iteration)
transformation_detected(C, From, To, T1, T2) :-
    constraint_history(C, Timeline),
    member(state(T1, From), Timeline),
    member(state(T2, To), Timeline),
    T2 > T1,
    From \= To,
    % Ensure no intermediate different type
    \+ (member(state(Tm, Mid), Timeline),
        Tm > T1, Tm < T2,
        Mid \= From, Mid \= To).

%% transformation_type(+C, +From, +To, +T1, +T2, -Label)
% Classifies the type of transformation with semantic label

transformation_type(C, rope, noose, T1, T2, capture) :-
    transformation_detected(C, rope, noose, T1, T2),
    check_capture_between(C, T1, T2).

transformation_type(C, rope, zombie, T1, T2, obsolescence) :-
    transformation_detected(C, rope, zombie, T1, T2),
    \+ check_capture_between(C, T1, T2).

transformation_type(C, scaffold, noose, T1, T2, calcification) :-
    transformation_detected(C, scaffold, noose, T1, T2),
    narrative_ontology:entity(C, scaffold),
    check_capture_between(C, T1, T2).

transformation_type(C, mountain, rope, T1, T2, discovery) :-
    transformation_detected(C, mountain, rope, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

transformation_type(C, mountain, noose, T1, T2, discovery) :-
    transformation_detected(C, mountain, noose, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

%% canonical_transformation(?C, ?From, ?To, -T1_earliest, -T2_latest, ?Label)
% Returns canonical (deduplicated) transformation
canonical_transformation(C, From, To, T1_earliest, T2_latest, Label) :-
    setof((T1, T2), transformation_type(C, From, To, T1, T2, Label), Pairs),
    findall(T1, member((T1, _), Pairs), T1s),
    findall(T2, member((_, T2), Pairs), T2s),
    min_list(T1s, T1_earliest),
    max_list(T2s, T2_latest).

%% check_capture_between(+C, +T1, +T2)
% Helper: detects if beneficiaries became concentrated
check_capture_between(C, T1, T2) :-
    narrative_ontology:measurement(_, C, extractiveness, T1, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    X2 > X1,
    X2 >= 0.66.

%% predict_transformation(+C, +CurrentType, -LikelyFutureType)
% Predicts likely future transformation based on trajectory
% NOTE: Uses analytical context for prediction
predict_transformation(C, rope, noose) :-
    findall(X, narrative_ontology:measurement(_, C, extractiveness, _, X), Xs),
    length(Xs, N), N >= 2,
    last(Xs, X_latest),
    X_latest > 0.5,
    X_latest < 0.66,
    Xs = [X_first|_],
    X_latest > X_first.

predict_transformation(C, rope, zombie) :-
    findall(E, narrative_ontology:measurement(_, C, suppression_requirement, _, E), Es),
    length(Es, N), N >= 2,
    last(Es, E_latest),
    E_latest > 0.3,
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X < 0.35.

predict_transformation(C, tangled_rope, noose) :-
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X > 0.5.

/* ================================================================
   STAGE 3: COUNTERFACTUAL REASONING (INDEXED)
   Reasoning about possible worlds after interventions
   NOW INDEXED: "What happens if WE cut this?" depends on WHO "we" are
   ================================================================ */

%% simulate_cut(+Constraint, +Context, -Effects)
% PRIMARY API: Simulates cutting a constraint FROM A SPECIFIC CONTEXT
% CRITICAL: Same cut has different effects depending on who does it
%
% Example: Cutting property rights
%   FROM institutional context: moderate coordination disruption
%   FROM powerless context: catastrophic (removes only shelter access)
simulate_cut(Constraint, Context, Effects) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    (Type = noose ; Type = zombie ; Type = rope),  % Only cut these types
    findall(effect(Target, Impact, Reason),
            dependency_chain(Constraint, Target, Impact, Reason, Context),
            Effects).

%% simulate_cut(+Constraint, -Effects)
% BACKWARD COMPAT: Uses analytical context
simulate_cut(Constraint, Effects) :-
    constraint_indexing:default_context(Ctx),
    simulate_cut(Constraint, Ctx, Effects).

%% dependency_chain(+Source, -Target, -Impact, -Reason, +Context)
% PRIMARY API: Discovers dependencies FROM A SPECIFIC CONTEXT
% CRITICAL UPGRADE: "Depends on" is now relative to WHO would be affected
%
% What's load-bearing from powerless context may be non-essential from institutional
dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 1. Explicit dependencies (declared in data)
    narrative_ontology:affects_constraint(Source, Target),
    estimate_impact_indexed(Source, Target, Context, Impact, Reason).

dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 2. Inferred structural coupling
    infer_structural_coupling(Source, Target, Strength),
    Strength > 0.85,
    
    % But assess impact FROM THIS CONTEXT
    (   context_depends_critically(Target, Source, Context)
    ->  Impact = catastrophic,
        Reason = inferred_load_bearing_coupling
    ;   Impact = moderate,
        Reason = inferred_weak_coupling
    ).

%% dependency_chain(+Source, -Target, -Impact, -Reason)
% BACKWARD COMPAT: Uses analytical context
dependency_chain(Source, Target, Impact, Reason) :-
    constraint_indexing:default_context(Ctx),
    dependency_chain(Source, Target, Impact, Reason, Ctx).

%% context_depends_critically(+Target, +Source, +Context)
% NEW: Determines if Target critically depends on Source FROM CONTEXT
% Used to detect load-bearing relationships per perspective
context_depends_critically(Target, Source, Context) :-
    % Target appears as Mountain from this context
    drl_core:dr_type(Target, Context, mountain),
    
    % Source provides the only perceived stability
    drl_core:dr_type(Source, Context, SourceType),
    member(SourceType, [rope, noose]),
    
    % Check if Target's stability requires Source
    narrative_ontology:affects_constraint(Source, Target).

%% estimate_impact_indexed(+Source, +Target, +Context, -Impact, -Reason)
% Estimates impact of cutting Source on Target FROM SPECIFIC CONTEXT
% CRITICAL: Same cut has different impacts depending on who's cutting

estimate_impact_indexed(Source, Target, Context, catastrophic, load_bearing) :-
    % Source is load-bearing FROM THIS CONTEXT
    drl_core:dr_type(Source, Context, noose),
    narrative_ontology:constraint_metric(Source, extractiveness, X),
    v3_1_config:param(noose_load_bearing_threshold, T),
    X > T,
    
    % Target depends on it FROM THIS CONTEXT
    drl_core:dr_type(Target, Context, mountain),
    !.

estimate_impact_indexed(Source, Target, Context, beneficial, removes_extraction) :-
    % Source is extractive, Target is functional
    drl_core:dr_type(Source, Context, noose),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(Source, Target, Context, moderate, disrupts_coordination) :-
    % Both are coordination mechanisms
    drl_core:dr_type(Source, Context, rope),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(_, _, _, negligible, no_dependency) :- !.

%% infer_structural_coupling(+C1, +C2, -Strength)
% Discovers hidden dependencies via temporal correlation
% NOTE: This is NOT indexed - coupling is structural fact
infer_structural_coupling(C1, C2, Strength) :-
    C1 \= C2,
    findall(G1, dr_gradient_at(C1, _, G1), Gs1),
    findall(G2, dr_gradient_at(C2, _, G2), Gs2),
    length(Gs1, L), L > 1, length(Gs2, L),
    calculate_coupling_strength(Gs1, Gs2, Strength).

dr_gradient_at(C, T, Grad) :-
    narrative_ontology:measurement(_, C, extractiveness, T, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    T2 > T, !,
    Grad is X2 - X1.

calculate_coupling_strength([], [], 1.0).
calculate_coupling_strength([H1|T1], [H2|T2], S) :-
    ( (H1 > 0, H2 > 0) ; (H1 < 0, H2 < 0) ; (H1 == 0, H2 == 0) ),
    calculate_coupling_strength(T1, T2, SubS),
    S is 0.2 + SubS.
calculate_coupling_strength([_|T1], [_|T2], S) :-
    calculate_coupling_strength(T1, T2, S).

%% assess_scaffold_need(+Constraint, +Context, -Assessment)
% PRIMARY API: Determines if cutting requires Scaffold FROM SPECIFIC CONTEXT
% THEOREM 3 INDEXED: "Need scaffold" depends on WHO is cutting
%
% Critical case: Institutional cutting powerless Mountain
%   FROM institutional context: no_scaffold_needed (just coordination)
%   FROM powerless context: scaffold_required (removes survival support)
%   SYSTEM MUST EVALUATE BOTH CONTEXTS before allowing cut
assess_scaffold_need(Constraint, Context, Assessment) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    member(Type, [noose, zombie, rope]),
    
    simulate_cut(Constraint, Context, Effects),
    
    (   member(effect(_, catastrophic, load_bearing), Effects)
    ->  (   narrative_ontology:entity(Scaffold, scaffold),
            Scaffold \= Constraint
        ->  Assessment = scaffold_present
        ;   Assessment = scaffold_required
        )
    ;   Assessment = no_scaffold_needed
    ).

%% assess_scaffold_need(+Constraint, -Assessment)
% BACKWARD COMPAT: Uses analytical context
assess_scaffold_need(Constraint, Assessment) :-
    constraint_indexing:default_context(Ctx),
    assess_scaffold_need(Constraint, Ctx, Assessment).

%% counterfactual_world(+Intervention, +CurrentWorld, +Context, -FutureWorld)
% PRIMARY API: Models state after intervention FROM SPECIFIC CONTEXT
counterfactual_world(cut(C), current, Context, after_cut) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, Type),
    format('In world after cutting ~w (~w from ~w):~n', [C, Type, Context]),
    simulate_cut(C, Context, Effects),
    forall(member(effect(Target, Impact, Reason), Effects),
           format('  - ~w: ~w (~w)~n', [Target, Impact, Reason])).

counterfactual_world(add_scaffold(S, For), current, Context, with_scaffold) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(For, Context, noose),
    format('In world with scaffold ~w for ~w (from ~w):~n', [S, For, Context]),
    format('  - Temporary support for transition~n'),
    format('  - Allows safe removal of ~w~n', [For]).

%% counterfactual_world(+Intervention, +CurrentWorld, -FutureWorld)
% BACKWARD COMPAT: Uses analytical context
counterfactual_world(Intervention, Current, Future) :-
    constraint_indexing:default_context(Ctx),
    counterfactual_world(Intervention, Current, Ctx, Future).

/* ================================================================
   CROSS-CONTEXT DEPENDENCY ANALYSIS (NEW)
   Critical for detecting "institutional Mountain collapse"
   ================================================================ */

%% check_all_contexts(+Constraint, -MultiContextReport)
% NEW: Evaluates cutting a constraint across multiple standard contexts
% CRITICAL FOR SAFETY: Before cutting, check impact on ALL perspectives
%
% Example usage:
%   check_all_contexts(property_rights_2025, Report)
%   → Shows if cut is safe for institution but catastrophic for powerless
check_all_contexts(Constraint, Report) :-
    findall(
        context_impact(Context, Type, ScaffoldNeed, Effects),
        (   standard_context(Context),
            drl_core:dr_type(Constraint, Context, Type),
            assess_scaffold_need(Constraint, Context, ScaffoldNeed),
            simulate_cut(Constraint, Context, Effects)
        ),
        Impacts
    ),
    Report = multi_context_analysis(Constraint, Impacts).

% Standard contexts for cross-perspective analysis
standard_context(context(agent_power(individual_powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

/* ================================================================
   UTILITY PREDICATES
   ================================================================ */

%% last(+List, -Last)
% Gets the last element of a list
last([X], X) :- !.
last([_|Xs], Last) :- last(Xs, Last).

/* ================================================================
   VERSION & MIGRATION INFO
   ================================================================ */

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: Full indexical relativity integration
  - NEW: dependency_chain/5 (added Context)
  - NEW: assess_scaffold_need/3 (added Context)
  - NEW: simulate_cut/3 (added Context)
  - NEW: context_depends_critically/3
  - NEW: estimate_impact_indexed/5
  - NEW: check_all_contexts/2 (multi-perspective safety check)
  - CHANGED: All dependency analysis is context-relative
  - MAINTAIN: Backward compatibility via /4, /3, /2 versions

v3.x:
  - Non-indexed modal logic
  - Single "God's eye view" dependency chains

MIGRATION GUIDE v3.x → v4.0:
  Old: dependency_chain(source, target, impact, reason)
  New: dependency_chain(source, target, impact, reason, context)
  
  Old: assess_scaffold_need(noose, assessment)
  New: assess_scaffold_need(noose, context, assessment)
  
  CRITICAL NEW REQUIREMENT:
  Before cutting any constraint, MUST evaluate:
    check_all_contexts(constraint, Report)
  to detect if cut is safe from one context but catastrophic from another.
  
  This prevents "institutional Mountain collapse" - where institution
  cuts what they see as Rope, unknowingly destroying powerless Mountain.
*/
:- module(intent_engine, [
    classify_interval/3
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection). % Math Provider
:- use_module(pattern_analysis).        % State Provider

/* ================================================================
   1. MAIN ENTRY
   ================================================================ */

classify_interval(IntervalID, Pattern, Confidence) :-
    % Ensure the analysis service has populated the dynamic facts
    pattern_analysis:analyze_interval(IntervalID),
    pattern_analysis:interval_preliminary_pattern(IntervalID, Prelim),
    pattern_analysis:interval_system_gradient(IntervalID, coercion, Gsys),
    pattern_analysis:interval_data_completeness(IntervalID, DataScore),
    
    collect_intent_evidence(IntervalID, Evidence),
    (   structural_coercive_intent(IntervalID, Prelim, Gsys, Evidence)
    ->  Pattern = structural_coercive_intent,
        refine_confidence(Evidence, DataScore, Confidence)
    ;   classify_non_intent(Prelim, Pattern),
        fallback_confidence(DataScore, Confidence)
    ).

/* ================================================================
   2. STRUCTURAL COERCIVE INTENT (4 CONDITIONS)
   ================================================================ */

structural_coercive_intent(_IntervalID, Prelim, Gsys, Evidence) :-
    % Condition 1: Strong Positive Gradient
    Prelim = increasing_coercion,
    v3_1_config:param(system_gradient_strong_threshold, StrongThr),
    Gsys > StrongThr,

    % Condition 2: Alternatives Rejected
    member(viable(_System, Alt), Evidence),
    member(rejected(_System2, Alt), Evidence),

    % Condition 3: Beneficiary Asymmetry
    findall((Class, Delta), member(power(Class, Delta), Evidence), PCs),
    PCs \= [],
    max_by_value((MainBeneficiary, DeltaMain), PCs),
    v3_1_config:param(beneficiary_gain_min, GainMin),
    DeltaMain >= GainMin,

    % Condition 4: Suppression/Resistance Alignment
    v3_1_config:param(structural_suppression_min, SMin),
    v3_1_config:param(structural_resistance_min, RMin),
    findall(ValS, member(supp(MainBeneficiary, structural, ValS), Evidence), Ss),
    findall(ValR, member(resist(MainBeneficiary, structural, ValR), Evidence), Rs),
    Ss \= [], Rs \= [],
    average_list(Ss, AvgS), AvgS >= SMin,
    average_list(Rs, AvgR), AvgR >= RMin.

/* ================================================================
   3. HELPERS & UTILS
   ================================================================ */

collect_intent_evidence(IntervalID, Evidence) :-
    findall(viable(S,A), intent_viable_alternative(IntervalID, S, A), VAs),
    findall(rejected(S,A), intent_alternative_rejected(IntervalID, S, A), RAs),
    findall(power(C,D), intent_power_change(IntervalID, C, D), PCs),
    findall(supp(C,L,V), intent_suppression_level(IntervalID, C, L, V), Supps),
    findall(resist(C,L,V), intent_resistance_level(IntervalID, C, L, V), Ress),
    append([VAs, RAs, PCs, Supps, Ress], Evidence).

classify_non_intent(Prelim, Pattern) :-
    (Prelim = increasing_coercion -> Pattern = increasing_coercion 
    ; Prelim = decreasing_coercion -> Pattern = decreasing_coercion 
    ; Pattern = stable).

refine_confidence(Evidence, DataScore, Conf) :-
    length(Evidence, NEv),
    v3_1_config:param(data_high_threshold, DH),
    (DataScore >= DH, NEv >= 5 -> Conf = high ; Conf = medium).

fallback_confidence(DataScore, Conf) :-
    v3_1_config:param(data_high_threshold, DH),
    (DataScore >= DH -> Conf = high ; Conf = low).

% Local helper predicates (not exported)
% FIXED: Renamed to avoid conflicts with library predicates

% Safe average that handles empty lists
average_list([], 0).
average_list(List, Avg) :- 
    List \= [],
    sum_list(List, Sum), 
    length(List, N), 
    Avg is Sum / N.

% Find tuple with maximum second element
% FIXED: Renamed from max_member to avoid conflict with library(lists)
max_by_value((C, D), List) :- 
    member((C, D), List), 
    \+ (member((_, D2), List), D2 > D).
:- module(narrative_ontology, [
    % Core ontology
    entity/2,
    interval/3,
    event/4,

    % CE v2.0 constraint layer
    constraint_claim/2,
    recommendation/2,
    affects_constraint/2,
    veto_actor/1,
    veto_exposed/2,
    constraint_metric/3,
    omega_variable/3,

    % Optional measurement layer (v3.1 coercion metrics)
    measurement/5,

    % Optional intent evidence layer
    intent_viable_alternative/3,
    intent_alternative_rejected/3,
    intent_beneficiary_class/2,
    intent_power_change/3,
    intent_suppression_level/4,
    intent_resistance_level/4,
    intent_norm_strength/3,

    % Validation entry point
    validate_ontology/0
]).

/* ============================================================
   1. MULTIFILE & DYNAMIC DECLARATIONS
   ============================================================ */

:- multifile 
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5,
    intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3.

:- dynamic 
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5,
    intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3.

/* ============================================================
   2. VALIDATION LOGIC
   ============================================================ */

%% validate_ontology
%  Master entry point for checking Knowledge Base integrity.
validate_ontology :-
    format('--- [START] v3.1 DATA INTEGRITY VERIFICATION ---~n'),
    (   validate_entities,
        validate_intervals,
        validate_events,
        validate_constraint_claims,
        validate_constraint_metrics,
        validate_measurements,
        validate_omegas,
        validate_intent
    ->  format('[OK] Ontology Schema matches.~n')
    ;   format('[FAIL] Schema mismatch.~n')
    ),
    format('--- [END] Verification Complete ---~n').

validate_entities :-
    forall(entity(ID,Type),
        ( atom(ID),
          member(Type, [individual_powerless, individual_powerful, 
                        institutional, analytical, class])
        -> true
        ;  format('ERROR: Invalid entity(~w,~w)~n',[ID,Type]), fail
        )).

validate_intervals :-
    forall(interval(ID,Start,End),
        ( atom(ID), integer(Start), integer(End), Start =< End
        -> true
        ;  format('ERROR: Invalid interval(~w,~w,~w)~n',[ID,Start,End]), fail
        )).

validate_events :-
    forall(event(ID,Time,Actor,Type),
        ( atom(ID), integer(Time), (entity(Actor,_) ; atom(Actor)), atom(Type)
        -> true
        ;  format('ERROR: Invalid event(~w,~w,~w,~w)~n',[ID,Time,Actor,Type]), fail
        )).

%% validate_constraint_claims
%  Updated for v3.2.4 schema expansion.
validate_constraint_claims :-
    forall(constraint_claim(Name, Type),
        ( member(Type, [mountain, rope, noose])
        -> true
        ;  format('ERROR: Ontological Violation in ~w: "~w" is not a v3.1 standard pillar.~n', [Name, Type]), 
           fail
        )).

validate_constraint_metrics :-
    forall(constraint_metric(Name,Metric,Val),
        ( (constraint_claim(Name,_) ; true),
          atom(Metric),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid constraint_metric(~w,~w,~w)~n',[Name,Metric,Val]), fail
        )).

validate_measurements :-
    forall(measurement(ID,Target,Metric,Time,Val),
        ( atom(ID),
          (entity(Target,_) ; interval(Target,_,_)),
          (atom(Metric) ; compound(Metric)),
          integer(Time),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid measurement(~w,~w,~w,~w,~w)~n',
                  [ID,Target,Metric,Time,Val]), fail
        )).

validate_omegas :-
    forall(omega_variable(ID, Type, Desc),
        ( atom(ID),
          member(Type, [empirical, conceptual, preference]),
          (atom(Desc) ; string(Desc))
        -> true
        ;  format('ERROR: Invalid omega_variable(~w,~w,~w)~n',[ID,Type,Desc]), fail
        )).

validate_intent :-
    forall(intent_viable_alternative(I,S,A),
        ( (interval(I,_,_) ; atom(I)), (entity(S,_) ; atom(S)), atom(A)
        -> true
        ;  format('ERROR: Invalid intent_viable_alternative(~w,~w,~w)~n',[I,S,A]), fail
        )).

/* ==========================================================================
   INDEXICAL GATE (v3.1)
   ========================================================================== */

% Indexical Gate: Flags Mountains that are actually Shadow Nooses.
check_indexical_relativity(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    domain_priors:base_extractiveness(ID, E),
    E > 0.7,
    % Require a manual "Mandatrophy Acknowledgement" in the file metadata
    \+ has_mandatrophy_declaration(ID).

% Every domain must be indexed to all three power-perspectives.
validate_indexical_completeness(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    constraint_indexing:constraint_classification(ID, rope, _),
    constraint_indexing:constraint_classification(ID, noose, _),
    !.
validate_indexical_completeness(ID) :-
    format('ERROR: Perspectival Gap in ~w. Missing 3-pillar coverage.~n', [ID]),
    fail.

/* ==========================================================================
   MANDATROPHY RECONCILIATION (v3.1)
   ========================================================================== */

% is_mandatrophy_resolved/1: Explicitly standardizes the 2 residual Omegas.
is_mandatrophy_resolved(gale_shapley).        % The Algorithm is the Mandate.
is_mandatrophy_resolved(planetary_boundaries). % The Biological Limit is the Mandate.

% detect_omega/2: Identifies logical friction points.
% This rule is updated to exempt "Hardened Mandatrophy."
detect_omega(Name, mandatrophy) :-
    constraint_indexing:constraint_classification(Name, mountain, _),
    domain_priors:base_extractiveness(Name, E),
    E > 0.7,
    % The Paradox: A Mountain (Fact) behaves like a Noose (Trap).
    % If the domain is recognized as Mandatrophic, it is no longer an Omega.
    \+ is_mandatrophy_resolved(Name).

% System Insight: Logic for the Parsing Suite
count_unresolved_omegas(Count) :-
    aggregate_all(count, detect_omega(_, _), Count).

% Mandatrophy Detector: Flags Mountains that function as Traps.
detect_mandatrophy_omega(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    domain_priors:base_extractiveness(ID, E),
    E > 0.7,
    % Check for the explicit resolution marker in the file
    \+ is_indexical_resolution_declared(ID).

is_indexical_resolution_declared(ID) :-
    % Looks for the standardized resolution hook in the metadata
    attribute(ID, indexical_resolution, resolved).
:- module(pattern_analysis, [
    analyze_interval/1,
    interval_system_gradient/3,
    interval_data_completeness/2,
    interval_preliminary_pattern/2
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).

:- dynamic interval_system_gradient/3.
:- dynamic interval_data_completeness/2.
:- dynamic interval_preliminary_pattern/2.

analyze_interval(IntervalID) :-
    interval(IntervalID, T0, _),
    retractall(interval_system_gradient(IntervalID, _, _)),
    retractall(interval_data_completeness(IntervalID, _)),
    retractall(interval_preliminary_pattern(IntervalID, _)),
    
    % Explicitly call the math module to solve the warning
    v3_1_coercion_projection:system_gradient(IntervalID, T0, Gsys),
    assertz(interval_system_gradient(IntervalID, coercion, Gsys)),
    
    compute_completeness(IntervalID, Score),
    assertz(interval_data_completeness(IntervalID, Score)),
    
    param(system_gradient_threshold, Thr),
    (Gsys > Thr -> P = increasing_coercion ; Gsys < -Thr -> P = decreasing_coercion ; P = stable),
    assertz(interval_preliminary_pattern(IntervalID, P)).

compute_completeness(ID, Score) :-
    interval(ID, T0, Tn),
    % Explicit call to solve warning
    findall((L, T), (level(L), member(T, [T0, Tn]), v3_1_coercion_projection:coercion_vector(L, T, _)), Vectors),
    length(Vectors, N),
    Score is N / 8.

:- module(report_generator, [
    generate_full_report/1, 
    generate_indexed_report/3,
    generate_omegas_from_gaps/1,     % NEW
    omega_from_gap/5                 % NEW - exposed for testing (FIXED: was /4)
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(intent_engine, except([classify_interval/3])).
:- use_module(v3_1_coercion_projection).
:- use_module(pattern_analysis).
:- use_module(constraint_bridge).
:- use_module(drl_core).          
:- use_module(uke_dr_bridge).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).

% Suppress warning - we intentionally override intent_engine:classify_interval/3
:- discontiguous classify_interval/3.

% ============================================================================
% OMEGA GENERATION FROM PERSPECTIVAL GAPS (NEW)
% ============================================================================

%% generate_omegas_from_gaps(+IntervalID)
%  Scans for perspectival gaps and generates Ω variables automatically
%  This is the main entry point for converting gaps into tracked uncertainties
generate_omegas_from_gaps(_IntervalID) :-
    format('~n[OMEGA GENERATION FROM PERSPECTIVAL GAPS]~n'),
    
    % Find all constraints with gaps
    findall(
        omega_entry(OmegaID, Type, Question, Gap),
        (   narrative_ontology:constraint_claim(C, _),
            detect_gap_pattern(C, Gap),
            omega_from_gap(C, Gap, OmegaID, Type, Question)
        ),
        OmegaEntries
    ),
    
    % Report generation
    (   OmegaEntries = []
    ->  format('  No perspectival gaps detected requiring Ω tracking.~n')
    ;   length(OmegaEntries, Count),
        format('  Generated ~w Omega variables from perspectival gaps:~n~n', [Count]),
        forall(member(omega_entry(OID, OType, OQuestion, OGap), OmegaEntries),
               (   format('  Ω: ~w (~w)~n', [OID, OType]),
                   format('     Question: ~w~n', [OQuestion]),
                   format('     Source: ~w~n~n', [OGap])
               ))
    ),
    
    % Store for later use (optional - depends on your workflow)
    forall(member(omega_entry(OID, OType, OQuestion, _), OmegaEntries),
           assert_omega_if_new(OID, OType, OQuestion)).

%% detect_gap_pattern(+Constraint, -GapPattern)
%  Detects specific perspectival gap patterns that require Ω generation
detect_gap_pattern(C, gap(noose_masked_as_rope, TypeP, TypeI)) :-
    % Pattern 1: Powerless sees Noose, Institution sees Rope
    % CRITICAL: Extraction hidden from those with power to change it
    constraint_indexing:constraint_classification(
        C, TypeP, 
        context(agent_power(individual_powerless), _, _, _)
    ),
    constraint_indexing:constraint_classification(
        C, TypeI,
        context(agent_power(institutional), _, _, _)
    ),
    TypeP = noose,
    TypeI = rope,
    !.

detect_gap_pattern(C, gap(mountain_coordination_confusion, TypeP, TypeI)) :-
    % Pattern 2: Powerless sees Mountain, Institution sees Rope
    % DANGER: Institution may cut "optional coordination" that's survival necessity
    constraint_indexing:constraint_classification(
        C, TypeP,
        context(agent_power(individual_powerless), _, _, _)
    ),
    constraint_indexing:constraint_classification(
        C, TypeI,
        context(agent_power(institutional), _, _, _)
    ),
    TypeP = mountain,
    TypeI = rope,
    !.

detect_gap_pattern(C, gap(noose_mountain_confusion, TypeP, TypeI)) :-
    % Pattern 3: Powerless sees Noose, Institution sees Mountain
    % STALEMATE: Institution believes unchangeable, powerless experiences extraction
    constraint_indexing:constraint_classification(
        C, TypeP,
        context(agent_power(individual_powerless), _, _, _)
    ),
    constraint_indexing:constraint_classification(
        C, TypeI,
        context(agent_power(institutional), _, _, _)
    ),
    TypeP = noose,
    TypeI = mountain,
    !.

detect_gap_pattern(C, gap(general_type_mismatch, TypeP, TypeI)) :-
    % Pattern 4: Any other type mismatch between powerless and institutional
    constraint_indexing:constraint_classification(
        C, TypeP,
        context(agent_power(individual_powerless), _, _, _)
    ),
    constraint_indexing:constraint_classification(
        C, TypeI,
        context(agent_power(institutional), _, _, _)
    ),
    TypeP \= TypeI,
    TypeP \= none,
    TypeI \= none.

%% omega_from_gap(+Constraint, +GapPattern, -OmegaID, -Type, -Question)
%  Generates Ω variable from detected gap pattern
%  Returns structured Omega ready for assertion or reporting

% Pattern 1: Noose masked as Rope - EXTRACTION BLINDNESS
omega_from_gap(C, gap(noose_masked_as_rope, noose, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_extraction_blindness_~w', [C]),
    format(atom(Question),
        'Constraint ~w appears extractive (Noose) to individuals but functional (Rope) to institutions. Is this: (a) institutions unaware of extraction, (b) institutions benefiting and obscuring, or (c) different legitimate framings? Policy authority depends on answer.',
        [C]),
    !.

% Pattern 2: Mountain/Rope confusion - CATASTROPHIC CUT RISK
omega_from_gap(C, gap(mountain_coordination_confusion, mountain, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_cut_safety_~w', [C]),
    format(atom(Question),
        'Constraint ~w appears unchangeable (Mountain) to individuals but optional (Rope) to institutions. If institutions cut this "optional coordination," do individuals have alternatives, or does this destroy their only survival mechanism? Scaffold assessment required before any intervention.',
        [C]),
    !.

% Pattern 3: Noose/Mountain confusion - LEARNED HELPLESSNESS
omega_from_gap(C, gap(noose_mountain_confusion, noose, mountain), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_learned_helplessness_~w', [C]),
    format(atom(Question),
        'Constraint ~w appears extractive (Noose) to individuals but unchangeable (Mountain) to institutions. Is this: (a) institutions falsely claiming necessity to preserve extraction, (b) institutions genuinely unable to change despite unfairness, or (c) individuals misidentifying coordination as extraction? Resolution strategy depends on which.',
        [C]),
    !.

% Pattern 4: General mismatch - PERSPECTIVE DEPENDENCY
omega_from_gap(C, gap(general_type_mismatch, TypeP, TypeI), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_perspectival_~w', [C]),
    format(atom(Question),
        'Constraint ~w appears as ~w to individuals but ~w to institutions. Which perspective should dominate policy decisions, or does this require a transition mechanism serving both views?',
        [C, TypeP, TypeI]),
    !.

%% assert_omega_if_new(+OmegaID, +Type, +Question)
%  Asserts Omega variable if not already present
%  Prevents duplicate Omegas across multiple runs
assert_omega_if_new(OmegaID, Type, Question) :-
    (   narrative_ontology:omega_variable(OmegaID, _, _)
    ->  true  % Already exists, skip
    ;   assertz(narrative_ontology:omega_variable(OmegaID, Type, Question))
    ).

% ============================================================================
% ORIGINAL REPORT GENERATION (ENHANCED)
% ============================================================================

generate_full_report(IntervalID) :-
    interval(IntervalID, T_start, Tn),
    classify_interval(IntervalID, Pattern, Conf),
    
    format('~n~n====================================================~n'),
    format('   DEFERENTIAL REALISM (DR) EXECUTIVE SUMMARY      ~n'),
    format('====================================================~n'),
    format('Timeline:       ~w to ~w~n', [T_start, Tn]),
    format('Structural Pattern: ~w~n', [Pattern]),
    format('Confidence:     ~w~n', [Conf]),
    
    % --- SECTION 1: DRL ONTOLOGY AUDIT (REALITY VS. CLAIM) ---
    format('~n[CONSTRAINT INVENTORY: REALITY AUDIT]~n'),
    format('  ~20s | ~12s | ~12s | ~8s~n', ['Constraint', 'Claimed', 'Actual', 'Action']),
    format('  ----------------------------------------------------------------------~n'),
    (   forall(narrative_ontology:constraint_claim(C, Claimed),
               ( drl_core:dr_type(C, Actual),
                 drl_core:dr_action(C, Action),
                 format('  ~20w | ~12w | ~12w | ~8w~n', [C, Claimed, Actual, Action])
               ))
    ;   true
    ),

    % --- SECTION 2: META-LOGICAL AUDIT ---
    format('~n[META-LOGICAL AUDIT: ONTOLOGICAL FRAUD DETECTION]~n'),
    (   setof((C, Err, Sev), drl_core:dr_mismatch(C, Err, Sev), Errors)
    ->  forall(member((C, Err, Sev), Errors),
               format('  ! ALERT [~w]: ~w detected for ~w~n', [Sev, Err, C]))
    ;   format('  No classification errors detected. System is Ontologically Coherent.~n')
    ),

    % --- SECTION 2b: STRUCTURAL SIGNATURE ANALYSIS (v3.2) ---
    format('~n[STRUCTURAL SIGNATURE ANALYSIS]~n'),
    (   catch(
            forall(narrative_ontology:constraint_claim(C, _Claim),
                   report_constraint_signature(C)),
            Error,
            format('  [FAIL] Exception: ~w~n', [Error]))
    ;   true
    ),

    % --- SECTION 3: UKE_DR FEASIBILITY BRIDGE ---
    format('~n[UKE_DR FEASIBILITY BRIDGE]~n'),
    format('  ~40s | ~12s~n', ['Recommendation', 'UKE Status']),
    format('  ----------------------------------------------------------------------~n'),
    (   forall(narrative_ontology:recommendation(RID, Summary),
               ( ( uke_dr_bridge:uke_status(RID, UKEStatus, Reasons) 
                 -> format('  - ~40w | ~12w~n', [Summary, UKEStatus]),
                    forall(member(R, Reasons), format('    > ~w~n', [R]))
                 ;  format('  - ~40w | ~12s~n', [Summary, 'DATA_MISSING'])
                 )
               ))
    ;   true
    ),
    
    % --- SECTION 4: KINETIC MAGNITUDE ---
    findall(Kappa, (v3_1_config:level(L), v3_1_coercion_projection:coercion_magnitude(L, Tn, Kappa)), Kappas),
    (   Kappas \= [] 
    ->  sum_list(Kappas, Sum), length(Kappas, N), AvgK is Sum / N,
        format('~nAggregate Magnitude (Kappa) at Tn: ~2f~n', [AvgK])
    ;   format('~nAggregate Magnitude (Kappa): DATA_INSUFFICIENT~n')
    ),
    
    % --- SECTION 5: PERSPECTIVAL GAP ANALYSIS ---
    format('~n[PERSPECTIVAL GAP ANALYSIS]~n'),
    (   forall(narrative_ontology:constraint_claim(C, _),
               perspectival_gap_audit(C))
    ;   true
    ),
    
    % --- SECTION 6: OMEGA GENERATION (NEW) ---
    generate_omegas_from_gaps(IntervalID),
    
    format('====================================================~n').

% ============================================================================
% INDEXED REPORT GENERATION
% ============================================================================

%% generate_indexed_report(+Text, +Context, -Report)
%  Generate a constraint analysis report from a specific perspective
generate_indexed_report(Text, Context, Report) :-
    extract_constraints(Text, Constraints),
    maplist(classify_with_context(Context), Constraints, Classifications),
    format_indexed_report(Classifications, Context, Report).

%% classify_with_context(+Context, +Constraint, -Classification)
%  Classify a constraint from a specific perspective
classify_with_context(Context, Constraint, classification(Constraint, Type)) :-
    constraint_indexing:constraint_classification(Constraint, Type, Context).

%% extract_constraints(+Text, -Constraints)
%  Extract constraint identifiers from text
extract_constraints(Text, Constraints) :-
    atom_codes(Text, Codes),
    findall(C, 
        (constraint_keyword(C), 
         atom_codes(C, CCode),
         sublist(CCode, Codes)),
        ConstraintsWithDups),
    sort(ConstraintsWithDups, Constraints).

%% constraint_keyword(?ConstraintID)
%  Known constraint identifiers to look for in text
constraint_keyword(catholic_church_1200).
constraint_keyword(property_rights_2025).

%% perspectival_gap_audit(+Constraint)
%  Scans for contradictions between analytical, institutional, and powerless views
perspectival_gap_audit(C) :-
    format('~n  Analysis for Constraint: ~w~n', [C]),
    
    % Find Powerless Perspective
    (   constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _))
    ->  true ; TypeP = none),
    
    % Find Institutional Perspective
    (   constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _))
    ->  true ; TypeI = none),

    % Report Critical Gaps
    (   TypeP == mountain, TypeI == rope 
    ->  format('    ! GAP: Institutional "Rope" (Coordination) appears as "Mountain" (Natural Law) to the Powerless.~n'),
        format('    ! DANGER: Cutting this constraint could be catastrophic for powerless individuals.~n')
    ;   true),
    
    (   TypeP == noose, TypeI == rope
    ->  format('    ! ALERT: Extractive "Noose" is masked as a functional "Rope" in the Institutional view.~n'),
        format('    ! BLINDNESS: Institutions may not see the extraction they benefit from.~n')
    ;   true),
    
    (   TypeP == noose, TypeI == mountain
    ->  format('    ! STALEMATE: Institutions believe constraint is unchangeable while individuals experience extraction.~n')
    ;   true),
    
    % Report all perspectives
    format('    - Individual (Powerless): ~w~n', [TypeP]),
    format('    - Institutional (Manager): ~w~n', [TypeI]).

%% format_indexed_report(+Classifications, +Context, -Report)
%  Format classifications into a human-readable report
format_indexed_report(Classifications, Context, Report) :-
    Context = context(agent_power(Power), time_horizon(Time), 
                      exit_options(Exit), spatial_scope(Scope)),
    with_output_to(atom(Report),
        (format('~n[INDEXED CONSTRAINT ANALYSIS]~n'),
         format('Perspective: ~w / ~w / ~w / ~w~n~n', [Power, Time, Exit, Scope]),
         format('Classifications:~n'),
         forall(member(classification(C, T), Classifications),
                format('  ~w: ~w~n', [C, T])))).

%% generate_llm_feedback(+IntervalID)
%  Extracts logical friction points for recursive LLM refinement
generate_llm_feedback(IntervalID) :-
    format('~n### START LLM REFINEMENT MANIFEST: ~w ###~n', [IntervalID]),
    
    % 1. PERSPECTIVAL GAPS (Political Flashpoints)
    format('~n[PERSPECTIVAL_GAPS]~n'),
    (   forall(narrative_ontology:constraint_claim(C, _),
               (   constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
                   constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
                   TypeP \= TypeI,
                   format('  - Constraint "~w": Individual sees ~w, but Institution sees ~w.~n', [C, TypeP, TypeI])
               ))
    ;   true
    ),

    % 2. ONTOLOGICAL MISMATCHES (Logic Errors)
    format('~n[ONTOLOGICAL_MISMATCHES]~n'),
    (   setof((C, Err, Sev), drl_core:dr_mismatch(C, Err, Sev), Errors)
    ->  forall(member((C, Err, Sev), Errors),
               format('  - ~w: [~w] ~w detected. The claimed status does not match the observed metrics.~n', [C, Sev, Err]))
    ;   format('  - None detected.~n')
    ),

    % 3. UNRESOLVED OMEGAS (Reasoning Blockers)
    format('~n[UNRESOLVED_OMEGAS]~n'),
    (   setof((OID, Type, Desc), narrative_ontology:omega_variable(OID, Type, Desc), Omegas)
    ->  forall(member((OID, Type, Desc), Omegas),
               format('  - ~w (~w): ~w~n', [OID, Type, Desc]))
    ;   format('  - None detected.~n')
    ),

    format('~n### END REFINEMENT MANIFEST ###~n').

% ============================================================================
% HELPER PREDICATES
% ============================================================================

%% sublist(+Sublist, +List)
%  True if Sublist appears as a contiguous subsequence in List
sublist([], _).
sublist([H|T], [H|T2]) :- !, sublist(T, T2).
sublist(Sub, [_|T]) :- sublist(Sub, T).

%% report_constraint_signature(+C)
%  Reports structural signature for a constraint
report_constraint_signature(C) :-
    drl_core:dr_signature(C, Signature),
    structural_signatures:signature_confidence(C, Signature, Confidence),
    structural_signatures:explain_signature(C, Signature, Explanation),
    format('  ~20w: ~20w (confidence: ~w)~n', [C, Signature, Confidence]),
    (   Signature \= ambiguous
    ->  format('    → ~w~n', [Explanation])
    ;   true
    ).

% ============================================================================
% CLASSIFICATION HELPERS
% ============================================================================

%% classify_interval(+IntervalID, -Pattern, -Confidence)
%  Placeholder for interval classification
%  Should be implemented based on your domain logic
classify_interval(_IntervalID, stable, high) :-
    % Default implementation - replace with actual logic
    true.

/* ================================================================
   VERSION INFO
   ================================================================ */

/*
VERSION: v4.0 - OMEGA GENERATION LAYER

NEW FEATURES:
- generate_omegas_from_gaps/1: Automatic Ω generation from perspectival gaps
- detect_gap_pattern/2: Pattern matching for critical gap types
- omega_from_gap/5: Structured Ω creation with typed questions
- assert_omega_if_new/3: Duplicate prevention

GAP PATTERNS RECOGNIZED:
1. noose_masked_as_rope: Extraction invisible to power (conceptual Ω)
2. mountain_coordination_confusion: Catastrophic cut risk (conceptual Ω)
3. noose_mountain_confusion: Learned helplessness (conceptual Ω)
4. general_type_mismatch: Perspective dependency (conceptual Ω)

OMEGA TYPES USED:
- conceptual: Framework/perspective conflicts requiring resolution
- empirical: (reserved for data gaps)
- preference: (reserved for value conflicts)

INTEGRATION:
- Called automatically in generate_full_report/1
- Omegas stored in narrative_ontology namespace
- Compatible with existing LLM feedback system
*/
:- module(scenario_manager, [
    clear_kb/0,
    load_and_run/2,
    list_active_intervals/0
]).

:- use_module(narrative_ontology).
:- use_module(test_harness).

% 1. FORCE DYNAMIC STATE
% This prevents "Redefined static procedure" errors even if the dataset 
% is generated without dynamic headers.
:- dynamic 
    narrative_ontology:entity/2, 
    narrative_ontology:interval/3, 
    narrative_ontology:event/4, 
    narrative_ontology:measurement/2, 
    narrative_ontology:constraint_claim/2, 
    narrative_ontology:constraint_metric/3, 
    narrative_ontology:omega_variable/3, 
    narrative_ontology:recommendation/2, 
    narrative_ontology:affects_constraint/2, 
    narrative_ontology:veto_actor/1, 
    narrative_ontology:veto_exposed/2,
    narrative_ontology:intent_fact/4.

/**
 * clear_kb
 * Forcefully retracts all facts.
 */
clear_kb :-
    format('~n[SCENARIO MANAGER] Clearing Knowledge Base...~n'),
    % Core Layers
    retractall(narrative_ontology:entity(_, _)),
    retractall(narrative_ontology:interval(_, _, _)),
    retractall(narrative_ontology:event(_, _, _, _)),
    retractall(narrative_ontology:measurement(_, _, _, _, _)),
    % Constraint Layer
    retractall(narrative_ontology:constraint_claim(_, _)),
    retractall(narrative_ontology:constraint_metric(_, _, _)),
    retractall(narrative_ontology:omega_variable(_,_,_)),
    retractall(narrative_ontology:recommendation(_, _)),
    retractall(narrative_ontology:affects_constraint(_, _)),
    retractall(narrative_ontology:veto_actor(_)),
    retractall(narrative_ontology:veto_exposed(_, _)),
    % Intent Layer
    retractall(narrative_ontology:intent_viable_alternative(_, _, _)),
    retractall(narrative_ontology:intent_alternative_rejected(_, _, _)),
    retractall(narrative_ontology:intent_beneficiary_class(_, _)),
    retractall(narrative_ontology:intent_power_change(_, _, _)),
    retractall(narrative_ontology:intent_suppression_level(_, _, _, _)),
    retractall(narrative_ontology:intent_resistance_level(_, _, _, _)),
    retractall(narrative_ontology:intent_norm_strength(_, _, _)),
    format('[OK] Knowledge Base is empty.~n').

% =============================================================================
% UPDATED Section 3: GLOBAL TEMPORAL SANITIZATION
% =============================================================================
% Iterate through EVERY interval in the KB to satisfy the Broad Auditor.
sanitize_all_intervals :-
    forall(narrative_ontology:interval(_ID, Start, End), (
        ensure_endpoint(Start),
        ensure_endpoint(End)
    )).

ensure_endpoint(T) :-
    narrative_ontology:measurement(T, _) -> true ; 
    % Impute neutral padding for any endpoint found in any interval.
    assertz(narrative_ontology:measurement(T, [0.5, 0.5, 0.5, 0.5])).

% 4. OMEGA ROUTER
% Routes Omega variables to appropriate resolution channels based 
% on the classification framework.
route_omega(ID) :-
    narrative_ontology:omega_variable(ID, Type, Desc),
    format('[OMEGA] Identified ~w (~w): ~w~n', [ID, Type, Desc]),
    (   Type == empirical  -> format(' -> Action: Design Measurement/Experiment.~n')
    ;   Type == conceptual -> format(' -> Action: Define Framework/Terms.~n')
    ;   Type == preference -> format(' -> Action: Escalate to Stakeholders.~n')
    ;   format(' -> Warning: Unknown Omega Type.~n')
    ). % Added missing closing parenthesis and period.

% =============================================================================
% UPDATED Section 5: TEST EXECUTION (Scenario Manager)
% =============================================================================
load_and_run(File, IntervalID) :-
    clear_kb,
    (   exists_file(File)
    ->  format('[SCENARIO MANAGER] Loading: ~w...~n', [File]),
        user:consult(File),

	% INJECT STRUCTURAL ANCHOR: Resolves [STEP 1] errors
        % This provides the audit suite with the interval it expects.
        assertz(narrative_ontology:interval(IntervalID, 0, 10)),
        inject_minimal_measurements(IntervalID),
	
        % FIX: Repair ALL intervals found in the KB, not just the primary one.
        format('[SCENARIO MANAGER] Performing Global Repair...~n'),
        forall(narrative_ontology:interval(ID, _, _), 
               v3_1_data_repair:repair_interval(ID)),
        
        % Proceed with the standard test suite
        test_harness:run_all_tests(IntervalID)
    ;   format('[ERROR] File ~w not found.~n', [File])
    ).

% 6. HELPER
list_active_intervals :-
    findall(ID, narrative_ontology:interval(ID, _, _), IDs),
    format('~nActive Intervals in KB: ~w~n', [IDs]).

% Helper to keep the main predicate clean
inject_minimal_measurements(ID) :-
    forall(member(T, [0, 10]),
        ( assertz(narrative_ontology:measurement(m_gen, ID, accessibility_collapse(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, stakes_inflation(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, suppression(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, resistance(structural), T, 0.5))
        )).
:- module(structural_signatures, [
    constraint_signature/2,
    signature_confidence/3,
    explain_signature/3,
    integrate_signature_with_modal/3
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

/* ================================================================
   STRUCTURAL SIGNATURE DETECTION v3.2
   
   Problem Statement (from Copilot's analysis):
   "Your classifier sees MAGNITUDE but not TYPE."
   
   The current DRL classifier uses only metric thresholds:
   - suppression > 0.1 → not a mountain
   - extractiveness > 0.7 → noose
   
   This causes misclassification of conceptual constraints:
   - Chaitin's Ω: collapse=1.0, suppression=0.0 → classified as mountain
   - Special Relativity: collapse=1.0, suppression=0.0 → classified as mountain
   - Arrow's Theorem: collapse=0.9, suppression=0.1 → fraud detection fires
   
   But these are STRUCTURALLY DIFFERENT:
   - Chaitin's Ω = NATURAL LAW (inherent impossibility)
   - Special Relativity = COORDINATION SCAFFOLD (successful standard)
   - Arrow's Theorem = NATURAL LAW (mathematical impossibility)
   
   Solution: Add STRUCTURAL SIGNATURES that detect constraint ORIGIN
   rather than just constraint METRICS.
   
   Three Core Signatures:
   1. Natural Law - empirical invariant, no alternatives possible
   2. Coordination Scaffold - voluntary equilibrium, alternatives existed
   3. Constructed Constraint - enforced rule, power asymmetries
   ================================================================ */

%% constraint_signature(+ConstraintID, -Signature)
%  Main entry point: classifies structural signature
%  Returns: natural_law | coordination_scaffold | constructed_constraint | ambiguous
constraint_signature(C, Signature) :-
    get_constraint_profile(C, Profile),
    classify_by_signature(Profile, Signature).

/* ================================================================
   PROFILE EXTRACTION
   
   Extracts 7 key features for signature classification:
   1. Accessibility Collapse (avg across time)
   2. Suppression Requirement (avg across time)
   3. Resistance Level (avg across time)
   4. Beneficiary Count (how many asymmetric winners)
   5. Has Viable Alternatives (were there choices?)
   6. Temporal Stability (does it evolve or remain constant?)
   7. Coordination Success (high access + low enforcement)
   ================================================================ */

get_constraint_profile(C, 
                      profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives, 
                             TemporalStability, CoordinationSuccess)) :-
    
    % Get averaged metrics across all levels
    get_metric_average(C, accessibility_collapse, AccessCollapse),
    get_metric_average(C, suppression_requirement, Suppression),
    get_metric_average(C, resistance, Resistance),
    
    % Count asymmetric beneficiaries
    count_power_beneficiaries(C, BeneficiaryCount),
    
    % Check for viable alternatives
    has_viable_alternatives(C, HasAlternatives),
    
    % Compute temporal stability
    compute_temporal_stability(C, TemporalStability),
    
    % Check coordination success pattern
    CoordinationSuccess = (AccessCollapse > 0.8, Suppression < 0.2).

%% get_metric_average(+Constraint, +MetricType, -Average)
%  Averages a metric across all levels (structural, organizational, class, individual)
get_metric_average(C, MetricType, Average) :-
    findall(Val, narrative_ontology:constraint_metric(C, MetricType, Val), Vals),
    (   Vals \= []
    ->  sum_list(Vals, Sum),
        length(Vals, N),
        Average is Sum / N
    ;   Average = 0.5  % Default if no data
    ).

%% count_power_beneficiaries(+Constraint, -Count)
%  Counts distinct classes with positive power changes
count_power_beneficiaries(C, Count) :-
    % Find intervals affecting this constraint
    findall(Class, (
        narrative_ontology:affects_constraint(I, C),
        narrative_ontology:intent_power_change(I, Class, Delta),
        Delta > 0.1  % Meaningful gain threshold
    ), Beneficiaries),
    sort(Beneficiaries, UniqueBeneficiaries),
    length(UniqueBeneficiaries, Count).

%% has_viable_alternatives(+Constraint, -HasAlternatives)
%  Checks if viable alternatives were considered (indicates choice vs necessity)
has_viable_alternatives(C, true) :-
    narrative_ontology:affects_constraint(I, C),
    narrative_ontology:intent_viable_alternative(I, _, _), !.
has_viable_alternatives(_, false).

%% compute_temporal_stability(+Constraint, -Stability)
%  Measures whether constraint metrics remain stable over time
%  Returns: stable | evolving
compute_temporal_stability(C, Stability) :-
    % Get suppression values at different time points for this constraint
    findall(Val, 
            narrative_ontology:constraint_metric(C, suppression_requirement, Val),
            Vals),
    (   Vals = []
    ->  Stability = unknown
    ;   Vals = [_SingleVal]
    ->  Stability = stable  % Only one measurement
    ;   compute_variance(Vals, Variance),
        (   Variance < 0.05
        ->  Stability = stable
        ;   Stability = evolving
        )
    ).

compute_variance(Vals, Variance) :-
    length(Vals, N),
    N > 0,
    sum_list(Vals, Sum),
    Mean is Sum / N,
    findall(SqDiff, (member(V, Vals), SqDiff is (V - Mean) * (V - Mean)), SqDiffs),
    sum_list(SqDiffs, SumSqDiffs),
    Variance is SumSqDiffs / N.

/* ================================================================
   SIGNATURE CLASSIFICATION LOGIC
   
   Decision Tree:
   
   1. Check Natural Law signature FIRST (most specific)
      - Extreme collapse + minimal enforcement + no alternatives
      - Examples: Chaitin's Ω, Heisenberg, Arrow's Theorem
      
   2. Check Coordination Scaffold SECOND
      - Extreme collapse + minimal enforcement + HAS alternatives
      - Examples: Special Relativity, SI Units, ISO Standards
      
   3. Check Constructed Constraint LAST (most general)
      - Positive enforcement OR beneficiary asymmetries
      - Examples: 26 USC §469, GS1 Barcodes, Hammurabi's Code
      
   4. Otherwise: ambiguous
   ================================================================ */

classify_by_signature(Profile, natural_law) :-
    natural_law_signature(Profile), !.

classify_by_signature(Profile, coordination_scaffold) :-
    coordination_scaffold_signature(Profile), !.

classify_by_signature(Profile, constructed_constraint) :-
    constructed_constraint_signature(Profile), !.

classify_by_signature(_, ambiguous).

/* ================================================================
   SIGNATURE 1: NATURAL LAW
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero beneficiaries (no asymmetric winners)
   ✓ No viable alternatives (not a choice)
   ✓ Temporally stable (doesn't evolve)
   
   Interpretation:
   This is an INHERENT PROPERTY of the system, not a human choice.
   It cannot be changed by coordination or enforcement.
   
   Examples:
   - Chaitin's Omega (algorithmic information limit)
   - Heisenberg Uncertainty (quantum measurement limit)
   - Arrow's Impossibility (social choice limit)
   - Second Law of Thermodynamics (entropy increase)
   ================================================================ */

natural_law_signature(profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives,
                             TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions
    v3_1_config:param(natural_law_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    v3_1_config:param(natural_law_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    v3_1_config:param(natural_law_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (CRITICAL for distinguishing from coordination)
    BeneficiaryCount == 0,  % No asymmetric winners
    HasAlternatives == false,  % Not a choice
    TemporalStability == stable.  % Doesn't evolve

/* ================================================================
   SIGNATURE 2: COORDINATION SCAFFOLD
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero or few beneficiaries (symmetric benefits)
   ✓ HAS viable alternatives (WAS a choice)
   ✓ May be stable or evolving (can be refined)
   
   KEY DISTINCTION from Natural Law:
   - Alternatives EXISTED → this was a COORDINATION CHOICE
   - Success is CONTINGENT → depends on continued acceptance
   - Could theoretically be replaced → not inherent to reality
   
   Interpretation:
   This is a SUCCESSFUL VOLUNTARY STANDARD that everyone adopted
   because it provides symmetric coordination benefits.
   
   Examples:
   - Special Relativity (replaced Newtonian mechanics)
   - SI Metric System (replaced imperial units)
   - UTC Time Standard (replaced local solar time)
   - IP Protocol (replaced other network protocols)
   ================================================================ */

coordination_scaffold_signature(profile(AccessCollapse, Suppression, Resistance,
                                       BeneficiaryCount, HasAlternatives,
                                       _TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions (same as natural law)
    v3_1_config:param(coordination_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    v3_1_config:param(coordination_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    v3_1_config:param(coordination_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (DIFFERENT from natural law)
    BeneficiaryCount =< 1,  % Symmetric or near-symmetric
    HasAlternatives == true.  % KEY: This WAS a choice

/* ================================================================
   SIGNATURE 3: CONSTRUCTED CONSTRAINT
   
   Diagnostic Pattern:
   ✓ Variable accessibility collapse
   ✓ Positive suppression (> 0.2) OR
   ✓ Positive resistance (> 0.2) OR
   ✓ Multiple beneficiaries (asymmetric gains)
   
   Interpretation:
   This is an INSTITUTIONALLY ENFORCED RULE that requires
   active maintenance and produces asymmetric outcomes.
   
   Examples:
   - 26 USC §469 (passive loss limitation)
   - GS1 Barcode System (licensing monopoly)
   - Hammurabi's Code (benefice system)
   - Lehman's Repo 105 (accounting fiction)
   ================================================================ */

constructed_constraint_signature(profile(_AccessCollapse, Suppression, Resistance,
                                        BeneficiaryCount, _HasAlternatives,
                                        _TemporalStability, _CoordinationSuccess)) :-
    
    % At least one indicator of constructed constraint
    (   Suppression > 0.2        % Requires enforcement
    ;   Resistance > 0.2         % Faces opposition  
    ;   BeneficiaryCount > 1     % Asymmetric benefits
    ).

/* ================================================================
   CONFIDENCE SCORING
   
   Returns confidence level based on how strongly the signature
   pattern matches the classification.
   ================================================================ */

%% signature_confidence(+ConstraintID, +Signature, -Confidence)
%  Returns: high | medium | low
signature_confidence(C, Signature, Confidence) :-
    get_constraint_profile(C, Profile),
    compute_signature_confidence(Profile, Signature, Confidence).

compute_signature_confidence(Profile, natural_law, Confidence) :-
    Profile = profile(AccessCollapse, Suppression, Resistance, _, _, _, _),
    
    % Count strong indicators
    findall(1, (
        (AccessCollapse > 0.95);
        (Suppression < 0.05);
        (Resistance < 0.05)
    ), Indicators),
    length(Indicators, Count),
    
    (   Count >= 3 -> Confidence = high
    ;   Count >= 2 -> Confidence = medium
    ;   Confidence = low
    ).

compute_signature_confidence(Profile, coordination_scaffold, Confidence) :-
    Profile = profile(AccessCollapse, Suppression, _, _, HasAlternatives, _, _),
    
    % Strong indicators
    findall(1, (
        (AccessCollapse > 0.95);
        (Suppression < 0.05);
        (HasAlternatives == true)  % Critical for coordination
    ), Indicators),
    length(Indicators, Count),
    
    (   Count >= 3 -> Confidence = high
    ;   Count >= 2 -> Confidence = medium
    ;   Confidence = low
    ).

compute_signature_confidence(Profile, constructed_constraint, Confidence) :-
    Profile = profile(_, Suppression, Resistance, BeneficiaryCount, _, _, _),
    
    % Count enforcement indicators
    findall(1, (
        (Suppression > 0.5);
        (Resistance > 0.5);
        (BeneficiaryCount > 2)
    ), Indicators),
    length(Indicators, Count),
    
    (   Count >= 2 -> Confidence = high
    ;   Count >= 1 -> Confidence = medium
    ;   Confidence = low
    ).

compute_signature_confidence(_, ambiguous, low).

/* ================================================================
   EXPLANATION GENERATION
   ================================================================ */

%% explain_signature(+ConstraintID, +Signature, -Explanation)
explain_signature(C, natural_law, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, R, _, _, _, _),
    format(atom(Explanation),
           'NATURAL LAW signature for ~w: Extreme inaccessibility (collapse=~2f) with minimal enforcement (suppression=~2f, resistance=~2f). No viable alternatives exist. This represents an inherent property of the system, not a coordination choice. Cannot be changed by policy.',
           [C, AC, S, R]).

explain_signature(C, coordination_scaffold, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, _, _, _, _, _),
    format(atom(Explanation),
           'COORDINATION SCAFFOLD signature for ~w: Extreme accessibility (collapse=~2f) with minimal enforcement (suppression=~2f). Viable alternatives existed historically, indicating this is a successful coordination standard rather than a natural law. Maintains adoption through symmetric benefits.',
           [C, AC, S]).

explain_signature(C, constructed_constraint, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(_, S, R, BC, _, _, _),
    format(atom(Explanation),
           'CONSTRUCTED CONSTRAINT signature for ~w: Active enforcement detected (suppression=~2f, resistance=~2f) with ~d asymmetric beneficiaries. This is an institutionally maintained rule requiring ongoing suppression energy.',
           [C, S, R, BC]).

explain_signature(C, ambiguous, Explanation) :-
    format(atom(Explanation),
           'AMBIGUOUS signature for ~w: Insufficient structural differentiation to classify. Consider gathering more data on alternatives, beneficiaries, and temporal evolution.',
           [C]).

/* ================================================================
   INTEGRATION WITH MODAL CLASSIFICATION
   
   This is the key integration point: structural signatures
   OVERRIDE modal classification when there's a mismatch.
   
   Example: Special Relativity
   - Modal classifier says: "mountain" (suppression=0, snapback=0)
   - Signature detector says: "coordination_scaffold"
   - Integrated result: "rope" with note about coordination success
   ================================================================ */

%% integrate_signature_with_modal(+Constraint, +ModalType, -AdjustedType)
%  Adjusts modal classification based on structural signature
integrate_signature_with_modal(C, ModalType, AdjustedType) :-
    constraint_signature(C, Signature),
    resolve_modal_signature_conflict(ModalType, Signature, AdjustedType).

% Natural laws stay as mountains (correct classification)
resolve_modal_signature_conflict(mountain, natural_law, mountain) :- !.

% Coordination scaffolds should be ROPES not mountains
resolve_modal_signature_conflict(mountain, coordination_scaffold, rope) :- !.

% Constructed constraints override mountain classification
resolve_modal_signature_conflict(mountain, constructed_constraint, tangled_rope) :- !.

% No conflict - keep original classification
resolve_modal_signature_conflict(ModalType, _, ModalType).
:- module(test_harness, [
    load_scenario/1,
    run_all_tests/1,
    quick_check/1
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).
:- use_module(v3_1_data_repair).
:- use_module(data_verification).
:- use_module(pattern_analysis).
:- use_module(intent_engine).
:- use_module(constraint_bridge).
:- use_module(drl_core).
:- use_module(uke_dr_bridge).
:- use_module(report_generator).

/* ================================================================
   v3.2 HARD-STOP TEST HARNESS
   ================================================================ */

run_all_tests(IntervalID) :-
    format('~n>>> INITIATING v3.1.1 DR-AUDIT SUITE: ~w~n', [IntervalID]),

    % Step 1: Data Repair (Epistemic Imputation)
    format('[STEP 1] Auditing and Repairing Measurements...~n'),
    v3_1_data_repair:repair_interval(IntervalID),

    % Step 2: Hard-Stop Verification Gate
    % v3.2 Change: This is now a strict boolean gate.
    format('[STEP 2] Verifying Data Integrity...~n'),
    (   data_verification:verify_all 
    ->  format('[OK] Verification passed. Proceeding to audit.~n')
    ;   (   format('[CRITICAL FAIL] Data integrity verification failed for ~w.~n', [IntervalID]),
            format('Summary generation aborted to prevent halluncinated analysis.~n'),
            !, fail  % Hard-stop the pipeline here
        )
    ),

    % Step 3: Compute System Dynamics (Only reached if Step 2 passes)
    format('[STEP 3] Computing System Gradients...~n'),
    pattern_analysis:analyze_interval(IntervalID),

    % Step 4: DRL Ontological Audit
    format('[STEP 4] DRL Ontological Audit...~n'),
    (   setof((C, Err, Sev), drl_core:dr_mismatch(C, Err, Sev), Errors)
    ->  forall(member((C, Err, Sev), Errors),
               format('  ! ALERT [~w]: ~w detected for ~w~n', [Sev, Err, C]))
    ;   format('  [OK] No Ontological Fraud detected.~n')
    ),

    % Step 5: Extracting Omegas
    format('[STEP 5] Extracting Omega Variables (Ω)...~n'),
    (   setof((OID, Type, Desc), narrative_ontology:omega_variable(OID, Type, Desc), Omegas)
    ->  forall(member((OID, Type, Desc), Omegas),
               format('  - Ω_~w [~w]: ~w~n', [OID, Type, Desc]))
    ;   format('  No reasoning blockers (Omegas) identified.~n')
    ),

    % Step 6: Final Reporting
    format('[STEP 6] Generating Executive Summary...~n'),
    report_generator:generate_full_report(IntervalID),

    % Step 7: Recursive Feedback
    format('[STEP 7] Generating LLM Refinement Manifest...~n'),
    report_generator:generate_llm_feedback(IntervalID).

%% quick_check(+IntervalID)
%  Diagnostic for identifying the primary "Binding Mountain" intensity.
quick_check(IntervalID) :-
    format('--- Diagnostic: ~w ---~n', [IntervalID]),
    (   drl_core:dr_type(Name, mountain),
        narrative_ontology:constraint_metric(Name, intensity, Intensity),
        Intensity > 0.8
    ->  format('CRITICAL MOUNTAIN: ~w (~2f)~n', [Name, Intensity])
    ;   format('No binding mountains detected.~n')).

load_scenario(lehman) :-
    consult('lehman_data.pl'),
    format('~n[SCENARIO] Loaded: Lehman Terminal Collapse (2008)~n').

/* ================================================================
   4. Interactive Help
   ================================================================ */

help :-
    format('~n--- v3.1 Structural Analysis Harness ---~n'),
    format('1. load_scenario(iran|lehman).~n'),
    format('2. run_all_tests(IntervalID).~n'),
    format('3. quick_check(IntervalID).~n').
% ============================================================================
% INDEXICAL CLASSIFICATION INTEGRATION TEST
% ============================================================================

% Test that the indexical system loads and basic queries work

:- begin_tests(indexical_integration).

% Test 1: Default context works
test(default_context_defined) :-
    constraint_indexing:default_context(Ctx),
    Ctx = context(
        agent_power(analytical),
        time_horizon(civilizational),
        exit_options(analytical),
        spatial_scope(global)
    ).

% Test 2: Catholic Church multi-perspective
test(catholic_church_multi_perspective) :-
    % Serf sees Mountain
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        mountain,
        context(agent_power(individual_powerless), 
                time_horizon(biographical), 
                exit_options(trapped), 
                spatial_scope(local))
    ),
    % Historian sees Noose
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        noose,
        context(agent_power(analytical), 
                time_horizon(civilizational), 
                exit_options(analytical), 
                spatial_scope(continental))
    ),
    % Pope sees Rope
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        rope,
        context(agent_power(institutional), 
                time_horizon(generational), 
                exit_options(arbitrage), 
                spatial_scope(continental))
    ).

% Test 3: Property rights perspectives
test(property_rights_perspectives) :-
    % Powerless sees Noose
    constraint_indexing:constraint_classification(
        property_rights_2025,
        noose,
        context(agent_power(individual_powerless),
                time_horizon(biographical),
                exit_options(trapped),
                spatial_scope(national))
    ),
    % Middle class sees Rope
    constraint_indexing:constraint_classification(
        property_rights_2025,
        rope,
        context(agent_power(individual_moderate),
                time_horizon(biographical),
                exit_options(mobile),
                spatial_scope(national))
    ).

% Test 4: Extractiveness scales with power
test(extractiveness_power_scaling) :-
    Context1 = context(agent_power(individual_powerless), 
                       time_horizon(biographical), 
                       exit_options(trapped), 
                       spatial_scope(national)),
    Context2 = context(agent_power(institutional), 
                       time_horizon(generational), 
                       exit_options(arbitrage), 
                       spatial_scope(global)),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, Context1, Score1),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, Context2, Score2),
    Score1 > Score2.  % Powerless experience more extraction

% Test 5: Immutability varies with time horizon
test(time_horizon_immutability) :-
    constraint_indexing:effective_immutability(biographical, trapped, mountain),
    constraint_indexing:effective_immutability(civilizational, trapped, rope).

% Test 6: Base extractiveness defined
test(base_extractiveness_defined) :-
    domain_priors:base_extractiveness(catholic_church_1200, E1),
    E1 = 0.7,
    domain_priors:base_extractiveness(property_rights_2025, E2),
    E2 = 0.5.

:- end_tests(indexical_integration).

% To run: swipl -g "consult('test_indexical_integration.pl'), run_tests." -t halt
:- module(uke_dr_bridge, [
    uke_status/3
]).

:- use_module(drl_core).
:- use_module(narrative_ontology).
:- use_module(constraint_bridge).

% Map Feasibility + DRL Type to UKE Status
uke_status(RecID, Status, Reasons) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is actually a recommendation
    narrative_ontology:affects_constraint(RecID, C),
    drl_core:dr_type(C, Type),
    constraint_bridge:recommendation_feasibility(RecID, Feas, Vetoes),
    determine_status(C, Type, Feas, Vetoes, Status, Reasons). % Passed C here

% --- Status Routing ---

determine_status(_, mountain, _, _, fantasy, 
    ['Recommendation attempts to modify a natural constraint (Mountain).']).

% Fixed: Uses C to check load-bearing status
determine_status(C, noose, _, _, blocked, 
    ['CRITICAL: Load-bearing Noose removal attempted without Scaffold.']) :-
    is_load_bearing(C),
    \+ narrative_ontology:entity(_, scaffold).

determine_status(_, Type, viable, [], viable, 
    ['No structural or political vetoes detected.']) :-
    member(Type, [rope, noose, zombie]).

determine_status(_, tangled_rope, _, _, aspirational, 
    ['System is Tangled: Extraction is rising. Coordination remains, but Reform is required.']).

% Fallback for unclassified constraints
determine_status(_, unknown, _, _, investigate, 
    ['Structural audit incomplete: Constraint metrics do not match known types.']).

determine_status(_, _, blocked_by_veto, Vetoes, blocked, [Msg]) :-
    format(string(Msg), 'Vetoed by: ~w', [Vetoes]).

% Helper
is_load_bearing(C) :- 
    drl_core:dr_type(C, noose),
    v3_1_config:param(noose_load_bearing_threshold, T),
    narrative_ontology:constraint_metric(C, extractiveness, X), 
    X > T.
:- module(v3_1_coercion_projection, [
    coercion_vector/3,
    coercion_magnitude/3,
    coercion_gradient/4,
    system_gradient/3,
    time_point_in_interval/2
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

% Base Vector
coercion_vector(Level, Time, [A, S, U, R]) :-
    measurement(_, _, accessibility_collapse(Level), Time, A),
    measurement(_, _, stakes_inflation(Level),      Time, S),
    measurement(_, _, suppression(Level),           Time, U),
    measurement(_, _, resistance(Level),            Time, R).

% Magnitude logic
coercion_magnitude(Level, Time, Kappa) :-
    coercion_vector(Level, Time, [A, S, U, R]),
    aggregation_weights(Level, WA, WS, WU, WR),
    Kappa is (WA * A) + (WS * S) + (WU * U) + (WR * R).

% Time points helper (Optimized)
time_point_in_interval(IntervalID, Time) :-
    interval(IntervalID, T_start, T_end),
    % Find all unique times present in the measurement database
    setof(T, is_measurement_time(T), AllTimes),
    member(Time, AllTimes),
    Time >= T_start,
    Time =< T_end,
    !.

% Helper to isolate the cross-module dynamic call
is_measurement_time(T) :-
    narrative_ontology:measurement(_, _, _, T, _).

% Gradient logic (Guarded)
coercion_gradient(Level, IntervalID, T_now, Grad) :-
    interval(IntervalID, _, T_end),
    T_now < T_end,
    % Use setof to find future points but wrap in a conditional to prevent looping
    (   setof(T_next, 
              (time_point_in_interval(IntervalID, T_next), T_next > T_now), 
              FuturePoints)
    ->  FuturePoints = [T_next|_], % Take the immediate next point
        coercion_magnitude(Level, T_now, K_now),
        coercion_magnitude(Level, T_next, K_next),
        Grad is K_next - K_now,
        ! % Prevent backtracking into the setof search
    ;   fail % Explicitly fail if no future points exist in the interval
    ).

% System Gradient (Safe Aggregation)
system_gradient(IntervalID, Time, SysGrad) :-
    findall(WG,
        ( level(L),
          influence_weight(L, W),
          % Ensure coercion_gradient succeeds before calculating
          coercion_gradient(L, IntervalID, Time, G),
          WG is W * G
        ),
        WGList),
    % Guard against empty lists at the end of a timeline
    (   WGList \= []
    ->  sum_list(WGList, SysGrad), !
    ;   SysGrad = 0.0 % Return neutral gradient if no changes are detected
    ).
:- module(v3_1_config, [
    param/2,
    aggregation_weights/5,
    influence_weight/2,
    level/1
]).

/* ================================================================
   1. HIERARCHY DEFINITIONS
   ================================================================ */

%% level(?Level)
% Defines the four analytical levels of the system.
level(structural).
level(organizational).
level(class).
level(individual).

/* ================================================================
   2. COMPONENT WEIGHTS (Alpha)
   Maps components (A, S, U, R) to magnitude (Kappa) per level.
   Formula: $\kappa = (\alpha_A \cdot A) + (\alpha_S \cdot S) + (\alpha_U \cdot U) + (\alpha_R \cdot R)$.
   ================================================================ */

%% aggregation_weights(+Level, -AlphaA, -AlphaS, -AlphaU, -AlphaR)
% Weights are shifted based on level-specific significance.
aggregation_weights(structural,     0.30, 0.20, 0.20, 0.20).
aggregation_weights(organizational, 0.30, 0.40, 0.15, 0.15).
aggregation_weights(class,          0.30, 0.20, 0.30, 0.30).
aggregation_weights(individual,     0.25, 0.25, 0.25, 0.25).

/* ================================================================
   3. INFLUENCE WEIGHTS (w_i)
   Determines how much each level contributes to the System Gradient (Gsys).
   ================================================================ */

%% influence_weight(+Level, -Weight)
influence_weight(structural,     0.40). % Highest impact on system stability.
influence_weight(organizational, 0.30).
influence_weight(class,          0.20).
influence_weight(individual,     0.10).

/* ================================================================
   4. INTENT & DETECTION THRESHOLDS
   Consolidated parameters for the intent_engine and pattern_analysis.
   ================================================================ */

% --- Gradient Thresholds ---
% Minimum change to be considered non-stable.
param(system_gradient_threshold, 0.01).
% Threshold for "Strong" intent classification.
param(system_gradient_strong_threshold, 1.00).

% --- Beneficiary Asymmetry ---
% Min power gain required to be identified as the "Main Beneficiary".
param(beneficiary_gain_min, 0.50).
% Max gain allowed for other classes to maintain "Asymmetry".
param(loser_loss_max_gain, 0.10).

% --- Suppression & Resistance Alignment ---
% Required thresholds for structural-level alignment.
param(structural_suppression_min, 0.70). 
param(structural_resistance_min, 0.70).

% --- Data Integrity ---
% Thresholds for high/medium confidence classification.
param(data_high_threshold, 0.95).
param(data_medium_threshold, 0.75).

/* ================================================================
   5. DEFERENTIAL REALISM (DR) THRESHOLDS
   ================================================================ */

% --- Mountain Boundaries ---
param(mountain_suppression_ceiling, 0.05). % noise floor
param(mountain_snap_back_ceiling,    0.00). 

% --- Rope Boundaries ---
param(rope_extraction_ceiling,       0.35). % Pure coordination
param(rope_suppression_ceiling,      0.15). 

% --- Tangled Rope (Hybrid Zone) ---
% Zone between Rope (0.35) and Noose (0.66)
param(tangled_rope_extraction_ceil,  0.65). 
param(tangled_rope_suppression_ceil, 0.45). % Fixed: 0.45 instead of 045

% --- Noose Boundaries ---
param(noose_extraction_floor,        0.66). 
param(noose_suppression_floor,       0.46). 
param(noose_load_bearing_threshold,  0.70). 

% --- Zombie Boundaries ---
param(zombie_extraction_ceiling,     0.10).

/* ================================================================
   6. STRUCTURAL SIGNATURE THRESHOLDS (v3.2)
   These parameters enable detection of constraint ORIGIN
   (natural law vs coordination scaffold vs constructed constraint)
   rather than just constraint METRICS.
   ================================================================ */

% --- Natural Law Signature ---
% Identifies inherent properties of reality (no alternatives possible)
param(natural_law_collapse_min,      0.85).  % Extreme universal inaccessibility
param(natural_law_suppression_max,   0.15).  % No enforcement needed
param(natural_law_resistance_max,    0.15).  % Cannot be resisted

% --- Coordination Scaffold Signature ---
% Identifies successful voluntary standards (alternatives existed)
param(coordination_collapse_min,     0.85).  % Universal adoption achieved
param(coordination_suppression_max,  0.15).  % Voluntary compliance
param(coordination_resistance_max,   0.15).  % Minimal opposition

% --- Constructed Constraint Signature ---
% Identifies institutionally enforced rules (power asymmetries)
param(constructed_suppression_min,   0.20).  % Requires enforcement
param(constructed_resistance_min,    0.20).  % Faces opposition
param(constructed_beneficiary_min,   2).     % Asymmetric gains threshold
:- module(v3_1_data_repair, [
    repair_interval/1
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(domain_priors). % NEW: Hook into the Epistemic Prior Library

% Ensure we can add facts to the ontology's measurement predicate
:- dynamic narrative_ontology:measurement/5.

/* ============================================================
   REPAIR ORCHESTRATOR
   ============================================================ */

%% repair_interval(+IntervalID)
% Audits the measurement vectors for a given interval and repairs gaps
% using domain-specific epistemic priors.
repair_interval(IntervalID) :-
    (   narrative_ontology:interval(IntervalID, T0, Tn)
    ->  format('~n[REPAIR] Auditing vectors for: ~w...~n', [IntervalID]),
        % Audit both endpoints for all analytical levels
        forall(v3_1_config:level(L), 
               ( repair_point(L, T0, IntervalID), 
                 repair_point(L, Tn, IntervalID) 
               )),
        true
    ;   format('~n[ERROR] Interval ~w not found in database.~n', [IntervalID]),
        false
    ).

%% repair_point(+Level, +Time, +IntervalID)
% Iterates through the 4-component coercion vector at a specific time point.
repair_point(Level, Time, IntervalID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components), 
           ensure_metric_exists(Metric, Time, IntervalID)).

%% ensure_metric_exists(+Metric, +Time, +IntervalID)
% Core v3.2 Imputation Logic:
% 1. Checks for existing data.
% 2. Resolves prior based on domain type.
% 3. Flags novelty if the domain is unmapped.
ensure_metric_exists(Metric, Time, IntervalID) :-
    % Look directly into the ontology for existing measurement
    narrative_ontology:measurement(_, _, Metric, Time, _)
    ->  true
    ;   (   % NEW: Fetch prior value instead of hard-coded 0.5
            domain_priors:get_prior(IntervalID, Metric, Value),
            
            % NEW: Surface novelty alert to the LLM/User
            (domain_priors:is_known_domain(IntervalID) -> true ; domain_priors:flag_novelty(IntervalID)),
            
            gensym(repair_m_, SyntheticID),
            % Assert the synthetic fact into the global ontology
            assertz(narrative_ontology:measurement(SyntheticID, IntervalID, Metric, Time, Value)),
            format('  [FIXED] Imputed ~w for ~w at T=~w~n', [Value, Metric, Time])
    ).
:- module(v3_1_stack, [
    initialize_system/0,
    run_scenario/2
]).

% 1. Load Core Knowledge Schema
:- use_module(narrative_ontology).      % Schema & Global Expansion
:- use_module(v3_1_config).             % Grounded Weights & Thresholds

% 2. Load Management & Control (NEW)
:- use_module(scenario_manager, []).    % Lifecycle Controller

% 3. Load Functional Engines (Imported but silenced for namespace safety)
:- use_module(v3_1_coercion_projection, []).
:- use_module(drl_core, []).
:- use_module(drl_modal_logic, []).
:- use_module(structural_signatures, []).  % NEW: v3.2 signature detection
:- use_module(v3_1_data_repair, []).
:- use_module(data_verification, []).
:- use_module(pattern_analysis, []).
:- use_module(intent_engine, []).

% 4. Load Diagnostic & UI
:- use_module(constraint_bridge, []).
:- use_module(uke_dr_bridge, []).
:- use_module(report_generator, []).
:- use_module(test_harness, []).

/* ================================================================
   SCENARIO ALIASES
   ================================================================ */

%% run_scenario(+File, +IntervalID)
%  Convenience alias for the Scenario Manager's load_and_run predicate.
run_scenario(File, IntervalID) :-
    scenario_manager:load_and_run(File, IntervalID).

/* ================================================================
   INITIALIZATION
   ================================================================ */

initialize_system :-
    format('~n====================================================~n'),
    format('   v3.1 STRUCTURAL ANALYSIS STACK INITIALIZED      ~n'),
    format('====================================================~n'),
    format('Namespace:  Consolidated & Grounded (v3.1)~n'),
    format('Control:    Scenario Manager Active~n'),
    format('Usage:      run_scenario(\'file.pl\', interval_id).~n'),
    format('====================================================~n').

:- initialize_system.
/* ================================================================
   v3.2 STRUCTURAL SIGNATURE CONFIGURATION
   
   Add these parameters to v3_1_config.pl to enable signature detection
   ================================================================ */

% NATURAL LAW SIGNATURE THRESHOLDS
% These identify constraints that are inherent properties of reality

param(natural_law_collapse_min, 0.85).
% Minimum accessibility collapse for natural law
% Natural laws affect everyone equally (high collapse)

param(natural_law_suppression_max, 0.15).
% Maximum suppression for natural law
% Natural laws don't require enforcement

param(natural_law_resistance_max, 0.15).
% Maximum resistance for natural law
% Natural laws cannot be effectively resisted

% COORDINATION SCAFFOLD SIGNATURE THRESHOLDS  
% These identify successful voluntary coordination standards

param(coordination_collapse_min, 0.85).
% Minimum accessibility collapse for coordination
% Successful standards achieve universal adoption

param(coordination_suppression_max, 0.15).
% Maximum suppression for coordination
% Coordination scaffolds are adopted voluntarily

param(coordination_resistance_max, 0.15).
% Maximum resistance for coordination
% Successful coordination faces minimal opposition

% CONSTRUCTED CONSTRAINT SIGNATURE THRESHOLDS
% These identify institutionally enforced rules

param(constructed_suppression_min, 0.20).
% Minimum suppression indicating institutional enforcement
% Constructed constraints require active maintenance

param(constructed_resistance_min, 0.20).
% Minimum resistance indicating opposition
% Constructed constraints face pushback

param(constructed_beneficiary_min, 2).
% Minimum beneficiary count for asymmetric gains
% Constructed constraints often benefit specific groups

/* ================================================================
   USAGE NOTES
   
   1. Natural Law vs Coordination Scaffold Distinction:
      Both have extreme collapse + minimal enforcement
      KEY DIFFERENCE: Coordination had viable alternatives
      
   2. Calibration Recommendations:
      - Start with these defaults
      - Monitor false positives in conceptual domains
      - Adjust collapse_min down if too restrictive
      - Adjust suppression_max up if missing constructs
      
   3. Integration with Existing System:
      - Structural signatures OVERRIDE modal classification
      - Use integrate_signature_with_modal/3 in report flow
      - Add signature explanations to audit output
   ================================================================ */
:- use_module(scenario_manager).
:- dynamic test_passed/1.
:- dynamic test_failed/2.

run_dynamic_suite :-
    retractall(test_passed(_)),
    retractall(test_failed(_, _)),
    writeln('--- STARTING DYNAMIC VALIDATION ---'),
    test_file('../prolog/testsets/26usc469.pl', 'tax_code_section_469', '26USC469', 1),
    test_file('../prolog/testsets/26usc469_real_estate_exemption.pl', 'section_469_c7_professional_threshold', '26USC469_REAL_ESTATE_EXEMPTION', 2),
    test_file('../prolog/testsets/academic_peer_review_gatekeeping.pl', 'unknown_interval', 'ACADEMIC_PEER_REVIEW_GATEKEEPING', 3),
    test_file('../prolog/testsets/academic_tenure_system.pl', 'tenure_track_cycle', 'ACADEMIC_TENURE_SYSTEM', 4),
    test_file('../prolog/testsets/adverse_possession.pl', 'adverse_possession_interval', 'ADVERSE_POSSESSION', 5),
    test_file('../prolog/testsets/ai_edu_decentralization.pl', 'ai_edu_decentralization', 'AI_EDU_DECENTRALIZATION', 6),
    test_file('../prolog/testsets/ai_evaluators_matching.pl', 'ai_evaluators_matching', 'AI_EVALUATORS_MATCHING', 7),
    test_file('../prolog/testsets/ai_professional_displacement.pl', 'ai_labor_shift_2026', 'AI_PROFESSIONAL_DISPLACEMENT', 8),
    test_file('../prolog/testsets/algorithmic_bias.pl', 'algo_bias_interval', 'ALGORITHMIC_BIAS', 9),
    test_file('../prolog/testsets/ancient_grudge_verona.pl', 'verona_feud_interval', 'ANCIENT_GRUDGE_VERONA', 10),
    test_file('../prolog/testsets/antifragility.pl', 'antifragility_interval', 'ANTIFRAGILITY', 11),
    test_file('../prolog/testsets/arctic_geopolitical_flashpoint.pl', 'arctic_ice_melt_2026', 'ARCTIC_GEOPOLITICAL_FLASHPOINT', 12),
    test_file('../prolog/testsets/arrows_impossibility_theorem.pl', 'arrows_era', 'ARROWS_IMPOSSIBILITY_THEOREM', 13),
    test_file('../prolog/testsets/asce_7_22_seismic_design.pl', 'asce_cycle_22', 'ASCE_7_22_SEISMIC_DESIGN', 14),
    test_file('../prolog/testsets/astm_d638_tensile_testing.pl', 'industrial_testing_regime', 'ASTM_D638_TENSILE_TESTING', 15),
    test_file('../prolog/testsets/authoritarian_power_paradox.pl', 'power_paradox_cycle', 'AUTHORITARIAN_POWER_PARADOX', 16),
    test_file('../prolog/testsets/automatic_enrollment_defaults.pl', 'automatic_enrollment_defaults', 'AUTOMATIC_ENROLLMENT_DEFAULTS', 17),
    test_file('../prolog/testsets/availability_heuristic.pl', 'availability_interval', 'AVAILABILITY_HEURISTIC', 18),
    test_file('../prolog/testsets/axiom_of_choice_determinacy.pl', 'ac_era', 'AXIOM_OF_CHOICE_DETERMINACY', 19),
    test_file('../prolog/testsets/banach_fixed_point.pl', 'banach_era', 'BANACH_FIXED_POINT', 20),
    test_file('../prolog/testsets/banach_tarski_paradox.pl', 'banach_tarski_era', 'BANACH_TARSKI_PARADOX', 21),
    test_file('../prolog/testsets/bap_of_pigs_operational_silo.pl', 'operation_zapata_timeline', 'BAP_OF_PIGS_OPERATIONAL_SILO', 22),
    test_file('../prolog/testsets/base_pair_complementarity.pl', 'dna_structure_discovery', 'BASE_PAIR_COMPLEMENTARITY', 23),
    test_file('../prolog/testsets/basel_problem_convergence.pl', 'basel_era', 'BASEL_PROBLEM_CONVERGENCE', 24),
    test_file('../prolog/testsets/berkshire_compounding_culture.pl', 'berkshire_compounding_culture', 'BERKSHIRE_COMPOUNDING_CULTURE', 25),
    test_file('../prolog/testsets/biological_curiosity.pl', 'biological_curiosity', 'BIOLOGICAL_CURIOSITY', 26),
    test_file('../prolog/testsets/birthday_paradox_collison.pl', 'birthday_era', 'BIRTHDAY_PARADOX_COLLISON', 27),
    test_file('../prolog/testsets/blackstone_carried_interest_taxation.pl', 'blackstone_ipo_restructuring', 'BLACKSTONE_CARRIED_INTEREST_TAXATION', 28),
    test_file('../prolog/testsets/blackstone_conflicts_of_interest.pl', 'blackstone_conflict_era', 'BLACKSTONE_CONFLICTS_OF_INTEREST', 29),
    test_file('../prolog/testsets/blackstone_smd_control.pl', 'blackstone_governance_lock', 'BLACKSTONE_SMD_CONTROL', 30),
    test_file('../prolog/testsets/blackstone_tax_receiveable_agreement.pl', 'blackstone_tra_life', 'BLACKSTONE_TAX_RECEIVEABLE_AGREEMENT', 31),
    test_file('../prolog/testsets/brouwer_fixed_point.pl', 'brouwer_era', 'BROUWER_FIXED_POINT', 32),
    test_file('../prolog/testsets/buffons_needle_pi_estimation.pl', 'buffon_era', 'BUFFONS_NEEDLE_PI_ESTIMATION', 33),
    test_file('../prolog/testsets/burali_forte_paradox.pl', 'burali_forti_interval', 'BURALI_FORTE_PARADOX', 34),
    test_file('../prolog/testsets/burden_of_proof_engineering_safety.pl', 'challenger_launch_decision', 'BURDEN_OF_PROOF_ENGINEERING_SAFETY', 35),
    test_file('../prolog/testsets/burden_of_proof_legal_criminal.pl', 'criminal_trial_sequence', 'BURDEN_OF_PROOF_LEGAL_CRIMINAL', 36),
    test_file('../prolog/testsets/burden_of_proof_scientific_empirical.pl', 'scientific_revolution_current', 'BURDEN_OF_PROOF_SCIENTIFIC_EMPIRICAL', 37),
    test_file('../prolog/testsets/busy_beaver_noncomputability.pl', 'busy_beaver_era', 'BUSY_BEAVER_NONCOMPUTABILITY', 38),
    test_file('../prolog/testsets/cantor_set_topology.pl', 'cantor_set_topology', 'CANTOR_SET_TOPOLOGY', 39),
    test_file('../prolog/testsets/cap_theorem.pl', 'cap_theorem_interval', 'CAP_THEOREM', 40),
    test_file('../prolog/testsets/carbon_credit_markets_2026.pl', 'carbon_credit_markets_2026_int', 'CARBON_CREDIT_MARKETS_2026', 41),
    test_file('../prolog/testsets/carrying_capacity.pl', 'carrying_capacity_interval', 'CARRYING_CAPACITY', 42),
    test_file('../prolog/testsets/central_limit_theorem_convergence.pl', 'clt_era', 'CENTRAL_LIMIT_THEOREM_CONVERGENCE', 43),
    test_file('../prolog/testsets/chaitins_omega_undecidability.pl', 'chaitin_era', 'CHAITINS_OMEGA_UNDECIDABILITY', 44),
    test_file('../prolog/testsets/challenger_o_ring_integrity.pl', 'unknown_interval', 'CHALLENGER_O_RING_INTEGRITY', 45),
    test_file('../prolog/testsets/china_critical_mineral_chokepoint.pl', 'unknown_interval', 'CHINA_CRITICAL_MINERAL_CHOKEPOINT', 46),
    test_file('../prolog/testsets/china_taiwan_reunification_mandate.pl', 'rejuvenation_centenary_cycle', 'CHINA_TAIWAN_REUNIFICATION_MANDATE', 47),
    test_file('../prolog/testsets/choice_architecture_design.pl', 'rope_design', 'CHOICE_ARCHITECTURE_DESIGN', 48),
    test_file('../prolog/testsets/church_turing_thesis.pl', 'church_turing_era', 'CHURCH_TURING_THESIS', 49),
    test_file('../prolog/testsets/cia_fbi_legal_wall.pl', 'pre_911_silo_regime', 'CIA_FBI_LEGAL_WALL', 50),
    test_file('../prolog/testsets/cinderella_midnight_deadline.pl', 'midnight_deadline_period', 'CINDERELLA_MIDNIGHT_DEADLINE', 51),
    test_file('../prolog/testsets/cloudflare_dual_class_asymmetry.pl', 'cloudflare_dual_class_asymmetry', 'CLOUDFLARE_DUAL_CLASS_ASYMMETRY', 52),
    test_file('../prolog/testsets/cobra_effect.pl', 'cobra_effect_interval', 'COBRA_EFFECT', 53),
    test_file('../prolog/testsets/cognitive_surrender_to_system_3.pl', 'system_3_emergence', 'COGNITIVE_SURRENDER_TO_SYSTEM_3', 54),
    test_file('../prolog/testsets/coinbase_crypto_volatility.pl', 'coinbase_ipo_window', 'COINBASE_CRYPTO_VOLATILITY', 55),
    test_file('../prolog/testsets/coinbase_regulatory_uncertainty.pl', 'coinbase_reg_pivot', 'COINBASE_REGULATORY_UNCERTAINTY', 56),
    test_file('../prolog/testsets/collatz_conjecture_determinism.pl', 'collatz_era', 'COLLATZ_CONJECTURE_DETERMINISM', 57),
    test_file('../prolog/testsets/college_admissions_market.pl', 'college_admissions_market', 'COLLEGE_ADMISSIONS_MARKET', 58),
    test_file('../prolog/testsets/colorado_sbe_decentralization_friction.pl', 'colorado_regulatory_window', 'COLORADO_SBE_DECENTRALIZATION_FRICTION', 59),
    test_file('../prolog/testsets/columbia_2026_elections.pl', 'colombia_2026_presidential_election', 'COLUMBIA_2026_ELECTIONS', 60),
    test_file('../prolog/testsets/comitatus_bond.pl', 'comitatus_era', 'COMITATUS_BOND', 61),
    test_file('../prolog/testsets/confirmation_bias.pl', 'confirmation_bias_interval', 'CONFIRMATION_BIAS', 62),
    test_file('../prolog/testsets/constitutional_consecration.pl', 'gettysburg_address_analysis', 'CONSTITUTIONAL_CONSECRATION', 63),
    test_file('../prolog/testsets/constitutional_supremacy.pl', 'marbury_v_madison_analysis', 'CONSTITUTIONAL_SUPREMACY', 64),
    test_file('../prolog/testsets/continuum_hypothesis_undecidability.pl', 'continuum_era', 'CONTINUUM_HYPOTHESIS_UNDECIDABILITY', 65),
    test_file('../prolog/testsets/conways_game_of_life_dynamics.pl', 'conway_era', 'CONWAYS_GAME_OF_LIFE_DYNAMICS', 66),
    test_file('../prolog/testsets/copyleft_viral_licensing.pl', 'copyleft_viral_licensing', 'COPYLEFT_VIRAL_LICENSING', 67),
    test_file('../prolog/testsets/copyright_protection.pl', 'copyright_protection', 'COPYRIGHT_PROTECTION', 68),
    test_file('../prolog/testsets/coumpounding_logic.pl', 'compounding_logic_analysis', 'COUMPOUNDING_LOGIC', 69),
    test_file('../prolog/testsets/countable_infinity_cardinality.pl', 'countable_infinity_cardinality', 'COUNTABLE_INFINITY_CARDINALITY', 70),
    test_file('../prolog/testsets/couples_residency_match.pl', 'couples_residency_match', 'COUPLES_RESIDENCY_MATCH', 71),
    test_file('../prolog/testsets/creative_commons_licensing.pl', 'creative_commons_licensing', 'CREATIVE_COMMONS_LICENSING', 72),
    test_file('../prolog/testsets/cuba_mandatrophic_collapse.pl', 'cuba_blackout_cycle', 'CUBA_MANDATROPHIC_COLLAPSE', 73),
    test_file('../prolog/testsets/cuban_missile_crisis_excomm_delibration.pl', 'thirteen_days_crisis', 'CUBAN_MISSILE_CRISIS_EXCOMM_DELIBRATION', 74),
    test_file('../prolog/testsets/currys_paradox.pl', 'currys_paradox_interval', 'CURRYS_PARADOX', 75),
    test_file('../prolog/testsets/damped_harmonics.pl', 'damped_harmonics', 'DAMPED_HARMONICS', 76),
    test_file('../prolog/testsets/dark_patterns_manipulation.pl', 'dark_patterns_manipulation', 'DARK_PATTERNS_MANIPULATION', 77),
    test_file('../prolog/testsets/dead_sea_effect.pl', 'dead_sea_effect', 'DEAD_SEA_EFFECT', 78),
    test_file('../prolog/testsets/deferential_realism_core.pl', 'dr_recursive_int', 'DEFERENTIAL_REALISM_CORE', 79),
    test_file('../prolog/testsets/dionysaic_frenzy.pl', 'dionysiac_frenzy_interval', 'DIONYSAIC_FRENZY', 80),
    test_file('../prolog/testsets/dunbars_number.pl', 'dunbar_interval', 'DUNBARS_NUMBER', 81),
    test_file('../prolog/testsets/dunning_kruger_effect.pl', 'dunning_kruger_interval', 'DUNNING_KRUGER_EFFECT', 82),
    test_file('../prolog/testsets/educational_unbundling_implementation.pl', 'implementation_window_2026', 'EDUCATIONAL_UNBUNDLING_IMPLEMENTATION', 83),
    test_file('../prolog/testsets/endowment_effect.pl', 'endowment_interval', 'ENDOWMENT_EFFECT', 84),
    test_file('../prolog/testsets/ergo_advanced_mechanisms.pl', 'storage_rent_interval', 'ERGO_ADVANCED_MECHANISMS', 85),
    test_file('../prolog/testsets/ergo_autolykos_asic_resistance.pl', 'ergo_mining_era', 'ERGO_AUTOLYKOS_ASIC_RESISTANCE', 86),
    test_file('../prolog/testsets/ergo_dexy_gold_protocol.pl', 'dexy_gold_interval', 'ERGO_DEXY_GOLD_PROTOCOL', 87),
    test_file('../prolog/testsets/ergo_lets_protocol.pl', 'ergo_lets_interval', 'ERGO_LETS_PROTOCOL', 88),
    test_file('../prolog/testsets/ergo_mixer_protocol.pl', 'ergo_mixer_interval', 'ERGO_MIXER_PROTOCOL', 89),
    test_file('../prolog/testsets/ergo_nipopows.pl', 'ergo_nipopows_interval', 'ERGO_NIPOPOWS', 90),
    test_file('../prolog/testsets/ergo_rosen_bridge_protocol.pl', 'rosen_bridge_interval', 'ERGO_ROSEN_BRIDGE_PROTOCOL', 91),
    test_file('../prolog/testsets/ergo_sig_usd_protocol.pl', 'sig_usd_interval', 'ERGO_SIG_USD_PROTOCOL', 92),
    test_file('../prolog/testsets/ergo_storage_rent_mechanism.pl', 'ergo_operational_era', 'ERGO_STORAGE_RENT_MECHANISM', 93),
    test_file('../prolog/testsets/ergodic_theorems.pl', 'ergodic_interval', 'ERGODIC_THEOREMS', 94),
    test_file('../prolog/testsets/euler_characteristic_topology.pl', 'euler_era', 'EULER_CHARACTERISTIC_TOPOLOGY', 95),
    test_file('../prolog/testsets/exploration_vs_exploitation.pl', 'exploration_vs_exploitation', 'EXPLORATION_VS_EXPLOITATION', 96),
    test_file('../prolog/testsets/factional_instability.pl', 'federalist_10_analysis', 'FACTIONAL_INSTABILITY', 97),
    test_file('../prolog/testsets/faint_blue_neural_bifurcation.pl', 'faint_blue_remodeling_event', 'FAINT_BLUE_NEURAL_BIFURCATION', 98),
    test_file('../prolog/testsets/fair_use_doctrine.pl', 'fair_use_doctrine', 'FAIR_USE_DOCTRINE', 99),
    test_file('../prolog/testsets/family_succession_and_decadence.pl', 'atsumono_period', 'FAMILY_SUCCESSION_AND_DECADENCE', 100),
    test_file('../prolog/testsets/fast_growing_hierarchy.pl', 'fast_growing_hierarchy', 'FAST_GROWING_HIERARCHY', 101),
    test_file('../prolog/testsets/feigenbaum_universality.pl', 'feigenbaum_universality', 'FEIGENBAUM_UNIVERSALITY', 102),
    test_file('../prolog/testsets/finite_simple_groups_classification.pl', 'cfsg_era', 'FINITE_SIMPLE_GROUPS_CLASSIFICATION', 103),
    test_file('../prolog/testsets/fittss_law.pl', 'fittss_law_interval', 'FITTSS_LAW', 104),
    test_file('../prolog/testsets/fmeca_procedures_1980.pl', 'fmeca_standard_era', 'FMECA_PROCEDURES_1980', 105),
    test_file('../prolog/testsets/fnudamental_theorem_of_algebra.pl', 'fta_era', 'FNUDAMENTAL_THEOREM_OF_ALGEBRA', 106),
    test_file('../prolog/testsets/four_color_theorem_topological_bound.pl', 'four_color_era', 'FOUR_COLOR_THEOREM_TOPOLOGICAL_BOUND', 107),
    test_file('../prolog/testsets/framing_effect.pl', 'framing_effect_interval', 'FRAMING_EFFECT', 108),
    test_file('../prolog/testsets/frankenstein_creation_hubris.pl', 'frankenstein_analysis', 'FRANKENSTEIN_CREATION_HUBRIS', 109),
    test_file('../prolog/testsets/gale_shapley.pl', 'unknown_interval', 'GALE_SHAPLEY', 110),
    test_file('../prolog/testsets/galois_theory_symmetry.pl', 'galois_era', 'GALOIS_THEORY_SYMMETRY', 111),
    test_file('../prolog/testsets/gamblers_ruin_stochastic_extinction.pl', 'ruin_era', 'GAMBLERS_RUIN_STOCHASTIC_EXTINCTION', 112),
    test_file('../prolog/testsets/gauss_bonnet_topology.pl', 'gauss_bonnet_era', 'GAUSS_BONNET_TOPOLOGY', 113),
    test_file('../prolog/testsets/genetic_algorithms_evolution.pl', 'genetic_algorithms_evolution', 'GENETIC_ALGORITHMS_EVOLUTION', 114),
    test_file('../prolog/testsets/genetic_predisposition.pl', 'genetic_predisposition_interval', 'GENETIC_PREDISPOSITION', 115),
    test_file('../prolog/testsets/gig_economy_algorithmic_managment.pl', 'platform_labor_epoch', 'GIG_ECONOMY_ALGORITHMIC_MANAGMENT', 116),
    test_file('../prolog/testsets/gilgamesh_mortality_limit.pl', 'gilgamesh_epic_cycle', 'GILGAMESH_MORTALITY_LIMIT', 117),
    test_file('../prolog/testsets/gita_kurukshetra.pl', 'dharma_of_kurukshetra', 'GITA_KURUKSHETRA', 118),
    test_file('../prolog/testsets/glp1_payload_efficiency_pivot.pl', 'glp1_market_impact_2026', 'GLP1_PAYLOAD_EFFICIENCY_PIVOT', 119),
    test_file('../prolog/testsets/godels_incompleteness_theorems.pl', 'goedel_era', 'GODELS_INCOMPLETENESS_THEOREMS', 120),
    test_file('../prolog/testsets/goldbach_conjecture.pl', 'goldbach_era', 'GOLDBACH_CONJECTURE', 121),
    test_file('../prolog/testsets/golden_handcuffs.pl', 'golden_handcuffs', 'GOLDEN_HANDCUFFS', 122),
    test_file('../prolog/testsets/goodharts_law.pl', 'goodharts_law_interval', 'GOODHARTS_LAW', 123),
    test_file('../prolog/testsets/gradient_descent_optimization.pl', 'gradient_descent_optimization', 'GRADIENT_DESCENT_OPTIMIZATION', 124),
    test_file('../prolog/testsets/graph_coloring_complexity.pl', 'graph_coloring_interval', 'GRAPH_COLORING_COMPLEXITY', 125),
    test_file('../prolog/testsets/greenland_seizure_trade_war.pl', 'greenland_crisis_2026', 'GREENLAND_SEIZURE_TRADE_WAR', 126),
    test_file('../prolog/testsets/greshams_law.pl', 'gresham_interval', 'GRESHAMS_LAW', 127),
    test_file('../prolog/testsets/grete_samsa_transition.pl', 'grete_ascendance_period', 'GRETE_SAMSA_TRANSITION', 128),
    test_file('../prolog/testsets/gs1_gln_identification.pl', 'gln_standard_lifecycle', 'GS1_GLN_IDENTIFICATION', 129),
    test_file('../prolog/testsets/gs1_standardized_identification.pl', 'gs1_spec_v25', 'GS1_STANDARDIZED_IDENTIFICATION', 130),
    test_file('../prolog/testsets/halting_problem_undecidability.pl', 'halting_era', 'HALTING_PROBLEM_UNDECIDABILITY', 131),
    test_file('../prolog/testsets/hamiltonian_path_complexity.pl', 'hamiltonian_path_complexity', 'HAMILTONIAN_PATH_COMPLEXITY', 132),
    test_file('../prolog/testsets/hammurabi.pl', 'hammurabi_lex_talionis', 'HAMMURABI', 133),
    test_file('../prolog/testsets/hanlons_razor.pl', 'hanlon_interval', 'HANLONS_RAZOR', 134),
    test_file('../prolog/testsets/harm_principle_liberty.pl', 'on_liberty_analysis', 'HARM_PRINCIPLE_LIBERTY', 135),
    test_file('../prolog/testsets/hawthorne_effect.pl', 'hawthorne_interval', 'HAWTHORNE_EFFECT', 136),
    test_file('../prolog/testsets/heisenberg_uncertainty.pl', 'heisenberg_interval', 'HEISENBERG_UNCERTAINTY', 137),
    test_file('../prolog/testsets/heuristic_optimization.pl', 'heuristic_optimization', 'HEURISTIC_OPTIMIZATION', 138),
    test_file('../prolog/testsets/hilberts_hotel_infinity.pl', 'hilberts_hotel_infinity', 'HILBERTS_HOTEL_INFINITY', 139),
    test_file('../prolog/testsets/hoa_covenants.pl', 'hoa_interval', 'HOA_COVENANTS', 140),
    test_file('../prolog/testsets/hydra_game.pl', 'hydra_interval', 'HYDRA_GAME', 141),
    test_file('../prolog/testsets/information_foraging_theory.pl', 'information_foraging_theory', 'INFORMATION_FORAGING_THEORY', 142),
    test_file('../prolog/testsets/inner_model_theory_constraints.pl', 'inner_model_era', 'INNER_MODEL_THEORY_CONSTRAINTS', 143),
    test_file('../prolog/testsets/innovators_dilemma.pl', 'innovators_dilemma_interval', 'INNOVATORS_DILEMMA', 144),
    test_file('../prolog/testsets/institutional_mutation_domestication.pl', 'institutional_mutation_domestication', 'INSTITUTIONAL_MUTATION_DOMESTICATION', 145),
    test_file('../prolog/testsets/iran_mandatrophic_collapse.pl', 'iran_unrest_2025', 'IRAN_MANDATROPHIC_COLLAPSE', 146),
    test_file('../prolog/testsets/iron_law_of_oligarchy.pl', 'oligarchy_interval', 'IRON_LAW_OF_OLIGARCHY', 147),
    test_file('../prolog/testsets/japanese_energy_scaffold_2025.pl', 'japan_gx_transition', 'JAPANESE_ENERGY_SCAFFOLD_2025', 148),
    test_file('../prolog/testsets/jevons_paradox.pl', 'jevons_interval', 'JEVONS_PARADOX', 149),
    test_file('../prolog/testsets/kidney_exchange_market.pl', 'kidney_exchange_market', 'KIDNEY_EXCHANGE_MARKET', 150),
    test_file('../prolog/testsets/kirby_paris_theorem.pl', 'kirby_paris_interval', 'KIRBY_PARIS_THEOREM', 151),
    test_file('../prolog/testsets/kjv_great_awakening.pl', 'great_awakening_rekindling', 'KJV_GREAT_AWAKENING', 152),
    test_file('../prolog/testsets/kjv_linguistic_residue.pl', 'kjv_linguistic_residue', 'KJV_LINGUISTIC_RESIDUE', 153),
    test_file('../prolog/testsets/kjv_puritan_new_world_exit.pl', 'puritan_new_world_pivot', 'KJV_PURITAN_NEW_WORLD_EXIT', 154),
    test_file('../prolog/testsets/kjv_textual_authority.pl', 'kjv_textual_authority', 'KJV_TEXTUAL_AUTHORITY', 155),
    test_file('../prolog/testsets/kleene_recursion_theorem.pl', 'kleene_era', 'KLEENE_RECURSION_THEOREM', 156),
    test_file('../prolog/testsets/large_cardinals_foundations.pl', 'large_cardinal_era', 'LARGE_CARDINALS_FOUNDATIONS', 157),
    test_file('../prolog/testsets/law_of_diminishing_returns.pl', 'diminishing_returns_interval', 'LAW_OF_DIMINISHING_RETURNS', 158),
    test_file('../prolog/testsets/legacy_system_technical_debt.pl', 'software_lifecycle_r7', 'LEGACY_SYSTEM_TECHNICAL_DEBT', 159),
    test_file('../prolog/testsets/lehman_repo_105.pl', 'unknown_interval', 'LEHMAN_REPO_105', 160),
    test_file('../prolog/testsets/liar_paradox.pl', 'liar_paradox_interval', 'LIAR_PARADOX', 161),
    test_file('../prolog/testsets/lindy_effect.pl', 'lindy_interval', 'LINDY_EFFECT', 162),
    test_file('../prolog/testsets/lln_convergence.pl', 'lln_era', 'LLN_CONVERGENCE', 163),
    test_file('../prolog/testsets/lobs_theorem.pl', 'lobs_theorem_interval', 'LOBS_THEOREM', 164),
    test_file('../prolog/testsets/local_vs_global_optima.pl', 'local_vs_global_optima', 'LOCAL_VS_GLOBAL_OPTIMA', 165),
    test_file('../prolog/testsets/logistic_map_dynamics.pl', 'logistic_map_era', 'LOGISTIC_MAP_DYNAMICS', 166),
    test_file('../prolog/testsets/lorenz_attractor_dynamics.pl', 'lorenz_era', 'LORENZ_ATTRACTOR_DYNAMICS', 167),
    test_file('../prolog/testsets/lowenheim_skolem_theorem.pl', 'lowenheim_skolem_interval', 'LOWENHEIM_SKOLEM_THEOREM', 168),
    test_file('../prolog/testsets/lula_hemisphere_2026.pl', 'lula_hemisphere_2026', 'LULA_HEMISPHERE_2026', 169),
    test_file('../prolog/testsets/magna_carta_liberties.pl', 'magna_carta_liberties', 'MAGNA_CARTA_LIBERTIES', 170),
    test_file('../prolog/testsets/mandatrophic_margin_collapse.pl', 'mandatrophy_cycle', 'MANDATROPHIC_MARGIN_COLLAPSE', 171),
    test_file('../prolog/testsets/mandatrophic_margin_collapse_diagnostic.pl', 'mandatrophy_lifecycle', 'MANDATROPHIC_MARGIN_COLLAPSE_DIAGNOSTIC', 172),
    test_file('../prolog/testsets/marriage_problem.pl', 'optimal_stopping_marriage', 'MARRIAGE_PROBLEM', 173),
    test_file('../prolog/testsets/mars_rovers_navigational_autonomy.pl', 'mars_autonomy_evolution', 'MARS_ROVERS_NAVIGATIONAL_AUTONOMY', 174),
    test_file('../prolog/testsets/martian_signal_latency.pl', 'mariner_to_msl_era', 'MARTIAN_SIGNAL_LATENCY', 175),
    test_file('../prolog/testsets/matching_markets_general.pl', 'matching_markets_general', 'MATCHING_MARKETS_GENERAL', 176),
    test_file('../prolog/testsets/material_tensile_strength.pl', 'tensile_strength_interval', 'MATERIAL_TENSILE_STRENGTH', 177),
    test_file('../prolog/testsets/max_flow.pl', 'max_flow_min_cut', 'MAX_FLOW', 178),
    test_file('../prolog/testsets/mco_unit_system_discontinuity.pl', 'mco_failure_trajectory', 'MCO_UNIT_SYSTEM_DISCONTINUITY', 179),
    test_file('../prolog/testsets/medical_residency_match.pl', 'medical_residency_match', 'MEDICAL_RESIDENCY_MATCH', 180),
    test_file('../prolog/testsets/medieval_church_hegomony.pl', 'medieval_church_hegemony', 'MEDIEVAL_CHURCH_HEGOMONY', 181),
    test_file('../prolog/testsets/metamorphosis_samsa.pl', 'samsa_transformation_period', 'METAMORPHOSIS_SAMSA', 182),
    test_file('../prolog/testsets/micro_robot_electronics_integration.pl', 'ek_robot_integration_cycle', 'MICRO_ROBOT_ELECTRONICS_INTEGRATION', 183),
    test_file('../prolog/testsets/mil_std_461g_emi_control.pl', 'mil_std_461g_era', 'MIL_STD_461G_EMI_CONTROL', 184),
    test_file('../prolog/testsets/mil_std_810f_tailoring.pl', 'mil_std_810f_era', 'MIL_STD_810F_TAILORING', 185),
    test_file('../prolog/testsets/minimax_decision_rule.pl', 'minimax_era', 'MINIMAX_DECISION_RULE', 186),
    test_file('../prolog/testsets/monty_hall_conditional_probability.pl', 'probability_paradox_era', 'MONTY_HALL_CONDITIONAL_PROBABILITY', 187),
    test_file('../prolog/testsets/moores_law.pl', 'moores_law_interval', 'MOORES_LAW', 188),
    test_file('../prolog/testsets/nasa_faster_better_cheaper.pl', 'fbc_era_operations', 'NASA_FASTER_BETTER_CHEAPER', 189),
    test_file('../prolog/testsets/nash_equilibrium_coordination.pl', 'nash_era', 'NASH_EQUILIBRIUM_COORDINATION', 190),
    test_file('../prolog/testsets/network_effects.pl', 'network_effects_interval', 'NETWORK_EFFECTS', 191),
    test_file('../prolog/testsets/newtons_method_convergence.pl', 'newton_era', 'NEWTONS_METHOD_CONVERGENCE', 192),
    test_file('../prolog/testsets/no_cloning_theorem.pl', 'no_cloning_interval', 'NO_CLONING_THEOREM', 193),
    test_file('../prolog/testsets/noethers_theorem_symmetry.pl', 'noether_era', 'NOETHERS_THEOREM_SYMMETRY', 194),
    test_file('../prolog/testsets/non_compete_agreements.pl', 'non_compete_agreements', 'NON_COMPETE_AGREEMENTS', 195),
    test_file('../prolog/testsets/nonstandard_arithmetic_models.pl', 'skolem_era', 'NONSTANDARD_ARITHMETIC_MODELS', 196),
    test_file('../prolog/testsets/north_korea_songun_mandatrophy.pl', 'dprk_songun_cycle', 'NORTH_KOREA_SONGUN_MANDATROPHY', 197),
    test_file('../prolog/testsets/overton_window.pl', 'overton_interval', 'OVERTON_WINDOW', 198),
    test_file('../prolog/testsets/p_vs_np.pl', 'p_vs_np_interval', 'P_VS_NP', 199),
    test_file('../prolog/testsets/pareto_principle.pl', 'pareto_interval', 'PARETO_PRINCIPLE', 200),
    test_file('../prolog/testsets/parkinsons_law.pl', 'parkinson_interval', 'PARKINSONS_LAW', 201),
    test_file('../prolog/testsets/peano_curve_mapping.pl', 'peano_era', 'PEANO_CURVE_MAPPING', 202),
    test_file('../prolog/testsets/permissive_software_licensing.pl', 'permissive_software_licensing', 'PERMISSIVE_SOFTWARE_LICENSING', 203),
    test_file('../prolog/testsets/peter_principle.pl', 'peter_interval', 'PETER_PRINCIPLE', 204),
    test_file('../prolog/testsets/planetary_boundaries.pl', 'unknown_interval', 'PLANETARY_BOUNDARIES', 205),
    test_file('../prolog/testsets/planning_fallacy.pl', 'planning_fallacy_interval', 'PLANNING_FALLACY', 206),
    test_file('../prolog/testsets/platform_cooperativism_governance.pl', 'cooperative_labor_era', 'PLATFORM_COOPERATIVISM_GOVERNANCE', 207),
    test_file('../prolog/testsets/poincare_conjucture.pl', 'poincare_era', 'POINCARE_CONJUCTURE', 208),
    test_file('../prolog/testsets/prime_number_theorem.pl', 'pnt_era', 'PRIME_NUMBER_THEOREM', 209),
    test_file('../prolog/testsets/prisoners_dilemma_equilibrium.pl', 'game_theory_era', 'PRISONERS_DILEMMA_EQUILIBRIUM', 210),
    test_file('../prolog/testsets/proof_of_work_consensus.pl', 'bitcoin_consensus_era', 'PROOF_OF_WORK_CONSENSUS', 211),
    test_file('../prolog/testsets/public_domain_commons.pl', 'public_domain_commons', 'PUBLIC_DOMAIN_COMMONS', 212),
    test_file('../prolog/testsets/pythagorean_theorem_geometric_constancy.pl', 'pythagorean_era', 'PYTHAGOREAN_THEOREM_GEOMETRIC_CONSTANCY', 213),
    test_file('../prolog/testsets/qualified_immunity.pl', 'qi_interval', 'QUALIFIED_IMMUNITY', 214),
    test_file('../prolog/testsets/quantum_entanglement_protocol.pl', 'interstellar_quantum_link', 'QUANTUM_ENTANGLEMENT_PROTOCOL', 215),
    test_file('../prolog/testsets/quine_self_replication.pl', 'quine_era', 'QUINE_SELF_REPLICATION', 216),
    test_file('../prolog/testsets/qwerty_vs_dvorak.pl', 'qwerty_lockin_interval', 'QWERTY_VS_DVORAK', 217),
    test_file('../prolog/testsets/railway_gauge_standard.pl', 'railway_gauge_interval', 'RAILWAY_GAUGE_STANDARD', 218),
    test_file('../prolog/testsets/reciprocity_laws_math.pl', 'reciprocity_laws_math', 'RECIPROCITY_LAWS_MATH', 219),
    test_file('../prolog/testsets/regulatory_capture.pl', 'capture_interval', 'REGULATORY_CAPTURE', 220),
    test_file('../prolog/testsets/relativity_of_simultaneity.pl', 'relativity_of_simultaneity', 'RELATIVITY_OF_SIMULTANEITY', 221),
    test_file('../prolog/testsets/relativity_physical_invariance.pl', 'relativity_physical_invariance', 'RELATIVITY_PHYSICAL_INVARIANCE', 222),
    test_file('../prolog/testsets/rfc9293_interoperability.pl', 'tcp_rfc9293_interoperability', 'RFC9293_INTEROPERABILITY', 223),
    test_file('../prolog/testsets/rfc9293_state_machine.pl', 'tcp_state_machine_logic', 'RFC9293_STATE_MACHINE', 224),
    test_file('../prolog/testsets/rices_theorem_undecidability.pl', 'rices_era', 'RICES_THEOREM_UNDECIDABILITY', 225),
    test_file('../prolog/testsets/rogers_commission_institutional_analysis.pl', 'challenger_post_mortem', 'ROGERS_COMMISSION_INSTITUTIONAL_ANALYSIS', 226),
    test_file('../prolog/testsets/rotation_seven_black_soil.pl', 'black_soil_toxicity', 'ROTATION_SEVEN_BLACK_SOIL', 227),
    test_file('../prolog/testsets/rotation_seven_isolation.pl', 'protocol_r7_isolation', 'ROTATION_SEVEN_ISOLATION', 228),
    test_file('../prolog/testsets/rotation_seven_kubo_ranking.pl', 'kubo_ranking_system_r7', 'ROTATION_SEVEN_KUBO_RANKING', 229),
    test_file('../prolog/testsets/rotmigration_decision_threshold.pl', 'migration_theory_review', 'ROTMIGRATION_DECISION_THRESHOLD', 230),
    test_file('../prolog/testsets/royal_navy_middle_east_withdrawal.pl', 'rn_withdrawal_cycle', 'ROYAL_NAVY_MIDDLE_EAST_WITHDRAWAL', 231),
    test_file('../prolog/testsets/russells_paradox_self_reference.pl', 'russell_era', 'RUSSELLS_PARADOX_SELF_REFERENCE', 232),
    test_file('../prolog/testsets/russian_war_cannibalization.pl', 'russia_cannibalization_cycle', 'RUSSIAN_WAR_CANNIBALIZATION', 233),
    test_file('../prolog/testsets/s1_airbnb.pl', 'airbnb_ipo_era', 'S1_AIRBNB', 234),
    test_file('../prolog/testsets/s1_visa.pl', 'visa_ipo_window', 'S1_VISA', 235),
    test_file('../prolog/testsets/s1_visa_judgment_sharing_agreement.pl', 'visa_litigation_ringfencing', 'S1_VISA_JUDGMENT_SHARING_AGREEMENT', 236),
    test_file('../prolog/testsets/sapir_whorf_hypothesis.pl', 'sapir_whorf_interval', 'SAPIR_WHORF_HYPOTHESIS', 237),
    test_file('../prolog/testsets/sat_csp_complexity.pl', 'sat_csp_interval', 'SAT_CSP_COMPLEXITY', 238),
    test_file('../prolog/testsets/self_surpassing_superman.pl', 'zarathustra_hazar', 'SELF_SURPASSING_SUPERMAN', 239),
    test_file('../prolog/testsets/shannon_entropy_limit.pl', 'shannon_entropy_limit', 'SHANNON_ENTROPY_LIMIT', 240),
    test_file('../prolog/testsets/silicon_lexicon_overload.pl', 'silicon_lexicon_overload', 'SILICON_LEXICON_OVERLOAD', 241),
    test_file('../prolog/testsets/skills_based_hiring.pl', 'skills_based_hiring', 'SKILLS_BASED_HIRING', 242),
    test_file('../prolog/testsets/skolems_paradox.pl', 'skolems_paradox_interval', 'SKOLEMS_PARADOX', 243),
    test_file('../prolog/testsets/sludge_bureaucratic_friction.pl', 'sludge_bureaucratic_friction', 'SLUDGE_BUREAUCRATIC_FRICTION', 244),
    test_file('../prolog/testsets/social_loafing.pl', 'social_loafing_interval', 'SOCIAL_LOAFING', 245),
    test_file('../prolog/testsets/social_media_participation_threshold.pl', 'social_media_2025_cycle', 'SOCIAL_MEDIA_PARTICIPATION_THRESHOLD', 246),
    test_file('../prolog/testsets/sorites_paradox.pl', 'sorites_interval', 'SORITES_PARADOX', 247),
    test_file('../prolog/testsets/south_china_sea_arbitration_2016_2026.pl', 'scs_legal_era', 'SOUTH_CHINA_SEA_ARBITRATION_2016_2026', 248),
    test_file('../prolog/testsets/square_cube_law.pl', 'square_cube_interval', 'SQUARE_CUBE_LAW', 249),
    test_file('../prolog/testsets/st_petersburg_paradox.pl', 'st_petersburg_era', 'ST_PETERSBURG_PARADOX', 250),
    test_file('../prolog/testsets/stable_marriage_coordination.pl', 'matching_theory_era', 'STABLE_MARRIAGE_COORDINATION', 251),
    test_file('../prolog/testsets/starwars_evolutionary_mutation.pl', 'galactic_selection_event', 'STARWARS_EVOLUTIONARY_MUTATION', 252),
    test_file('../prolog/testsets/statecraft_virtu.pl', 'statecraft_virtu_analysis', 'STATECRAFT_VIRTU', 253),
    test_file('../prolog/testsets/stoic_logos_governance.pl', 'antonine_period', 'STOIC_LOGOS_GOVERNANCE', 254),
    test_file('../prolog/testsets/strange_attractor_dynamics.pl', 'strange_attractor_dynamics', 'STRANGE_ATTRACTOR_DYNAMICS', 255),
    test_file('../prolog/testsets/sts86_ascent_checklist.pl', 'sts86_ascent_checklist', 'STS86_ASCENT_CHECKLIST', 256),
    test_file('../prolog/testsets/sturgeons_law.pl', 'sturgeon_interval', 'STURGEONS_LAW', 257),
    test_file('../prolog/testsets/sunk_cost_fallacy.pl', 'sunk_cost_interval', 'SUNK_COST_FALLACY', 258),
    test_file('../prolog/testsets/suslin_hypothesis_undecidability.pl', 'suslin_era', 'SUSLIN_HYPOTHESIS_UNDECIDABILITY', 259),
    test_file('../prolog/testsets/sylow_theorems_group_theory.pl', 'sylow_era', 'SYLOW_THEOREMS_GROUP_THEORY', 260),
    test_file('../prolog/testsets/taiwan_existential_sovereignty.pl', 'taiwan_status_quo_cycle', 'TAIWAN_EXISTENTIAL_SOVEREIGNTY', 261),
    test_file('../prolog/testsets/taiwan_strait_hegemony_shift.pl', 'hegemony_transition_window', 'TAIWAN_STRAIT_HEGEMONY_SHIFT', 262),
    test_file('../prolog/testsets/tarski_undefinability.pl', 'tarski_interval', 'TARSKI_UNDEFINABILITY', 263),
    test_file('../prolog/testsets/texas_hispanic_political_pivot.pl', 'tx_pivot_window_2026', 'TEXAS_HISPANIC_POLITICAL_PIVOT', 264),
    test_file('../prolog/testsets/the_bacchae_madness_protocol.pl', 'theban_dionysian_conflict', 'THE_BACCHAE_MADNESS_PROTOCOL', 265),
    test_file('../prolog/testsets/the_calm_protocol_suppression.pl', 'the_calm_expedition_window', 'THE_CALM_PROTOCOL_SUPPRESSION', 266),
    test_file('../prolog/testsets/the_wall_procedural_barrier.pl', 'the_wall_2001', 'THE_WALL_PROCEDURAL_BARRIER', 267),
    test_file('../prolog/testsets/thermodynamics_entropy.pl', 'thermodynamics_entropy_interval', 'THERMODYNAMICS_ENTROPY', 268),
    test_file('../prolog/testsets/three_body_unpredicability.pl', 'celestial_mechanics_era', 'THREE_BODY_UNPREDICABILITY', 269),
    test_file('../prolog/testsets/tractarian_logic_limit.pl', 'tractarian_logic_limit', 'TRACTARIAN_LOGIC_LIMIT', 270),
    test_file('../prolog/testsets/trade_secret_law.pl', 'trade_secret_law', 'TRADE_SECRET_LAW', 271),
    test_file('../prolog/testsets/tragedy_of_the_commons.pl', 'commons_interval', 'TRAGEDY_OF_THE_COMMONS', 272),
    test_file('../prolog/testsets/traveling_salesperson_problem.pl', 'traveling_salesperson_problem', 'TRAVELING_SALESPERSON_PROBLEM', 273),
    test_file('../prolog/testsets/trojan_war_spoils.pl', 'trojan_collapse_interval', 'TROJAN_WAR_SPOILS', 274),
    test_file('../prolog/testsets/trump_making_china_great_2026.pl', 'post_trump_return', 'TRUMP_MAKING_CHINA_GREAT_2026', 275),
    test_file('../prolog/testsets/trumps_second_term_authoritarianism_2026.pl', 'trump_ii_year_one', 'TRUMPS_SECOND_TERM_AUTHORITARIANISM_2026', 276),
    test_file('../prolog/testsets/udhr_1946.pl', 'un_era', 'UDHR_1946', 277),
    test_file('../prolog/testsets/ulysses_chp01.pl', 'telemachus_morning', 'ULYSSES_CHP01', 278),
    test_file('../prolog/testsets/ulysses_chp02.pl', 'nestor_afternoon', 'ULYSSES_CHP02', 279),
    test_file('../prolog/testsets/ulysses_chp03.pl', 'proteus_strand_walk', 'ULYSSES_CHP03', 280),
    test_file('../prolog/testsets/ulysses_chp04.pl', 'bloom_kosher_transgression', 'ULYSSES_CHP04', 281),
    test_file('../prolog/testsets/ulysses_chp05.pl', 'bloom_secret_correspondence', 'ULYSSES_CHP05', 282),
    test_file('../prolog/testsets/ulysses_chp06.pl', 'bloom_exclusion_interval', 'ULYSSES_CHP06', 283),
    test_file('../prolog/testsets/ulysses_chp07.pl', 'bloom_aeolus_interval', 'ULYSSES_CHP07', 284),
    test_file('../prolog/testsets/ulysses_chp08.pl', 'lestrygonian_metabolism_chp8_interval', 'ULYSSES_CHP08', 285),
    test_file('../prolog/testsets/ulysses_chp09.pl', 'stephen_shakespeare_ghost', 'ULYSSES_CHP09', 286),
    test_file('../prolog/testsets/ulysses_chp10.pl', 'the_viceregal_cavalcade', 'ULYSSES_CHP10', 287),
    test_file('../prolog/testsets/ulysses_chp11.pl', 'bloom_sirens_interval', 'ULYSSES_CHP11', 288),
    test_file('../prolog/testsets/ulysses_chp12.pl', 'bloom_exclusion_id', 'ULYSSES_CHP12', 289),
    test_file('../prolog/testsets/ulysses_chp13.pl', 'gerty_bloom_interval', 'ULYSSES_CHP13', 290),
    test_file('../prolog/testsets/ulysses_chp14.pl', 'gestation_wombfruit_id', 'ULYSSES_CHP14', 291),
    test_file('../prolog/testsets/ulysses_chp15.pl', 'nighttown_vigil_id', 'ULYSSES_CHP15', 292),
    test_file('../prolog/testsets/ulysses_chp16.pl', 'bloom_samaritan_id', 'ULYSSES_CHP16', 293),
    test_file('../prolog/testsets/ulysses_chp17.pl', 'bloom_ithaca_interval', 'ULYSSES_CHP17', 294),
    test_file('../prolog/testsets/ulysses_chp18.pl', 'molly_affirmation_id', 'ULYSSES_CHP18', 295),
    test_file('../prolog/testsets/unclos_2026.pl', 'unclos_era', 'UNCLOS_2026', 296),
    test_file('../prolog/testsets/union_protection_underperformance.pl', 'labor_management_conflict_r1', 'UNION_PROTECTION_UNDERPERFORMANCE', 297),
    test_file('../prolog/testsets/us_suburban_zoning_2025.pl', 'us_suburban_zoning_2025', 'US_SUBURBAN_ZONING_2025', 298),
    test_file('../prolog/testsets/us_two_party_duopoly.pl', 'us_election_cycle_2026', 'US_TWO_PARTY_DUOPOLY', 299),
    test_file('../prolog/testsets/van_der_waerden_theorem.pl', 'van_der_waerden_interval', 'VAN_DER_WAERDEN_THEOREM', 300),
    test_file('../prolog/testsets/viral_transmission_rates.pl', 'viral_transmission_rates', 'VIRAL_TRANSMISSION_RATES', 301),
    test_file('../prolog/testsets/weber_fechner_law.pl', 'weber_fechner_interval', 'WEBER_FECHNER_LAW', 302),
    test_file('../prolog/testsets/whitehead_problem_undecidability.pl', 'whitehead_era', 'WHITEHEAD_PROBLEM_UNDECIDABILITY', 303),
    test_file('../prolog/testsets/winners_curse.pl', 'winners_curse_interval', 'WINNERS_CURSE', 304),
    test_file('../prolog/testsets/xi_mao_ideological_centralization.pl', 'chinese_leadership_cycle', 'XI_MAO_IDEOLOGICAL_CENTRALIZATION', 305),
    test_file('../prolog/testsets/zipfs_law.pl', 'zipf_interval', 'ZIPFS_LAW', 306),
    count_and_report.

test_file(Path, ID, Label, N) :-
    format('~n[~w] DOMAIN: ~w (~w)~n', [N, Label, Path]),
    (   catch(load_and_run(Path, ID), E, (assertz(test_failed(Path, E)), format('[FAIL] Exception: ~w~n', [E]), fail))
    ->  assertz(test_passed(Path)),
        report_generator:generate_llm_feedback(ID)
    ;   assertz(test_failed(Path, audit_failed)),
        report_generator:generate_llm_feedback(ID)
    ),
    !. 

count_and_report :-
    findall(P, test_passed(P), Ps), length(Ps, PC), findall(F, test_failed(F,_), Fs), length(Fs, FC),
    format('~nDONE: ~w Passed, ~w Failed~n', [PC, FC]).
