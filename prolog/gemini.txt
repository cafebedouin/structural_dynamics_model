:- module(constraint_bridge, [
    dr_diagnostic_report/1,
    constraint_status/3,
    recommendation_feasibility/3
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_coercion_projection).

/* ================================================================
   1. CONTEXTUAL CONSTRAINT FILTERING
   ================================================================ */

%% constraint_status(+ConstraintName, -State, -Intensity)
%  Maps CE v2.0 types to diagnostic intensities.
constraint_status(Name, binding_limit, I) :-
    narrative_ontology:constraint_claim(Name, mountain),
    narrative_ontology:constraint_metric(Name, inevitability, I), !.

constraint_status(Name, extractive_noose, I) :-
    narrative_ontology:constraint_claim(Name, snare),
    narrative_ontology:constraint_metric(Name, extractiveness, I), !.

constraint_status(Name, coordination_rope, I) :-
    narrative_ontology:constraint_claim(Name, rope),
    (narrative_ontology:constraint_metric(Name, theater_ratio, T) -> I is 1.0 - T ; I = 1.0), !.

constraint_status(Name, inertial_piton, I) :-
    narrative_ontology:constraint_claim(Name, piton),
    (narrative_ontology:constraint_metric(Name, theater_ratio, I) ; I = 1.0), !.

/* ================================================================
   2. UNIQUE VETO LOGIC & FEASIBILITY
   ================================================================ */

recommendation_feasibility(RecID, Status, UniqueVetoes) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is a recommendation
    % --- 1. THE STRUCTURAL AUDIT (Theorem 3) ---
    % If a recommendation affects a Snare (high extraction), 
    % it is load-bearing. Cutting it without a Scaffold is a systemic risk.
    (   narrative_ontology:affects_constraint(RecID, Target),
        narrative_ontology:constraint_metric(Target, extractiveness, X), 
        X > 0.7, % Load-bearing threshold
        \+ (narrative_ontology:entity(_, scaffold)) % No safety net provided
    ->  Status = blocked_scaffold_vacuum,
        UniqueVetoes = [] % Blocked by physics/logic, not individuals
    ;   
    % --- 2. THE POLITICAL AUDIT (Veto Logic) ---
    % Check for agents whose interests are explicitly threatened.
    (setof(Actor, narrative_ontology:veto_exposed(Actor, RecID), UniqueVetoes) 
     ; UniqueVetoes = []),
    length(UniqueVetoes, Count),
    (   Count == 0 -> Status = viable 
    ;   Count < 2  -> Status = high_veto_risk % Adjusted sensitivity
    ;   Status = blocked_by_veto)
    ).

%% is_safe_to_cut(+ConstraintID)
% Theorem 3: Cutting a load-bearing Snare requires a Scaffold.
is_safe_to_cut(C) :-
    narrative_ontology:constraint_metric(C, extractiveness, X), X > 0.7, % Load-bearing Snare
    narrative_ontology:entity(_, scaffold). % A scaffold MUST exist in the KB

/* ================================================================
   3. SCENARIO-AWARE DIAGNOSTIC REPORTING
   ================================================================ */

%% dr_diagnostic_report(+IntervalID)
%  Enhanced v4.1: Consolidates diagnostic reporting with High-Risk Isomorphism Alerting.
dr_diagnostic_report(IntervalID) :-
    format('~n=== DEFERENTIAL REALISM (DR) DIAGNOSTIC: ~w ===~n', [IntervalID]),
    
    % --- SECTION 1: CONSTRAINT INVENTORY ---
    format('~n[CONSTRAINT INVENTORY]~n'),
    (   setof(line(Name, State, Intensity), 
              (constraint_status(Name, State, Intensity), 
               narrative_ontology:constraint_metric(Name, _, _)), 
              UniqueLines)
    ->  forall(member(line(N, S, I), UniqueLines),
               (   format('  - ~w: ~w (Intensity: ~2f)~n', [N, S, I]),
                   % Trigger Isomorphism Check for High-Risk Types
                   check_for_social_twins(N, S)
               ))
    ;   format('  No active constraints found.~n')
    ),
    
    % --- SECTION 2: FEASIBILITY BRIDGE ---
    format('~n[FEASIBILITY BRIDGE]~n'),
    % Using _ConsName resolves the singleton variable warning
    forall((narrative_ontology:recommendation(RID, Summary),
            narrative_ontology:affects_constraint(RID, _ConsName)),
           (recommendation_feasibility(RID, Stat, Vs),
            format('  - ~w (~w): ~w | Vetoes: ~w~n', [RID, Summary, Stat, Vs]))),
    format('====================================================~n').

%% check_for_social_twins(+Name, +State)
%  Internal helper that alerts the user if a high-risk technical constraint 
%  mirrors a social pathology.
check_for_social_twins(Name, State) :-
    member(State, [snare, tangled_rope, extractive_noose]), % High-risk states [cite: 4, 206, 208]
    isomorphism_engine:find_high_risk_isomorphism(Name, SocialTwin, Score),
    domain_priors:category_of(SocialTwin, Cat),
    member(Cat, [narrative_history, statutory_formal, election_cycle]),
    !,
    format('    ! ALERT: High-Risk Social Twin Detected: ~w (Similarity: ~2f)~n', [SocialTwin, Score]),
    format('    ! Logic: This system functions structurally identically to a ~w scenario.~n', [Cat]).
check_for_social_twins(_, _).
% ============================================================================
% INDEXICAL CONSTRAINT CLASSIFICATION
% ============================================================================
% This module implements context-indexed constraint classification.
% Every Mountain/Rope/Snare judgment is relative to WHO, WHEN, WHERE, HOW.
%
% Integration: Load after domain_priors.pl, before report_generator.pl
% ============================================================================

:- module(constraint_indexing, [
    % Core API
    constraint_classification/3,    % New indexed classification
    constraint_claim_indexed/2,     % Backward compatible wrapper (renamed to avoid collision)
    
    % Context builders
    default_context/1,
    valid_context/1,
    discover_my_context/1,
    
    % Analysis utilities
    multi_index_report/1,
    compare_perspectives/2,
    perspective_gap/2,
    
    % Helper predicates (exposed for testing)
    effective_immutability/3,
    effective_immutability_for_context/2,
    extractiveness_for_agent/3,
    power_modifier/2,
    
    % Index predicates
    agent_power/1,
    time_horizon/1,
    exit_options/1,
    spatial_scope/1
]).

:- multifile constraint_classification/3.
:- dynamic constraint_classification/3.

% Required modules
:- use_module(drl_core, [base_extractiveness/2, suppression_score/2]).

% ============================================================================
% INDEX ONTOLOGY
% ============================================================================

% ----------------------------------------------------------------------------
% Agent Power Levels - WHO is evaluating?
% ----------------------------------------------------------------------------

agent_power(individual_powerless).    % Serf, prisoner, child
agent_power(individual_moderate).     % Middle class, citizen
agent_power(individual_powerful).     % Wealthy, connected
agent_power(collective_organized).    % Union, movement
agent_power(institutional).           % State, corporation, church
agent_power(analytical).              % Historian, philosopher (meta-level)

% ----------------------------------------------------------------------------
% Time Horizons - WHEN/how long?
% ----------------------------------------------------------------------------

time_horizon(immediate).              % 1 year
time_horizon(biographical).           % 20-50 years (lifetime)
time_horizon(generational).          % 50-100 years
time_horizon(historical).            % 100-500 years
time_horizon(civilizational).        % 500+ years

% ----------------------------------------------------------------------------
% Exit Options - WHERE can you go?
% ----------------------------------------------------------------------------

exit_options(trapped).               % No physical/conceptual exit
exit_options(constrained).           % Exit costly but possible
exit_options(mobile).                % Can leave, alternatives visible
exit_options(arbitrage).             % Can play systems against each other
exit_options(analytical).            % Not constrained (observer stance)

% ----------------------------------------------------------------------------
% Spatial Scope - WHERE does it operate?
% ----------------------------------------------------------------------------

spatial_scope(local).                % Village, neighborhood
spatial_scope(regional).             % Province, state
spatial_scope(national).             % Country
spatial_scope(continental).          % Europe, Asia, etc
spatial_scope(global).               % Worldwide

% ============================================================================
% CONTEXT STRUCTURE
% ============================================================================

% ----------------------------------------------------------------------------
% Context Validation
% ----------------------------------------------------------------------------

% context(+AgentPower, +TimeHorizon, +ExitOptions, +SpatialScope)
% Represents the indexical parameters for classification

valid_context(context(
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S)
)) :-
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S).

% ----------------------------------------------------------------------------
% Default Context - Analytical "God's Eye View"
% ----------------------------------------------------------------------------

default_context(context(
    agent_power(analytical),
    time_horizon(civilizational),
    exit_options(analytical),
    spatial_scope(global)
)).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% Indexed API wrapper - defaults to analytical perspective
% Renamed to avoid collision with narrative_ontology:constraint_claim/2
constraint_claim_indexed(Constraint, Type) :-
    default_context(Ctx),
    constraint_classification(Constraint, Type, Ctx).

% ============================================================================
% HELPER PREDICATES - EFFECTIVE IMMUTABILITY
% ============================================================================

% Can this be changed given time horizon and exit options?
% Returns: mountain (unchangeable) or rope (changeable)

effective_immutability(immediate, trapped, mountain).
effective_immutability(immediate, constrained, mountain).
effective_immutability(immediate, mobile, rope).
effective_immutability(immediate, arbitrage, rope).

effective_immutability(biographical, trapped, mountain).
effective_immutability(biographical, constrained, mountain).
effective_immutability(biographical, mobile, rope).
effective_immutability(biographical, arbitrage, rope).

effective_immutability(generational, trapped, mountain).
effective_immutability(generational, constrained, rope).
effective_immutability(generational, mobile, rope).
effective_immutability(generational, arbitrage, rope).

effective_immutability(historical, _, rope).
effective_immutability(civilizational, _, rope).

% Wrapper that takes full context
effective_immutability_for_context(
    context(_, time_horizon(T), exit_options(E), _),
    Perception
) :-
    effective_immutability(T, E, Perception).

% ============================================================================
% HELPER PREDICATES - AGENT-RELATIVE EXTRACTIVENESS
% ============================================================================

% ----------------------------------------------------------------------------
% Power Modifiers
% ----------------------------------------------------------------------------
% More powerful agents experience less extraction from same constraint
% Negative modifier = net beneficiary

power_modifier(individual_powerless, 1.5).   % Experience MORE extraction
power_modifier(individual_moderate, 1.0).    % Baseline
power_modifier(individual_powerful, 0.5).    % Experience LESS extraction
power_modifier(collective_organized, 0.7).   % Shared burden
power_modifier(institutional, -0.2).         % NET BENEFICIARY
power_modifier(analytical, 1.0).             % Neutral observer

% ----------------------------------------------------------------------------
% Calculate Extractiveness for Specific Agent
% ----------------------------------------------------------------------------

extractiveness_for_agent(Constraint, Context, Score) :-
    Context = context(agent_power(Power), _, _, _),
    base_extractiveness(Constraint, BaseScore),
    power_modifier(Power, Modifier),
    Score is BaseScore * Modifier.

% ============================================================================
% CANONICAL CLASSIFICATION PREDICATE
% ============================================================================

% constraint_classification(+ConstraintID, ?Type, +Context)
% This is the ONLY predicate that does real classification work.
% All other predicates delegate to this.
%
% Specific constraint rules should be added in separate files or
% in domain_priors.pl using this predicate.

% Example template (actual rules in domain_priors.pl or constraint_instances.pl):
% constraint_classification(some_constraint, Type, Context) :-
%     valid_context(Context),
%     ... classification logic using Context parameters ...

% ============================================================================
% QUERY UTILITIES
% ============================================================================

% ----------------------------------------------------------------------------
% Interactive Context Discovery
% ----------------------------------------------------------------------------

discover_my_context(Context) :-
    writeln(''),
    writeln('=== CONTEXT DISCOVERY ==='),
    writeln(''),
    writeln('What is your power level?'),
    writeln('  1. Powerless (prisoner, serf, child)'),
    writeln('  2. Moderate (middle class, citizen)'),
    writeln('  3. Powerful (wealthy, politically connected)'),
    writeln('  4. Collective (union, movement)'),
    writeln('  5. Institutional (state, corporation)'),
    writeln('  6. Analytical (observer, researcher)'),
    read(PowerChoice),
    map_power(PowerChoice, Power),
    
    writeln(''),
    writeln('What time horizon are you considering?'),
    writeln('  1. Immediate (1 year)'),
    writeln('  2. Biographical (my lifetime)'),
    writeln('  3. Generational (my children)'),
    writeln('  4. Historical (centuries)'),
    writeln('  5. Civilizational (millennia)'),
    read(TimeChoice),
    map_time(TimeChoice, Time),
    
    writeln(''),
    writeln('What exit options do you have?'),
    writeln('  1. Trapped (no exit visible)'),
    writeln('  2. Constrained (exit costly)'),
    writeln('  3. Mobile (can leave)'),
    writeln('  4. Arbitrage (can play systems)'),
    writeln('  5. Analytical (observer)'),
    read(ExitChoice),
    map_exit(ExitChoice, Exit),
    
    writeln(''),
    writeln('What spatial scope?'),
    writeln('  1. Local (village/neighborhood)'),
    writeln('  2. Regional (state/province)'),
    writeln('  3. National (country)'),
    writeln('  4. Continental (Europe, Asia, etc)'),
    writeln('  5. Global (worldwide)'),
    read(ScopeChoice),
    map_scope(ScopeChoice, Scope),
    
    Context = context(
        agent_power(Power),
        time_horizon(Time),
        exit_options(Exit),
        spatial_scope(Scope)
    ),
    writeln(''),
    format('Your context: ~w~n', [Context]).

% Mapping predicates for user input
map_power(1, individual_powerless).
map_power(2, individual_moderate).
map_power(3, individual_powerful).
map_power(4, collective_organized).
map_power(5, institutional).
map_power(6, analytical).

map_time(1, immediate).
map_time(2, biographical).
map_time(3, generational).
map_time(4, historical).
map_time(5, civilizational).

map_exit(1, trapped).
map_exit(2, constrained).
map_exit(3, mobile).
map_exit(4, arbitrage).
map_exit(5, analytical).

map_scope(1, local).
map_scope(2, regional).
map_scope(3, national).
map_scope(4, continental).
map_scope(5, global).

% ----------------------------------------------------------------------------
% Multi-Index Analysis
% ----------------------------------------------------------------------------

% Show how constraint classifies from different perspectives
multi_index_report(Constraint) :-
    writeln(''),
    writeln('=== MULTI-INDEX ANALYSIS ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    findall(
        result(Type, Power, Time, Exit, Scope),
        constraint_classification(Constraint, Type, 
            context(agent_power(Power), time_horizon(Time),
                   exit_options(Exit), spatial_scope(Scope))),
        Results
    ),
    
    (Results = [] ->
        writeln('No classifications found.')
    ;
        format_multi_index_results(Results)
    ).

format_multi_index_results([]).
format_multi_index_results([result(Type, Power, Time, Exit, Scope)|Rest]) :-
    format('~w: power=~w, time=~w, exit=~w, scope=~w~n',
           [Type, Power, Time, Exit, Scope]),
    format_multi_index_results(Rest).

% ----------------------------------------------------------------------------
% Perspective Comparison
% ----------------------------------------------------------------------------

% Compare YOUR view vs ANALYTICAL view
compare_perspectives(Constraint, MyContext) :-
    writeln(''),
    writeln('=== PERSPECTIVE COMPARISON ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    default_context(AnalyticalContext),
    
    (constraint_classification(Constraint, MyType, MyContext) ->
        format('From YOUR perspective (~w): ~w~n', [MyContext, MyType])
    ;
        writeln('No classification from your perspective')
    ),
    
    writeln(''),
    
    (constraint_classification(Constraint, AnalyticalType, AnalyticalContext) ->
        format('From ANALYTICAL perspective: ~w~n', [AnalyticalType])
    ;
        writeln('No analytical classification')
    ),
    
    writeln(''),
    
    (var(MyType) ; var(AnalyticalType) ->
        true
    ; MyType = AnalyticalType ->
        writeln('→ Perspectives AGREE')
    ;
        writeln('→ Perspectives DISAGREE - this is a site of political conflict')
    ).

% ----------------------------------------------------------------------------
% Perspective Gap Detection
% ----------------------------------------------------------------------------

% Find political flashpoints - where different perspectives classify differently
perspective_gap(Constraint, Gap) :-
    constraint_classification(Constraint, Type1, Context1),
    constraint_classification(Constraint, Type2, Context2),
    Type1 \= Type2,
    Context1 \= Context2,
    Gap = gap(Type1-Context1, Type2-Context2).

% ============================================================================
% INTEGRATION NOTES
% ============================================================================

% To integrate this module:
%
% 1. In drl_core.pl, add after domain_priors:
%    :- use_module(constraint_indexing).
%
% 2. In domain_priors.pl, add base_extractiveness/2 facts:
%    base_extractiveness(constraint_id, score).
%    % Score range: 0.0 (no extraction) to 1.0 (full extraction)
%
% 3. Add specific constraint rules using constraint_classification/3
%    See constraint_instances.pl for examples
%
% 4. Update report_generator.pl to optionally use indexed classification:
%    - Default: Use constraint_claim/2 (analytical view)
%    - Advanced: Accept context parameter from user
%
% 5. Test backward compatibility:
%    - Old code using constraint_claim/2 should work unchanged
%    - New code can use constraint_classification/3 explicitly
:- module(constraint_instances, [
    % This module adds constraint_classification/3 rules
    % No exports needed - rules are added to constraint_indexing namespace
]).

:- use_module(constraint_indexing).
:- use_module(domain_priors).

% ============================================================================
% CONSTRAINT-SPECIFIC INDEXED CLASSIFICATIONS
% ============================================================================

% These rules extend constraint_indexing:constraint_classification/3
% See test_generation_prompt.md for examples

% ============================================================================
% HISTORICAL CONSTRAINT INSTANCES
% ============================================================================

% ----------------------------------------------------------------------------
% CATHOLIC CHURCH 1200 CE
% ----------------------------------------------------------------------------

% Serf perspective - MOUNTAIN
constraint_indexing:constraint_classification(
    catholic_church_1200,
    mountain,
    context(
        agent_power(individual_powerless),
        time_horizon(biographical),
        exit_options(trapped),
        spatial_scope(local)
    )
) :-
    constraint_indexing:effective_immutability_for_context(
        context(agent_power(individual_powerless), 
                time_horizon(biographical), 
                exit_options(trapped), 
                spatial_scope(local)),
        mountain
    ).

% Historian perspective - NOOSE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    snare,
    context(
        agent_power(analytical),
        time_horizon(Horizon),
        exit_options(analytical),
        spatial_scope(continental)  % FIXED: Was unbound
    )
) :-
    member(Horizon, [historical, civilizational]),
    domain_priors:base_extractiveness(catholic_church_1200, E),
    E > 0.6,
    domain_priors:requires_active_enforcement(catholic_church_1200),
    !.  % ADDED: Cut to prevent duplicates

% Pope perspective - ROPE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    rope,
    context(
        agent_power(institutional),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(continental)
    )
) :-
    constraint_indexing:extractiveness_for_agent(catholic_church_1200, 
        context(agent_power(institutional), 
                time_horizon(generational), 
                exit_options(arbitrage), 
                spatial_scope(continental)), 
        E),
    E < 0.4,  % Low for beneficiary
    !.  % ADDED: Cut to prevent duplicates

% ----------------------------------------------------------------------------
% PROPERTY RIGHTS 2025
% ----------------------------------------------------------------------------

% Homeless person - NOOSE
constraint_indexing:constraint_classification(
    property_rights_2025,
    snare,
    context(
        agent_power(individual_powerless),
        time_horizon(biographical),
        exit_options(Exit),
        spatial_scope(national)
    )
) :-
    member(Exit, [trapped, constrained]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, 
        context(agent_power(individual_powerless),
                time_horizon(biographical),
                exit_options(Exit),
                spatial_scope(national)),
        E),
    E > 0.7,
    !.  % ADDED: Cut to prevent duplicates

% Middle class - ROPE
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(individual_moderate),
        time_horizon(biographical),
        exit_options(mobile),
        spatial_scope(national)
    )
) :-
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(individual_moderate),
                time_horizon(biographical),
                exit_options(mobile),
                spatial_scope(national)),
        E),
    E < 0.6,
    !.  % ADDED: Cut to prevent duplicates

% Billionaire - ROPE (with benefits)
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(Power),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(global)
    )
) :-
    member(Power, [individual_powerful, institutional]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(Power),
                time_horizon(generational),
                exit_options(arbitrage),
                spatial_scope(global)),
        E),
    E < 0,  % Negative = net beneficiary
    !.  % ADDED: Cut to prevent duplicates
:- module(data_validation, [
    validate_all/0,
    validate_constraint_completeness/0,
    validate_metric_ranges/0,
    validate_classification_consistency/0,
    validate_edge_cases/0,
    validate_domain_coverage/0,
    validation_summary/0
]).

:- use_module(narrative_ontology).
:- use_module(constraint_indexing).
:- use_module(domain_priors).
:- use_module(drl_core).
:- use_module(v3_1_config).
:- use_module(utils).  % For safe metric retrieval

/* ============================================================================
   DATA VALIDATION SUITE
   ============================================================================

   This module provides comprehensive validation of constraint data quality,
   completeness, and consistency. Unlike validation_suite.pl (which runs
   scenarios), this validates the data itself.

   ============================================================================ */

:- dynamic validation_error/3.    % validation_error(Type, Constraint, Details)
:- dynamic validation_warning/3.   % validation_warning(Type, Constraint, Details)
:- dynamic validation_info/2.      % validation_info(Type, Message)

/* ============================================================================
   1. MAIN VALIDATION ENTRY POINT
   ============================================================================ */

%% validate_all/0
%  Runs all validation checks and reports results.
validate_all :-
    retractall(validation_error(_, _, _)),
    retractall(validation_warning(_, _, _)),
    retractall(validation_info(_, _)),

    format('~n====================================================~n'),
    format('   DATA VALIDATION SUITE                           ~n'),
    format('====================================================~n~n'),

    write('Running validation checks...'), nl, nl,

    % Run all validation checks
    validate_constraint_completeness,
    validate_metric_ranges,
    validate_classification_consistency,
    validate_edge_cases,
    validate_domain_coverage,

    % Report results
    validation_summary.

/* ============================================================================
   2. CONSTRAINT COMPLETENESS VALIDATION
   ============================================================================ */

%% validate_constraint_completeness/0
%  Checks that all constraints have required data.
validate_constraint_completeness :-
    format('[CHECK 1: Constraint Completeness]~n'),
    findall(C, narrative_ontology:constraint_claim(C, _), Constraints),
    length(Constraints, Total),
    format('  Checking ~w constraints...~n', [Total]),

    findall(C, (member(C, Constraints), is_complete_constraint(C)), Complete),
    length(Complete, CompleteCount),
    Incomplete is Total - CompleteCount,

    (Incomplete > 0
    -> (format('  ✗ ~w incomplete constraint(s) found~n~n', [Incomplete]),
        forall((member(C, Constraints), \+ is_complete_constraint(C)),
               report_incomplete_constraint(C)))
    ;  format('  ✓ All constraints complete~n~n', [])).

%% is_complete_constraint(+Constraint)
%  True if constraint has all required data.
is_complete_constraint(C) :-
    % Must have extractiveness metric
    (narrative_ontology:constraint_metric(C, extractiveness, E)
    -> (E >= 0.0, E =< 1.0)
    ;  (assertz(validation_error(missing_metric, C, extractiveness)), fail)),

    % Must have suppression_requirement metric
    (narrative_ontology:constraint_metric(C, suppression_requirement, S)
    -> (S >= 0.0, S =< 1.0)
    ;  (assertz(validation_error(missing_metric, C, suppression_requirement)), fail)),

    % Must have domain category
    (domain_priors:category_of(C, Cat)
    -> (Cat \= unknown, Cat \= unknown_novel)
    ;  (assertz(validation_warning(missing_category, C, 'No domain category assigned')), fail)),

    % Should have at least one indexical classification
    (constraint_indexing:constraint_classification(C, _, _)
    -> true
    ;  (assertz(validation_warning(missing_classification, C, 'No indexical classification')), fail)).

%% report_incomplete_constraint(+Constraint)
%  Reports what data is missing for a constraint.
report_incomplete_constraint(C) :-
    format('  Constraint: ~w~n', [C]),

    % Check extractiveness
    (\+ narrative_ontology:constraint_metric(C, extractiveness, _)
    -> format('    ✗ Missing: extractiveness metric~n')
    ;  true),

    % Check suppression
    (\+ narrative_ontology:constraint_metric(C, suppression_requirement, _)
    -> format('    ✗ Missing: suppression_requirement metric~n')
    ;  true),

    % Check category
    (\+ domain_priors:category_of(C, _)
    -> format('    ✗ Missing: domain category~n')
    ; domain_priors:category_of(C, Cat),
      (Cat = unknown ; Cat = unknown_novel)
    -> format('    ⚠ Category is ~w (should be specific)~n', [Cat])
    ;  true),

    % Check classification
    (\+ constraint_indexing:constraint_classification(C, _, _)
    -> format('    ⚠ Missing: indexical classification~n')
    ;  true),

    nl.

/* ============================================================================
   3. METRIC RANGE VALIDATION
   ============================================================================ */

%% validate_metric_ranges/0
%  Checks that all metrics are within valid ranges.
validate_metric_ranges :-
    format('[CHECK 2: Metric Range Validation]~n'),

    % Check all constraint metrics
    findall(C-M-V, narrative_ontology:constraint_metric(C, M, V), Metrics),
    length(Metrics, TotalMetrics),
    format('  Checking ~w metrics...~n', [TotalMetrics]),

    findall(C-M-V,
            (narrative_ontology:constraint_metric(C, M, V),
             \+ valid_metric_range(M, V)),
            InvalidMetrics),

    length(InvalidMetrics, InvalidCount),
    (InvalidCount > 0
    -> (format('  ✗ ~w invalid metric(s) found~n~n', [InvalidCount]),
        forall(member(C-M-V, InvalidMetrics),
               (format('    ✗ ~w.~w = ~w (out of range)~n', [C, M, V]),
                assertz(validation_error(invalid_metric_range, C, M-V)))))
    ;  format('  ✓ All metrics in valid range~n', [])),
    nl.

%% valid_metric_range(+Metric, +Value)
%  Checks if a metric value is in valid range.
valid_metric_range(_, V) :-
    number(V),
    V >= 0.0,
    V =< 1.0.

/* ============================================================================
   4. CLASSIFICATION CONSISTENCY VALIDATION
   ============================================================================ */

%% validate_classification_consistency/0
%  Checks that claimed types match calculated types.
validate_classification_consistency :-
    format('[CHECK 3: Classification Consistency]~n'),
    findall(C, narrative_ontology:constraint_claim(C, _), Constraints),
    length(Constraints, Total),
    format('  Checking ~w constraints for consistency...~n', [Total]),

    findall(C-Claimed-Expected,
            (narrative_ontology:constraint_claim(C, Claimed),
             infer_expected_type(C, Expected),
             Claimed \= Expected),
            Inconsistencies),

    length(Inconsistencies, IncCount),
    (IncCount > 0
    -> (format('  ⚠ ~w potential inconsistenc(ies) found~n~n', [IncCount]),
        forall(member(C-Claimed-Expected, Inconsistencies),
               report_classification_inconsistency(C, Claimed, Expected)))
    ;  format('  ✓ All classifications consistent with metrics~n', [])),
    nl.

%% infer_expected_type(+Constraint, -Type)
%  Infers what type a constraint should be based on metrics.
infer_expected_type(C, Type) :-
    (narrative_ontology:constraint_metric(C, suppression_requirement, Supp),
     domain_priors:base_extractiveness(C, Extr),
     v3_1_config:param(mountain_suppression_ceiling, Ceil)
    -> classify_by_metrics(Supp, Extr, Ceil, Type)
    ;  Type = unknown).

%% classify_by_metrics(+Supp, +Extr, +Ceil, -Type)
%  Classification logic based on metrics.
classify_by_metrics(Supp, Extr, Ceil, mountain) :-
    Supp =< Ceil, Extr =< 0.35, !.

classify_by_metrics(Supp, Extr, Ceil, snare) :-
    Supp > Ceil, Extr > 0.66, !.

classify_by_metrics(Supp, Extr, Ceil, tangled_rope) :-
    Supp > Ceil, Extr > 0.35, !.

classify_by_metrics(Supp, _Extr, Ceil, rope) :-
    Supp > Ceil, !.

classify_by_metrics(_Supp, Extr, _Ceil, snare) :-
    Extr > 0.66, !.

classify_by_metrics(_, _, _, ambiguous).

%% report_classification_inconsistency(+C, +Claimed, +Expected)
report_classification_inconsistency(C, Claimed, Expected) :-
    narrative_ontology:constraint_metric(C, suppression_requirement, Supp),
    domain_priors:base_extractiveness(C, Extr),
    v3_1_config:param(mountain_suppression_ceiling, Ceil),

    format('  Constraint: ~w~n', [C]),
    format('    Claimed: ~w~n', [Claimed]),
    format('    Expected (from metrics): ~w~n', [Expected]),
    format('    Metrics: suppression=~2f, extractiveness=~2f, ceiling=~2f~n', [Supp, Extr, Ceil]),

    (Expected = snare, Claimed = mountain
    -> (format('    ⚠ CRITICAL: False Mountain (extractive but claimed unchangeable)~n'),
        assertz(validation_error(false_mountain, C, Claimed-Expected)))
    ; Expected = mountain, Claimed = snare
    -> (format('    ⚠ False Snare (fair but claimed extractive)~n'),
        assertz(validation_warning(false_noose, C, Claimed-Expected)))
    ;  assertz(validation_warning(classification_mismatch, C, Claimed-Expected))
    ),
    nl.

/* ============================================================================
   5. EDGE CASE DETECTION
   ============================================================================ */

%% validate_edge_cases/0
%  Detects unusual patterns and edge cases.
validate_edge_cases :-
    format('[CHECK 4: Edge Case Detection]~n'),

    % Check for mandatrophies (unchangeable + extractive)
    findall(C,
            (narrative_ontology:constraint_claim(C, mountain),
             domain_priors:base_extractiveness(C, E),
             E > 0.7),
            Mandatrophies),

    length(Mandatrophies, MandCount),
    (MandCount > 0
    -> (format('  ⚠ ~w potential mandatroph(ies) detected~n', [MandCount]),
        forall(member(C, Mandatrophies),
               (domain_priors:base_extractiveness(C, E),
                format('    - ~w (mountain with E=~2f > 0.7)~n', [C, E]),
                assertz(validation_warning(mandatrophy, C, E)))))
    ;  format('  ✓ No mandatrophies detected~n', [])),

    % Check for pitons (no resistance despite enforcement)
    findall(C,
            (narrative_ontology:constraint_metric(C, suppression_requirement, S),
             narrative_ontology:constraint_metric(C, resistance_to_change, R),
             S > 0.3, R < 0.1),
            Zombies),

    length(Zombies, ZombieCount),
    (ZombieCount > 0
    -> (format('  ⚠ ~w potential piton(s) detected~n', [ZombieCount]),
        forall(member(C, Zombies),
               (narrative_ontology:constraint_metric(C, suppression_requirement, S),
                narrative_ontology:constraint_metric(C, resistance_to_change, R),
                format('    - ~w (S=~2f but R=~2f < 0.1)~n', [C, S, R]),
                assertz(validation_warning(piton, C, S-R)))))
    ;  format('  ✓ No pitons detected~n', [])),

    % Check for extreme values
    findall(C-M-V,
            (narrative_ontology:constraint_metric(C, M, V),
             (V > 0.95 ; V < 0.05),
             member(M, [extractiveness, suppression_requirement, resistance_to_change])),
            ExtremeValues),

    length(ExtremeValues, ExtCount),
    (ExtCount > 0
    -> (format('  ⚠ ~w extreme value(s) detected (>0.95 or <0.05)~n', [ExtCount]),
        forall(member(C-M-V, ExtremeValues),
               (format('    - ~w.~w = ~2f~n', [C, M, V]),
                assertz(validation_info(extreme_value, C-M-V)))))
    ;  format('  ✓ No extreme values~n', [])),

    nl.

/* ============================================================================
   6. DOMAIN COVERAGE VALIDATION
   ============================================================================ */

%% validate_domain_coverage/0
%  Checks distribution across domain categories.
validate_domain_coverage :-
    format('[CHECK 5: Domain Coverage]~n'),

    findall(Cat, domain_priors:category_of(_, Cat), AllCats),
    sort(AllCats, UniqueCats),
    length(UniqueCats, NumCats),

    format('  Found ~w domain categories~n', [NumCats]),

    forall(member(Cat, UniqueCats),
           (findall(C, domain_priors:category_of(C, Cat), Cs),
            length(Cs, Count),
            format('    - ~w: ~w constraint(s)~n', [Cat, Count]))),

    % Check for underrepresented categories
    findall(Cat,
            (member(Cat, UniqueCats),
             findall(C, domain_priors:category_of(C, Cat), Cs),
             length(Cs, Count),
             Count < 3),
            UnderRep),

    (UnderRep \= []
    -> (nl, format('  ⚠ Underrepresented categories (<3 constraints):~n'),
        forall(member(Cat, UnderRep),
               (format('    - ~w~n', [Cat]),
                assertz(validation_info(underrepresented_category, Cat)))))
    ;  true),

    nl.

/* ============================================================================
   7. VALIDATION SUMMARY
   ============================================================================ */

%% validation_summary/0
%  Displays summary of validation results.
validation_summary :-
    format('====================================================~n'),
    format('   VALIDATION SUMMARY                              ~n'),
    format('====================================================~n~n'),

    % Count errors
    findall(E, validation_error(_, _, E), Errors),
    length(Errors, ErrorCount),

    % Count warnings
    findall(W, validation_warning(_, _, W), Warnings),
    length(Warnings, WarningCount),

    % Count info
    findall(I, validation_info(_, I), Infos),
    length(Infos, InfoCount),

    format('Results:~n'),
    format('  Errors:   ~w~n', [ErrorCount]),
    format('  Warnings: ~w~n', [WarningCount]),
    format('  Info:     ~w~n~n', [InfoCount]),

    % Show errors
    (ErrorCount > 0
    -> (format('ERRORS:~n'),
        forall(validation_error(Type, C, Details),
               format('  [ERROR] ~w: ~w - ~w~n', [Type, C, Details])),
        nl)
    ;  true),

    % Show critical warnings
    (WarningCount > 0
    -> (format('WARNINGS:~n'),
        forall(validation_warning(Type, C, Details),
               format('  [WARN] ~w: ~w - ~w~n', [Type, C, Details])),
        nl)
    ;  true),

    % Overall assessment
    (ErrorCount = 0, WarningCount = 0
    -> format('✓ DATA QUALITY: EXCELLENT - No issues detected~n')
    ; ErrorCount = 0, WarningCount < 10
    -> format('✓ DATA QUALITY: GOOD - Minor warnings only~n')
    ; ErrorCount > 0, ErrorCount < 5
    -> format('⚠ DATA QUALITY: FAIR - Some errors need attention~n')
    ;  format('✗ DATA QUALITY: POOR - Multiple errors require fixes~n')
    ),

    format('~n====================================================~n').
:- module(data_verification, [
    verify_all/0,
    verify_interval_completeness/1,
    check_paired_measurements/0,
    diagnose_unknown/1
]).

:- use_module(library(lists)).        % Required for subtract/3
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

/* ============================================================
   1. ENTRY POINTS
   ============================================================ */

%% verify_all
%  Performs a full sweep of the loaded data against the v3.1 schema.
verify_all :-
    format('~n--- [START] Data Verification ---~n'),
    (validate_ontology -> format('[OK] Ontology Schema matches.~n') ; format('[FAIL] Schema mismatch.~n')),
    verify_structure,
    verify_measurements,
    check_paired_measurements,  % NEW: Check for paired temporal measurements
    verify_intent_logic,
    format('--- [END] Data Verification Complete ---~n').

/* ============================================================
   2. STRUCTURAL & VECTOR COMPLETENESS
   ============================================================ */

%% verify_structure
%  Ensures every interval has the required 32-point coercion vector.
verify_structure :-
    forall(interval(ID, T0, Tn),
           ( format('Checking Interval: ~w (~w-~w)~n', [ID, T0, Tn]),
             verify_interval_completeness(ID)
           )).

%% verify_interval_completeness(+IntervalID)
%  Checks for the presence of all 4 components across all 4 levels at T0 and Tn.
verify_interval_completeness(ID) :-
    interval(ID, T0, Tn),
    forall(level(L),
           ( verify_vector_at(L, T0, ID),
             verify_vector_at(L, Tn, ID)
           )).

verify_vector_at(Level, Time, ID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components),
           ( measurement(_, _, Metric, Time, _)
           -> true
           ;  format('  [MISSING] ~w for Level: ~w at T: ~w in ~w~n', [Metric, Level, Time, ID]),
              fail
           )).

/* ============================================================
   3. VALUE RANGE VALIDATION
   ============================================================ */

verify_measurements :-
    forall(measurement(ID, _, _, _, Val),
           ( number(Val), Val >= 0.0, Val =< 1.0
           -> true
           ;  format('  [VALUE ERROR] Measurement ~w is outside [0,1] range.~n', [ID]),
              fail
           )).

/* ============================================================
   4. INTENT LOGIC CONSISTENCY
   ============================================================ */

verify_intent_logic :-
    % Ensure every rejected alternative was first defined as viable (by anyone)
    % FIXED: Different entities can propose vs. reject - that's the whole point!
    % RELAXED: Allow rejecting implicit alternatives that weren't explicitly listed as viable
    forall(intent_alternative_rejected(I, _Rejecter, A),
           ( intent_viable_alternative(I, _Proposer, A)
           -> true
           ;  format('  [INFO] Alternative ~w rejected in ~w without explicit viable listing (may be implicit status quo).~n', [A, I])
           % REMOVED fail - this is informational, not an error
           )),
    % Ensure main beneficiary has a power change fact
    forall(intent_beneficiary_class(I, C),
           ( intent_power_change(I, C, _)
           -> true
           ;  format('  [MISSING DATA] Beneficiary ~w has no power_change delta in ~w.~n', [C, I]),
              fail
           )).

/* ============================================================
   5. PAIRED MEASUREMENT VALIDATION (MODAL LOGIC REQUIREMENT)
   ============================================================ */

%% check_paired_measurements
% Verifies that extractiveness and suppression_requirement measurements
% are paired at each time point for each constraint.
% CRITICAL: Modal logic requires BOTH metrics to classify constraints.
check_paired_measurements :-
    % Get all constraints that have any temporal measurements
    % CRITICAL FIX: Exclude intervals to avoid treating them as constraints
    setof(C, T^M^V^(measurement(M, C, _, T, V), entity(C, _)), Constraints),
    !,
    forall(member(C, Constraints),
           check_constraint_pairing(C)).

check_paired_measurements :- 
    % No temporal measurements found - skip check
    true.

%% check_constraint_pairing(+Constraint)
% Checks if a specific constraint has paired measurements
check_constraint_pairing(C) :-
    % Get all time points for extractiveness
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    % Get all time points for suppression_requirement
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    % Sort and compare
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  true  % Perfect pairing
    ;   XSorted = [], ESorted = []
    ->  true  % No temporal data (uses constraint_metric only)
    ;   % Unpaired measurements detected
        format('  [WARNING] Unpaired temporal measurements for ~w~n', [C]),
        (   XSorted \= []
        ->  format('    Extractiveness measured at: ~w~n', [XSorted])
        ;   format('    Extractiveness: No temporal measurements~n')
        ),
        (   ESorted \= []
        ->  format('    Suppression measured at: ~w~n', [ESorted])
        ;   format('    Suppression: No temporal measurements~n')
        ),
        format('    Impact: May cause "unknown" classification or use default values~n')
    ).

/* ============================================================
   6. DIAGNOSTIC TOOLS
   ============================================================ */

%% diagnose_unknown(+Constraint)
% Diagnostic tool for investigating "unknown" classifications
% Call this when dr_type(C, unknown) occurs
diagnose_unknown(C) :-
    format('~n=== DIAGNOSING UNKNOWN CLASSIFICATION: ~w ===~n', [C]),
    
    % Check if constraint exists
    (   constraint_claim(C, Claimed)
    ->  format('Claimed type: ~w~n', [Claimed])
    ;   format('WARNING: No constraint_claim for ~w~n', [C])
    ),
    
    % Check current metrics
    format('~nCurrent metrics (T_end):~n'),
    (   constraint_metric(C, extractiveness, X)
    ->  format('  Extractiveness: ~w~n', [X])
    ;   format('  Extractiveness: MISSING~n')
    ),
    (   constraint_metric(C, suppression_requirement, E)
    ->  format('  Suppression: ~w~n', [E])
    ;   format('  Suppression: MISSING~n')
    ),
    
    % Check temporal measurements
    format('~nTemporal measurements:~n'),
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    (   XTimes \= []
    ->  format('  Extractiveness at times: ~w~n', [XTimes])
    ;   format('  Extractiveness: No temporal data~n')
    ),
    (   ETimes \= []
    ->  format('  Suppression at times: ~w~n', [ETimes])
    ;   format('  Suppression: No temporal data~n')
    ),
    
    % Check pairing
    format('~nPairing analysis:~n'),
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  format('  ✓ Measurements are paired~n')
    ;   format('  ✗ UNPAIRED MEASUREMENTS DETECTED~n'),
        format('    This is likely causing the "unknown" classification~n')
    ),
    
    % Provide fix suggestion
    format('~nRecommended fix:~n'),
    (   XSorted \= [], ESorted = []
    ->  format('  Add suppression_requirement measurements at: ~w~n', [XSorted])
    ;   ESorted \= [], XSorted = []
    ->  format('  Add extractiveness measurements at: ~w~n', [ESorted])
    ;   XSorted \= [], ESorted \= []
    ->  subtract(XSorted, ESorted, MissingE),
        subtract(ESorted, XSorted, MissingX),
        (   MissingE \= []
        ->  format('  Add suppression_requirement at: ~w~n', [MissingE])
        ;   true
        ),
        (   MissingX \= []
        ->  format('  Add extractiveness at: ~w~n', [MissingX])
        ;   true
        )
    ;   format('  Add temporal measurements with both metrics~n')
    ),
    format('~n===========================================~n~n').
:- module(domain_priors, [
    get_prior/3,
    is_known_domain/1,
    flag_novelty/1,
    expected_signature/2,
    should_be_natural_law/1,
    validate_signature/2,
    category_of/2
]).

:- use_module(domain_registry).
:- use_module(drl_core).

% 1. Suppress discontiguous warnings by declaring them at the top
:- discontiguous expected_signature/2.
:- discontiguous validate_signature/2.
:- discontiguous infer_category_from_priors/2.
:- discontiguous is_known_domain/1.
:- discontiguous flag_novelty/1.
:- discontiguous get_prior/3.

:- multifile
    drl_core:base_extractiveness/2,
    drl_core:suppression_score/2,
    drl_core:requires_active_enforcement/1,
    drl_core:emerges_naturally/1.

drl_core:base_extractiveness(_, _) :- fail.
drl_core:suppression_score(_, _) :- fail.
drl_core:requires_active_enforcement(_) :- fail.
drl_core:emerges_naturally(_) :- fail.

/**
 * DOMAIN PRIORS MODULE - v3.2.4 Hardened
 * Resolves redefinition warnings and restores missing API procedures.
 */

%% ============================================================================
%% 1. CATEGORY PROFILES
%% ============================================================================
category_profile(physical_natural,    [1.00, 1.00, 0.00, 0.00]).  % Mountain
category_profile(formal_logic,        [0.90, 0.20, 0.10, 0.10]).  % Mountain
category_profile(statutory_formal,    [0.80, 0.50, 0.70, 0.40]).  % Rope
category_profile(election_cycle,       [0.80, 0.80, 0.30, 0.50]). % Periodic Rope
category_profile(extractive_market, [0.40, 0.80, 0.68, 0.60]).    % Calibrated Snare
category_profile(narrative_history,  [0.6, 0.7, 0.41, 0.6]).      % Calibrated Rope
category_profile(unknown_novel,      [0.55, 0.73, 0.52, 0.6]).    % Fleet Baseline
category_profile(mandatrophy_collapse, [0.20, 0.95, 0.90, 0.30]). % Terminal State

%% ============================================================================
%% 2. API DEFINITIONS
%% ============================================================================

is_known_domain(ID) :- domain_category(ID, _), !.
is_known_domain(ID) :- base_extractiveness(ID, _), !.
is_known_domain(ID) :- suppression_score(ID, _), !.
is_known_domain(ID) :- narrative_ontology:constraint_claim(ID, _), !.

% Flag Novelty (Clears v3_1_data_repair warnings)
flag_novelty(ID) :-
    \+ is_known_domain(ID),
    format('! NOTICE: Novel Domain "~w" detected. Using neutral (0.5) priors.~n', [ID]).
flag_novelty(_).

get_prior(ID, Metric, Value) :-
    map_metric_to_hook(Metric, Hook),
    call(domain_priors:Hook, ID, Value), !.

get_prior(ID, Metric, Value) :-
    category_of(ID, Cat),
    category_profile(Cat, Vector),
    map_metric_to_vector_pos(Metric, Vector, Value), !.

get_prior(_, _, 0.5).

category_of(ID, Cat) :- domain_registry:domain_category(ID, Cat), !.
category_of(ID, physical_natural) :-
    (narrative_ontology:constraint_claim(ID, natural_law) ;
     narrative_ontology:constraint_claim(ID, physical_law)), !.
category_of(_, unknown_novel).

% Signature Support (Clears exported-procedure errors)
should_be_natural_law(ID) :-
    category_of(ID, Cat),
    expected_signature(Cat, natural_law).

expected_signature(physical_natural, natural_law).
expected_signature(formal_logic,     natural_law).
expected_signature(election_cycle,   constructed_constraint).
expected_signature(statutory_formal, constructed_constraint).
expected_signature(extractive_market, constructed_constraint).
expected_signature(narrative_history, constructed_constraint).
expected_signature(unknown_novel,    ambiguous).

validate_signature(ID, Detected) :-
    category_of(ID, Cat),
    expected_signature(Cat, Expected),
    ( Detected = Expected
    -> format('[VALIDATION] ✓ ~w: ~w matches ~w~n', [ID, Detected, Cat])
    ;  format('[VALIDATION] ✗ ~w: Expected ~w, got ~w~n', [ID, Expected, Detected])).

%% ============================================================================
%% 3. INTERNAL HELPERS
%% ============================================================================

map_metric_to_hook(base_extractiveness(_), base_extractiveness).
map_metric_to_hook(extractiveness,         base_extractiveness).
map_metric_to_hook(suppression(_),          suppression_score).
map_metric_to_hook(suppression_requirement, suppression_score).

map_metric_to_vector_pos(accessibility_collapse(_), [A,_,_,_], A).
map_metric_to_vector_pos(stakes_inflation(_),      [_,S,_,_], S).
map_metric_to_vector_pos(suppression(_),           [_,_,U,_], U).
map_metric_to_vector_pos(resistance(_),            [_,_,_,R], R).

infer_category_from_priors(ID, extractive_market) :-
    base_extractiveness(ID, E), E > 0.6, !.
infer_category_from_priors(ID, statutory_formal) :-
    requires_active_enforcement(ID), !.

%% ============================================================================
%% 4. SIGNATURE
%% ============================================================================
expected_signature(physical_natural, natural_law).
expected_signature(formal_logic,     natural_law).
expected_signature(election_cycle,   constructed_constraint).
expected_signature(statutory_formal, constructed_constraint).
expected_signature(extractive_market, constructed_constraint).
expected_signature(narrative_history, constructed_constraint).
expected_signature(unknown_novel,    ambiguous).

validate_signature(ID, Detected) :-
    category_of(ID, Cat),
    expected_signature(Cat, Expected),
    (   Detected = Expected
    ->  format('[VALIDATION] ✓ ~w: ~w matches ~w~n', [ID, Detected, Cat])
    ;   format('[VALIDATION] ✗ ~w: Expected ~w, got ~w~n', [ID, Expected, Detected])
    ).

%% flag_novelty(+ID)
%  Logs a domain that doesn't match existing priors for later calibration.
flag_novelty(ID) :-
    format('  [ALERT] Novel domain detected: ~w. Queuing for calibration.~n', [ID]),
    assertz(attribute(ID, discovery_status, novel)).

%% get_prior(+ID, +Metric, -Value)
%  Retrieves the baseline value based on the domain's category profile.
get_prior(ID, Metric, Value) :-
    category_of(ID, Category),
    category_profile(Category, Vector),
    map_metric_to_vector_pos(Metric, Vector, Value), !.
get_prior(_, _, 0.5). % Default neutral prior
:- module(domain_priors_expanded, [
    get_corpus_prior/3,
    category_corpus_profile/2,
    type_corpus_profile/2,
    subcategory_profile/2,
    default_extractiveness/2,
    default_suppression/2,
    default_resistance/2,
    infer_category_defaults/4
]).

/**
 * DOMAIN PRIORS EXPANSION - Auto-generated from corpus analysis
 * Generated from 409 constraints
 * Categories analyzed: 3
 *
 * This module provides corpus-derived defaults for domain priors.
 * Use these when a new domain lacks explicit priors.
 */

%% ============================================================================
%% 1. CATEGORY CORPUS PROFILES (From Corpus Averages)
%% ============================================================================
%% Format: category_corpus_profile(Category, [AvgExtract, AvgSuppress, StdExtract, StdSuppress, Count]).

category_corpus_profile(narrative_history, [0.305, 0.442, 0.158, 0.233, 260]).  % dominant: mountain, enforcement_ratio: 0.35
category_corpus_profile(extractive_market, [0.783, 0.685, 0.081, 0.166, 146]).  % dominant: snare, enforcement_ratio: 0.79
category_corpus_profile(unknown_novel, [0.735, 0.825, 0.015, 0.025, 3]).  % dominant: tangled_rope, enforcement_ratio: 1.0

%% ============================================================================
%% 2. CONSTRAINT TYPE PROFILES (Mountain/Rope/Snare/Tangled Rope)
%% ============================================================================
%% Format: type_corpus_profile(Type, [AvgExtract, AvgSuppress, StdExtract, StdSuppress, Count]).

type_corpus_profile(mountain, [0.367, 0.454, 0.236, 0.257, 150]).
type_corpus_profile(snare, [0.661, 0.682, 0.217, 0.164, 92]).
type_corpus_profile(rope, [0.373, 0.462, 0.23, 0.258, 79]).
type_corpus_profile(tangled_rope, [0.529, 0.587, 0.233, 0.187, 47]).

%% ============================================================================
%% 3. SUBCATEGORY PROFILES (Category + Type combinations)
%% ============================================================================
%% Format: subcategory_profile(SubcatName, [Parent, Type, AvgExtract, AvgSuppress, Count]).

subcategory_profile(narrative_history_mountain, ['narrative_history', 'mountain', 0.273, 0.405, 121]).
subcategory_profile(narrative_history_rope, ['narrative_history', 'rope', 0.298, 0.414, 66]).
subcategory_profile(extractive_market_noose, ['extractive_market', 'snare', 0.806, 0.745, 57]).
subcategory_profile(narrative_history_noose, ['narrative_history', 'snare', 0.418, 0.576, 34]).
subcategory_profile(extractive_market_mountain, ['extractive_market', 'mountain', 0.759, 0.662, 29]).
subcategory_profile(narrative_history_tangled_rope, ['narrative_history', 'tangled_rope', 0.325, 0.502, 24]).
subcategory_profile(extractive_market_tangled_rope, ['extractive_market', 'tangled_rope', 0.743, 0.662, 21]).
subcategory_profile(extractive_market_rope, ['extractive_market', 'rope', 0.752, 0.704, 13]).

%% ============================================================================
%% 4. DEFAULT VALUE INFERENCE PREDICATES
%% ============================================================================

%% default_extractiveness(+Category, -Value)
%% Returns corpus-derived default extractiveness for a category.
default_extractiveness(Category, Value) :-
    category_corpus_profile(Category, [Value|_]), !.
default_extractiveness(_, 0.5).  % Neutral fallback

%% default_suppression(+Category, -Value)
%% Returns corpus-derived default suppression for a category.
default_suppression(Category, Value) :-
    category_corpus_profile(Category, [_, Value|_]), !.
default_suppression(_, 0.5).  % Neutral fallback

%% default_resistance(+Category, -Value)
%% Infers resistance from extractiveness (inverse correlation).
default_resistance(Category, Value) :-
    default_extractiveness(Category, Ext),
    Value is max(0.1, min(0.9, 1.0 - Ext * 0.5)), !.
default_resistance(_, 0.5).

%% infer_category_defaults(+Category, -Extractiveness, -Suppression, -Resistance)
%% Unified predicate to get all defaults for a category.
infer_category_defaults(Category, Ext, Sup, Res) :-
    default_extractiveness(Category, Ext),
    default_suppression(Category, Sup),
    default_resistance(Category, Res).

%% get_corpus_prior(+ID, +Metric, -Value)
%% Retrieves corpus-derived prior by constraint type.
get_corpus_prior(ID, extractiveness, Value) :-
    narrative_ontology:constraint_claim(ID, Type),
    type_corpus_profile(Type, [Value|_]), !.
get_corpus_prior(ID, suppression, Value) :-
    narrative_ontology:constraint_claim(ID, Type),
    type_corpus_profile(Type, [_, Value|_]), !.
get_corpus_prior(_, _, 0.5).  % Neutral fallback

%% ============================================================================
%% 5. RECOMMENDED CATEGORY PROFILE VECTORS
%% ============================================================================
%% These are corpus-calibrated replacements for the original category_profile/2.
%% Format: [accessibility_collapse, stakes_inflation, suppression, resistance]

% recommended_profile(narrative_history, [0.82, 0.37, 0.44, 0.82]).  % N=260, dominant=mountain
% recommended_profile(extractive_market, [0.6, 0.94, 0.69, 0.53]).  % N=146, dominant=snare

%% ============================================================================
%% END OF AUTO-GENERATED PRIORS
%% ============================================================================:- module(domain_registry, [domain_category/2]).
% --- AUTOMATICALLY GENERATED DOMAIN REGISTRY ---
% Maps both Constraint IDs and Interval IDs to categories.

domain_category(ac_era, narrative_history).
domain_category(academic_peer_review_gatekeeping, extractive_market).
domain_category(academic_tenure_system, extractive_market).
domain_category(adverse_possession, extractive_market).
domain_category(adverse_possession_interval, extractive_market).
domain_category(advice_as_dangerous_gift, narrative_history).
domain_category(ai_cognitive_diversity_arbitrage, extractive_market).
domain_category(ai_driven_surveillance_sensor_layer, extractive_market).
domain_category(ai_edu_decentralization, narrative_history).
domain_category(ai_evaluators_matching, extractive_market).
domain_category(ai_professional_displacement, extractive_market).
domain_category(ai_task_horizon_reliability, narrative_history).
domain_category(airbnb_ipo_era, narrative_history).
domain_category(airbnb_str_regulation, narrative_history).
domain_category(algorithmic_bias, extractive_market).
domain_category(amish_technological_renunciation, extractive_market).
domain_category(ancient_grudge_verona, extractive_market).
domain_category(antifragility, extractive_market).
domain_category(apartheid_nuclear_program, extractive_market).
domain_category(arctic_geopolitical_flashpoint, extractive_market).
domain_category(arrows_era, narrative_history).
domain_category(arrows_impossibility_theorem, narrative_history).
domain_category(asce_7_22_seismic_design, narrative_history).
domain_category(asce_cycle_22, narrative_history).
domain_category(asshole_filter_2015, extractive_market).
domain_category(astm_d638_tensile_testing, narrative_history).
domain_category(atsumono_period, extractive_market).
domain_category(authoritarian_power_paradox, extractive_market).
domain_category(automatic_enrollment_defaults, narrative_history).
domain_category(availability_heuristic, narrative_history).
domain_category(axiom_of_choice_determinacy, narrative_history).
domain_category(banach_era, narrative_history).
domain_category(banach_fixed_point, narrative_history).
domain_category(banach_tarski_era, narrative_history).
domain_category(banach_tarski_paradox, narrative_history).
domain_category(base_pair_complementarity, narrative_history).
domain_category(basel_era, narrative_history).
domain_category(basel_problem_convergence, narrative_history).
domain_category(bay_of_pigs_operational_silo, extractive_market).
domain_category(bedouin_sedentary_transition, extractive_market).
domain_category(belief_argument_conclusion, extractive_market).
domain_category(belief_argument_conclusion_interval, extractive_market).
domain_category(berkshire_compounding_culture, narrative_history).
domain_category(big_data_astrophysics_arbitrage, extractive_market).
domain_category(biological_curiosity, narrative_history).
domain_category(bip_narrative_illusion, extractive_market).
domain_category(bip_narrative_illusion_interval, extractive_market).
domain_category(birthday_era, narrative_history).
domain_category(birthday_paradox_collision, narrative_history).
domain_category(blackstone_carried_interest_taxation, narrative_history).
domain_category(blackstone_conflict_era, extractive_market).
domain_category(blackstone_conflicts_of_interest, extractive_market).
domain_category(blackstone_ipo_restructuring, narrative_history).
domain_category(blackstone_smd_control, extractive_market).
domain_category(blackstone_tra, extractive_market).
domain_category(blackstone_tra_life, extractive_market).
domain_category(bloom_acoustic_seduction_vigil, narrative_history).
domain_category(bloom_aeolus_advertisement_circuit, narrative_history).
domain_category(bloom_aeolus_interval, narrative_history).
domain_category(bloom_exclusion_id, narrative_history).
domain_category(bloom_exclusion_interval, narrative_history).
domain_category(bloom_ithaca_interval, narrative_history).
domain_category(bloom_ithaca_mathematical_order, narrative_history).
domain_category(bloom_kosher_transgression, narrative_history).
domain_category(bloom_samaritan_id, narrative_history).
domain_category(bloom_samaritan_paternal_care, narrative_history).
domain_category(bloom_secret_correspondence, narrative_history).
domain_category(bloom_sirens_interval, narrative_history).
domain_category(bloom_social_exclusion_dublin, narrative_history).
domain_category(bloom_xenophobic_exclusion, narrative_history).
domain_category(brain_network_paradigm_2026, narrative_history).
domain_category(broke_vs_poor_grocery_math, extractive_market).
domain_category(brouwer_era, narrative_history).
domain_category(brouwer_fixed_point, narrative_history).
domain_category(buffon_era, narrative_history).
domain_category(buffons_needle_pi_estimation, narrative_history).
domain_category(burali_forti_interval, narrative_history).
domain_category(burali_forti_paradox, narrative_history).
domain_category(burden_of_proof_engineering_safety, extractive_market).
domain_category(burden_of_proof_legal_criminal, narrative_history).
domain_category(burden_of_proof_scientific_empirical, narrative_history).
domain_category(bushman_money_magic, extractive_market).
domain_category(bushman_money_magic_interval, extractive_market).
domain_category(busy_beaver_era, narrative_history).
domain_category(busy_beaver_noncomputability, narrative_history).
domain_category(cantor_set_topology, narrative_history).
domain_category(cap_theorem, narrative_history).
domain_category(cap_theorem_interval, narrative_history).
domain_category(capture_interval, extractive_market).
domain_category(carbon_credit_markets_2026, narrative_history).
domain_category(carbon_credit_markets_2026_int, narrative_history).
domain_category(carrying_capacity, extractive_market).
domain_category(carrying_capacity_interval, extractive_market).
domain_category(castration_longevity_choice, extractive_market).
domain_category(cbdc_deployment, extractive_market).
domain_category(cbdc_implementation, extractive_market).
domain_category(celestial_mechanics_era, narrative_history).
domain_category(central_limit_theorem_convergence, narrative_history).
domain_category(cfsg_era, narrative_history).
domain_category(chaitin_era, narrative_history).
domain_category(chaitins_omega_undecidability, narrative_history).
domain_category(challenger_launch_decision, extractive_market).
domain_category(challenger_o_ring_integrity, extractive_market).
domain_category(challenger_post_mortem, extractive_market).
domain_category(china_critical_mineral_chokepoint, extractive_market).
domain_category(china_taiwan_reunification_mandate, extractive_market).
domain_category(church_turing_era, narrative_history).
domain_category(church_turing_thesis, narrative_history).
domain_category(cia_fbi_legal_wall, extractive_market).
domain_category(click_chemistry_paradigm_2026, narrative_history).
domain_category(climate_attribution_2026, narrative_history).
domain_category(climate_target_one_point_five, narrative_history).
domain_category(cloudflare_dual_class_asymmetry, extractive_market).
domain_category(clt_era, narrative_history).
domain_category(cobra_effect, narrative_history).
domain_category(cognitive_diversity_arbitrage, extractive_market).
domain_category(cognitive_induction_gap, extractive_market).
domain_category(cognitive_mimicry_arbitrage, extractive_market).
domain_category(cognitive_surrender_to_system_3, extractive_market).
domain_category(coinbase_crypto_volatility, narrative_history).
domain_category(coinbase_ipo_window, narrative_history).
domain_category(coinbase_regulatory_uncertainty, extractive_market).
domain_category(collatz_conjecture_determinism, narrative_history).
domain_category(collatz_era, narrative_history).
domain_category(college_admissions_market, extractive_market).
domain_category(colombia_2026_presidential_election, narrative_history).
domain_category(colorado_sbe_decentralization_friction, extractive_market).
domain_category(comitatus_bond, narrative_history).
domain_category(comitatus_era, narrative_history).
domain_category(compounding_logic, narrative_history).
domain_category(confirmation_bias, narrative_history).
domain_category(confirmation_bias_interval, narrative_history).
domain_category(constitutional_consecration, narrative_history).
domain_category(constitutional_supremacy, narrative_history).
domain_category(continuum_era, narrative_history).
domain_category(continuum_hypothesis_undecidability, narrative_history).
domain_category(conversational_dogmas_interruption, narrative_history).
domain_category(conway_era, narrative_history).
domain_category(conways_game_of_life_dynamics, narrative_history).
domain_category(copyleft_viral_licensing, narrative_history).
domain_category(copyright_protection, narrative_history).
domain_category(cost_of_observation, extractive_market).
domain_category(countable_infinity_cardinality, narrative_history).
domain_category(couples_residency_match, narrative_history).
domain_category(cow_field_poop, narrative_history).
domain_category(creative_commons_licensing, narrative_history).
domain_category(credentialing_shift_2026, extractive_market).
domain_category(criminal_trial_sequence, narrative_history).
domain_category(crispr_genomic_rewrite_2026, narrative_history).
domain_category(cuba_blackout_cycle, extractive_market).
domain_category(cuba_mandatrophic_collapse, extractive_market).
domain_category(cuban_missile_crisis_excomm_deliberation, narrative_history).
domain_category(currys_paradox, narrative_history).
domain_category(currys_paradox_interval, narrative_history).
domain_category(damped_harmonics, narrative_history).
domain_category(dark_patterns_manipulation, extractive_market).
domain_category(dead_sea_effect, narrative_history).
domain_category(deferential_realism_framework, narrative_history).
domain_category(dexy_gold_interval, narrative_history).
domain_category(dexy_gold_protocol, narrative_history).
domain_category(digital_credentialing_verification, extractive_market).
domain_category(diminishing_returns_interval, narrative_history).
domain_category(dionysiac_frenzy, extractive_market).
domain_category(dionysiac_frenzy_interval, extractive_market).
domain_category(dldr_information_policy, narrative_history).
domain_category(dldr_policy_interval, narrative_history).
domain_category(dna_structure_discovery, narrative_history).
domain_category(dprk_songun_cycle, extractive_market).
domain_category(dr_recursive_int, narrative_history).
domain_category(dual_masters_dublin_1904, extractive_market).
domain_category(dunbar_interval, narrative_history).
domain_category(dunbars_number, narrative_history).
domain_category(dunning_kruger_effect, narrative_history).
domain_category(e2ee_digital_privacy_2026, narrative_history).
domain_category(education_unbundling_implementation, narrative_history).
domain_category(ek_robot_integration_cycle, narrative_history).
domain_category(electrification_scale_2026, narrative_history).
domain_category(elencher_identity_transformation, narrative_history).
domain_category(em_clinical_guidelines, narrative_history).
domain_category(em_practice_v2, narrative_history).
domain_category(empty_tomb_transformation, narrative_history).
domain_category(endowment_effect, narrative_history).
domain_category(endowment_interval, narrative_history).
domain_category(epigenetics_complexity_2026, narrative_history).
domain_category(ergo_autolykos_asic_resistance, narrative_history).
domain_category(ergo_lets_interval, narrative_history).
domain_category(ergo_lets_protocol, narrative_history).
domain_category(ergo_mixer_protocol, narrative_history).
domain_category(ergo_nipopows, narrative_history).
domain_category(ergo_storage_rent, narrative_history).
domain_category(ergo_storage_rent_mechanism, narrative_history).
domain_category(ergodic_interval, narrative_history).
domain_category(ergodic_theorems, narrative_history).
domain_category(ergot_grain_poisoning, extractive_market).
domain_category(ergot_grain_poisoning_interval, extractive_market).
domain_category(euler_characteristic_topology, narrative_history).
domain_category(euler_era, narrative_history).
domain_category(evolutionary_pressure_01, extractive_market).
domain_category(exoplanetary_habitability_arbitrage, narrative_history).
domain_category(exploration_vs_exploitation, narrative_history).
domain_category(extraordinary_narrative_shift, narrative_history).
domain_category(factional_instability, extractive_market).
domain_category(faint_blue_neural_bifurcation, extractive_market).
domain_category(fair_use_doctrine, narrative_history).
domain_category(family_estrangement_ratio, extractive_market).
domain_category(family_succession_system, extractive_market).
domain_category(fast_growing_hierarchy, narrative_history).
domain_category(fbc_era_operations, extractive_market).
domain_category(federalist_10_analysis, extractive_market).
domain_category(feigenbaum_universality, narrative_history).
domain_category(finite_pool_of_worry, extractive_market).
domain_category(finite_pool_of_worry_interval, extractive_market).
domain_category(finite_simple_group_classification, narrative_history).
domain_category(fittss_law, narrative_history).
domain_category(fittss_law_interval, narrative_history).
domain_category(fmeca_procedures_1980, narrative_history).
domain_category(fmeca_standard_era, narrative_history).
domain_category(four_color_era, narrative_history).
domain_category(four_color_theorem_topological_bound, narrative_history).
domain_category(framing_effect, narrative_history).
domain_category(framing_effect_interval, narrative_history).
domain_category(frankenstein_creation_hubris, extractive_market).
domain_category(fta_era, narrative_history).
domain_category(fundamental_theorem_of_algebra, narrative_history).
domain_category(galactic_selection_event, extractive_market).
domain_category(gale_shapley, extractive_market).
domain_category(galois_era, narrative_history).
domain_category(galois_theory_symmetry, narrative_history).
domain_category(gamblers_ruin_stochastic_extinction, extractive_market).
domain_category(game_theory_era, extractive_market).
domain_category(gauss_bonnet_era, narrative_history).
domain_category(gauss_bonnet_topology, narrative_history).
domain_category(generational_replacement_inertia, extractive_market).
domain_category(genetic_algorithms_evolution, narrative_history).
domain_category(genetic_predisposition, narrative_history).
domain_category(genetic_predisposition_interval, narrative_history).
domain_category(germline_regulation_threshold_2026, narrative_history).
domain_category(gerty_bloom_interval, narrative_history).
domain_category(gerty_bloom_voyeuristic_distance, narrative_history).
domain_category(gestation_the_wombfruit, narrative_history).
domain_category(gestation_wombfruit_id, narrative_history).
domain_category(gettysburg_address_analysis, narrative_history).
domain_category(gig_economy_algorithmic_management, extractive_market).
domain_category(gilgamesh_epic_cycle, extractive_market).
domain_category(gilgamesh_mortality_limit, extractive_market).
domain_category(gita_kurukshetra, narrative_history).
domain_category(gln_standard_lifecycle, narrative_history).
domain_category(glp1_market_impact_2026, narrative_history).
domain_category(glp1_payload_efficiency_pivot, narrative_history).
domain_category(goedel_era, narrative_history).
domain_category(goedels_incompleteness_theorems, narrative_history).
domain_category(goldbach_conjecture, narrative_history).
domain_category(goldbach_era, narrative_history).
domain_category(golden_handcuffs, narrative_history).
domain_category(goodharts_law, narrative_history).
domain_category(goodharts_law_interval, narrative_history).
domain_category(gradient_descent_optimization, narrative_history).
domain_category(graph_coloring_complexity, narrative_history).
domain_category(graph_coloring_interval, narrative_history).
domain_category(greenland_crisis_2026, extractive_market).
domain_category(greenland_seizure_trade_war, extractive_market).
domain_category(greshams_law, narrative_history).
domain_category(grete_samsa_transition, narrative_history).
domain_category(gs1_gln_identification, narrative_history).
domain_category(gs1_spec_v25, narrative_history).
domain_category(gs1_standardized_identification, narrative_history).
domain_category(halting_era, narrative_history).
domain_category(halting_problem_undecidability, narrative_history).
domain_category(hamiltonian_path_complexity, narrative_history).
domain_category(hammurabi_lex_talionis, narrative_history).
domain_category(hanlons_razor, narrative_history).
domain_category(happiness_of_others, extractive_market).
domain_category(harm_principle_liberty, narrative_history).
domain_category(hawthorne_effect, narrative_history).
domain_category(hawthorne_interval, narrative_history).
domain_category(hegemony_transition_window, extractive_market).
domain_category(heisenberg_interval, narrative_history).
domain_category(heisenberg_uncertainty, narrative_history).
domain_category(helsinki_bus_theory, narrative_history).
domain_category(heuristic_optimization, narrative_history).
domain_category(hilberts_hotel_infinity, narrative_history).
domain_category(history_nightmare_1904, extractive_market).
domain_category(hiv_prep_prevention_2026, narrative_history).
domain_category(hoa_architectural_covenants, narrative_history).
domain_category(hoa_interval, narrative_history).
domain_category(hominin_evolutionary_bottleneck, extractive_market).
domain_category(hydra_game, extractive_market).
domain_category(hydra_interval, extractive_market).
domain_category(implementation_window_2026, narrative_history).
domain_category(indexical_relativity_core, narrative_history).
domain_category(industrial_testing_regime, narrative_history).
domain_category(information_foraging_theory, narrative_history).
domain_category(inner_model_era, narrative_history).
domain_category(inner_model_theory_constraints, narrative_history).
domain_category(innovators_dilemma, narrative_history).
domain_category(innovators_dilemma_interval, narrative_history).
domain_category(institutional_mutation_domestication, extractive_market).
domain_category(insult_wisdom_interval, extractive_market).
domain_category(insult_wisdom_training, extractive_market).
domain_category(integrated_digital_governance_stack, extractive_market).
domain_category(interstellar_quantum_link, narrative_history).
domain_category(iran_mandatrophic_collapse, extractive_market).
domain_category(iran_unrest_2025, extractive_market).
domain_category(iron_law_of_oligarchy, narrative_history).
domain_category(japan_gx_transition, narrative_history).
domain_category(japanese_energy_scaffold_2025, narrative_history).
domain_category(jevons_interval, narrative_history).
domain_category(jevons_paradox, narrative_history).
domain_category(job_hunt_volume_system_2026, extractive_market).
domain_category(keltner_relationship_evaluation, narrative_history).
domain_category(khantivadin_patience_interval, extractive_market).
domain_category(khantivadin_radical_patience, extractive_market).
domain_category(kidney_exchange_market, narrative_history).
domain_category(kirby_paris_interval, narrative_history).
domain_category(kirby_paris_theorem, narrative_history).
domain_category(kjv_great_awakening, narrative_history).
domain_category(kjv_linguistic_residue, narrative_history).
domain_category(kjv_puritan_new_world_exit, narrative_history).
domain_category(kjv_textual_authority, narrative_history).
domain_category(kleene_era, narrative_history).
domain_category(kleene_recursion_theorem, narrative_history).
domain_category(labor_management_conflict_r1, narrative_history).
domain_category(landscape_of_fear_2026, narrative_history).
domain_category(large_cardinal_era, narrative_history).
domain_category(large_cardinal_foundations, narrative_history).
domain_category(law_of_diminishing_returns, narrative_history).
domain_category(layered_brain_processing, narrative_history).
domain_category(legacy_system_technical_debt, narrative_history).
domain_category(lehman_repo_105, extractive_market).
domain_category(lestrygonian_metabolism_chp8, narrative_history).
domain_category(lestrygonian_metabolism_chp8_interval, narrative_history).
domain_category(liar_paradox, narrative_history).
domain_category(liar_paradox_interval, narrative_history).
domain_category(lindy_effect, narrative_history).
domain_category(litany_of_the_real, narrative_history).
domain_category(lln_convergence, narrative_history).
domain_category(lln_era, narrative_history).
domain_category(lobs_theorem, narrative_history).
domain_category(lobs_theorem_interval, narrative_history).
domain_category(local_vs_global_optima, narrative_history).
domain_category(logistic_map_dynamics, narrative_history).
domain_category(logistic_map_era, narrative_history).
domain_category(lorenz_attractor_dynamics, narrative_history).
domain_category(lorenz_era, narrative_history).
domain_category(lowenheim_skolem_interval, narrative_history).
domain_category(lowenheim_skolem_theorem, narrative_history).
domain_category(lsd_microdosing_professional_openness, narrative_history).
domain_category(lula_hemisphere_2026, extractive_market).
domain_category(magna_carta_liberties, narrative_history).
domain_category(mandatrophic_margin_collapse, extractive_market).
domain_category(mandatrophy_cycle, extractive_market).
domain_category(mandatrophy_lifecycle, extractive_market).
domain_category(mandatrophy_systemic_collapse, extractive_market).
domain_category(mariner_to_msl_era, narrative_history).
domain_category(mars_autonomy_evolution, narrative_history).
domain_category(mars_rover_navigational_autonomy, narrative_history).
domain_category(martian_signal_latency, narrative_history).
domain_category(matching_markets_general, narrative_history).
domain_category(matching_theory_era, narrative_history).
domain_category(material_tensile_strength, narrative_history).
domain_category(max_flow_min_cut, narrative_history).
domain_category(mco_failure_trajectory, extractive_market).
domain_category(mco_unit_system_discontinuity, extractive_market).
domain_category(med_diet_consensus_2026, narrative_history).
domain_category(medical_residency_match, narrative_history).
domain_category(medieval_church_hegemony, extractive_market).
domain_category(meta_logic_01, narrative_history).
domain_category(meta_stack_convergence, extractive_market).
domain_category(metamorphosis_samsa, extractive_market).
domain_category(micro_robot_electronics_integration, narrative_history).
domain_category(microbiome_symbiosis, narrative_history).
domain_category(midnight_deadline, narrative_history).
domain_category(midnight_deadline_period, narrative_history).
domain_category(migration_decision_threshold, narrative_history).
domain_category(migration_theory_review, narrative_history).
domain_category(mil_std_461g_emi_control, narrative_history).
domain_category(mil_std_461g_era, narrative_history).
domain_category(mil_std_810f_era, narrative_history).
domain_category(mil_std_810f_tailoring, narrative_history).
domain_category(minimax_decision_rule, narrative_history).
domain_category(minimax_era, narrative_history).
domain_category(misunderstanding_as_mismatch, extractive_market).
domain_category(molly_affirmation_cycle, narrative_history).
domain_category(molly_affirmation_id, narrative_history).
domain_category(monetary_regime_transition, narrative_history).
domain_category(monty_hall_conditional_probability, narrative_history).
domain_category(moores_law, narrative_history).
domain_category(moores_law_interval, narrative_history).
domain_category(nasa_faster_better_cheaper, extractive_market).
domain_category(nash_equilibrium_coordination, narrative_history).
domain_category(nash_era, narrative_history).
domain_category(necessary_day_job, extractive_market).
domain_category(negative_emissions_arbitrage, extractive_market).
domain_category(nestor_afternoon, extractive_market).
domain_category(net_zero_stabilization, extractive_market).
domain_category(network_effects, narrative_history).
domain_category(neural_interoperability, extractive_market).
domain_category(neurodiversity_spectrum, extractive_market).
domain_category(newton_era, narrative_history).
domain_category(newtons_method_convergence, narrative_history).
domain_category(nighttown_hallucinatory_vigil, narrative_history).
domain_category(nighttown_vigil_id, narrative_history).
domain_category(nixon_shock_1971, narrative_history).
domain_category(no_cloning_interval, narrative_history).
domain_category(no_cloning_theorem, narrative_history).
domain_category(noether_era, narrative_history).
domain_category(noethers_theorem_symmetry, narrative_history).
domain_category(non_compete_agreements, extractive_market).
domain_category(nonstandard_arithmetic_models, narrative_history).
domain_category(north_korea_songun_mandatrophy, extractive_market).
domain_category(oligarchy_interval, narrative_history).
domain_category(omelet_perfection_complexity, narrative_history).
domain_category(omelet_perfection_interval, narrative_history).
domain_category(on_liberty_analysis, narrative_history).
domain_category(openbsd_netiquette_protocol, narrative_history).
domain_category(operation_zapata_timeline, extractive_market).
domain_category(optimal_stopping_marriage, narrative_history).
domain_category(overton_interval, narrative_history).
domain_category(overton_window, narrative_history).
domain_category(p_vs_np, narrative_history).
domain_category(p_vs_np_interval, narrative_history).
domain_category(parable_fish_turtle, extractive_market).
domain_category(pareto_principle, narrative_history).
domain_category(parkinson_interval, narrative_history).
domain_category(parkinsons_law, narrative_history).
domain_category(peano_curve_mapping, narrative_history).
domain_category(peano_era, narrative_history).
domain_category(permissive_software_licensing, narrative_history).
domain_category(personalized_nutritional_arbitrage, extractive_market).
domain_category(peter_principle, narrative_history).
domain_category(planetary_boundaries, extractive_market).
domain_category(planetary_diet_constraint_2026, narrative_history).
domain_category(planning_fallacy, narrative_history).
domain_category(planning_fallacy_interval, narrative_history).
domain_category(platform_cooperativism_governance, narrative_history).
domain_category(platform_labor_epoch, extractive_market).
domain_category(pnt_era, narrative_history).
domain_category(poetic_verse_and_past, extractive_market).
domain_category(poincare_conjecture, narrative_history).
domain_category(poincare_era, narrative_history).
domain_category(politeness_face_negotiation, extractive_market).
domain_category(post_trump_return, extractive_market).
domain_category(postman_survival_interval, narrative_history).
domain_category(postman_survival_protocol, narrative_history).
domain_category(pre_911_silo_regime, extractive_market).
domain_category(prime_number_theorem, narrative_history).
domain_category(prisoners_dilemma_equilibrium, extractive_market).
domain_category(private_identity_integration, narrative_history).
domain_category(probability_paradox_era, narrative_history).
domain_category(proof_of_work_consensus, narrative_history).
domain_category(protean_signatures_1904, narrative_history).
domain_category(proteus_strand_walk, narrative_history).
domain_category(public_domain_commons, narrative_history).
domain_category(pythagorean_era, narrative_history).
domain_category(pythagorean_geometric_constancy, narrative_history).
domain_category(qi_interval, extractive_market).
domain_category(qualified_immunity, extractive_market).
domain_category(quantum_decryption_risk_2026, extractive_market).
domain_category(quantum_entanglement_protocol, narrative_history).
domain_category(quantum_nonlocality_2026, narrative_history).
domain_category(quellcrist_falconer_justice, extractive_market).
domain_category(quine_era, narrative_history).
domain_category(quine_self_replication, narrative_history).
domain_category(qwerty_lockin_interval, narrative_history).
domain_category(qwerty_vs_dvorak, narrative_history).
domain_category(radiologic_diagnostic_threshold, extractive_market).
domain_category(radiology_r7, extractive_market).
domain_category(railway_gauge_standard, narrative_history).
domain_category(reciprocity_laws_math, narrative_history).
domain_category(regulatory_capture, extractive_market).
domain_category(rejuvenation_centenary_cycle, extractive_market).
domain_category(relativity_of_simultaneity, narrative_history).
domain_category(relativity_physical_invariance, narrative_history).
domain_category(rfc9293_state_machine, narrative_history).
domain_category(rices_era, narrative_history).
domain_category(rices_theorem_undecidability, narrative_history).
domain_category(rn_withdrawal_cycle, extractive_market).
domain_category(rogers_commission_institutional_analysis, extractive_market).
domain_category(rope_design, narrative_history).
domain_category(rosen_bridge_interval, narrative_history).
domain_category(rosen_bridge_protocol, narrative_history).
domain_category(rotation_seven_black_soil, extractive_market).
domain_category(rotation_seven_isolation, extractive_market).
domain_category(rotation_seven_kubo_ranking, extractive_market).
domain_category(royal_navy_middle_east_withdrawal, extractive_market).
domain_category(ruin_era, extractive_market).
domain_category(rules_based_international_order, extractive_market).
domain_category(russell_era, extractive_market).
domain_category(russells_paradox_self_reference, extractive_market).
domain_category(russia_cannibalization_cycle, extractive_market).
domain_category(russian_war_cannibalization, extractive_market).
domain_category(sadhu_integrity_protocol, narrative_history).
domain_category(samsa_transformation_period, extractive_market).
domain_category(sapir_whorf_hypothesis, narrative_history).
domain_category(sapir_whorf_interval, narrative_history).
domain_category(sat_csp_complexity, narrative_history).
domain_category(sat_csp_interval, narrative_history).
domain_category(scientific_consensus_period, narrative_history).
domain_category(scientific_revolution_current, narrative_history).
domain_category(scs_legal_era, narrative_history).
domain_category(scs_operational_2026, extractive_market).
domain_category(scurvy_maritime_extraction, extractive_market).
domain_category(scurvy_maritime_interval, extractive_market).
domain_category(self_surpassing, extractive_market).
domain_category(shannon_entropy_limit, narrative_history).
domain_category(shitty_feedback_handling, narrative_history).
domain_category(shobies_existential_commitment, extractive_market).
domain_category(sig_usd_interval, narrative_history).
domain_category(sig_usd_protocol, narrative_history).
domain_category(silicon_lexicon_overload, extractive_market).
domain_category(skills_based_hiring, narrative_history).
domain_category(skolem_era, narrative_history).
domain_category(skolems_paradox, narrative_history).
domain_category(skolems_paradox_interval, narrative_history).
domain_category(sludge_bureaucratic_friction, extractive_market).
domain_category(smartphone_ubiquity, extractive_market).
domain_category(social_credit_architecture, extractive_market).
domain_category(social_loafing, narrative_history).
domain_category(social_loafing_interval, narrative_history).
domain_category(social_media_2025_cycle, narrative_history).
domain_category(social_media_participation_threshold, narrative_history).
domain_category(social_narrative_casting, narrative_history).
domain_category(software_lifecycle_r7, narrative_history).
domain_category(solar_system_weirdness, narrative_history).
domain_category(somatic_focusing_awareness, narrative_history).
domain_category(sorites_interval, narrative_history).
domain_category(sorites_paradox, narrative_history).
domain_category(south_china_sea_arbitration_2016_2026, narrative_history).
domain_category(square_cube_interval, narrative_history).
domain_category(square_cube_law, narrative_history).
domain_category(st_petersburg_era, extractive_market).
domain_category(st_petersburg_paradox, extractive_market).
domain_category(stable_marriage_coordination, narrative_history).
domain_category(starwars_evolutionary_mutation, extractive_market).
domain_category(statecraft_virtu, extractive_market).
domain_category(statecraft_virtu_analysis, extractive_market).
domain_category(steinmetz_valuation_asymmetry, extractive_market).
domain_category(stephen_shakespeare_ghost, narrative_history).
domain_category(stoic_logos_governance, extractive_market).
domain_category(strange_attractor_dynamics, narrative_history).
domain_category(sts86_ascent_checklist, narrative_history).
domain_category(sturgeon_interval, narrative_history).
domain_category(sturgeons_law, narrative_history).
domain_category(suanne_coup_of_peace, extractive_market).
domain_category(suanne_face_restoration, extractive_market).
domain_category(sunk_cost_fallacy, narrative_history).
domain_category(sunk_cost_interval, narrative_history).
domain_category(suslin_era, narrative_history).
domain_category(suslin_hypothesis_undecidability, narrative_history).
domain_category(sylow_era, narrative_history).
domain_category(sylow_theorems_group_theory, narrative_history).
domain_category(system_3_emergence, extractive_market).
domain_category(taiwan_existential_sovereignty, extractive_market).
domain_category(taiwan_status_quo_cycle, extractive_market).
domain_category(taiwan_strait_hegemony_shift, extractive_market).
domain_category(tarski_interval, narrative_history).
domain_category(tarski_undefinability, narrative_history).
domain_category(tcp_rfc9293_interoperability, narrative_history).
domain_category(teaching_horses_to_sing, extractive_market).
domain_category(teaching_horses_to_sing_interval, extractive_market).
domain_category(technological_provenance_arbitrage, extractive_market).
domain_category(telemachus_morning, extractive_market).
domain_category(temporal_scale_arbitrage, extractive_market).
domain_category(tensile_strength_interval, narrative_history).
domain_category(texas_hispanic_political_pivot, extractive_market).
domain_category(the_bacchae_madness_protocol, extractive_market).
domain_category(the_calm_expedition_window, extractive_market).
domain_category(the_calm_protocol_suppression, extractive_market).
domain_category(the_churn_systemic_upheaval, extractive_market).
domain_category(the_viceregal_cavalcade, narrative_history).
domain_category(the_wall_procedural_barrier, extractive_market).
domain_category(theban_dionysian_conflict, extractive_market).
domain_category(theory_of_visitors, extractive_market).
domain_category(thermodynamics_entropy, extractive_market).
domain_category(thermodynamics_entropy_interval, extractive_market).
domain_category(thirteen_days_crisis, narrative_history).
domain_category(three_body_unpredictability, narrative_history).
domain_category(toxic_social_infection, extractive_market).
domain_category(toxic_social_infection_interval, extractive_market).
domain_category(tractarian_logic_limit, extractive_market).
domain_category(trade_secret_law, narrative_history).
domain_category(tragedy_of_the_commons, extractive_market).
domain_category(transformer_self_attention, extractive_market).
domain_category(transient_event_detection, narrative_history).
domain_category(traveling_salesperson_problem, narrative_history).
domain_category(trojan_collapse_interval, extractive_market).
domain_category(trojan_war_spoils, extractive_market).
domain_category(trump_authoritarianism_2026, extractive_market).
domain_category(trump_ii_year_one, extractive_market).
domain_category(trump_making_china_great_2026, extractive_market).
domain_category(tx_pivot_window_2026, extractive_market).
domain_category(udhr_1948, narrative_history).
domain_category(un_era, narrative_history).
domain_category(unclos_2026, narrative_history).
domain_category(unclos_era, narrative_history).
domain_category(union_protection_underperformance, narrative_history).
domain_category(universal_mathematics_communication, narrative_history).
domain_category(us_suburban_zoning_2025, extractive_market).
domain_category(us_two_party_duopoly, extractive_market).
domain_category(utopia_apocalypse_fragility, extractive_market).
domain_category(van_der_waerden_interval, narrative_history).
domain_category(van_der_waerden_theorem, narrative_history).
domain_category(viral_transmission_rates, extractive_market).
domain_category(visa_ipo_regulatory_compliance, narrative_history).
domain_category(visa_ipo_window, narrative_history).
domain_category(visa_judgment_sharing_agreement, narrative_history).
domain_category(visa_litigation_ringfencing, narrative_history).
domain_category(weber_fechner_law, narrative_history).
domain_category(whitehead_era, narrative_history).
domain_category(whitehead_problem_undecidability, narrative_history).
domain_category(wikipedia_crowdsourcing_2026, narrative_history).
domain_category(wikipedia_notability_requirement_2026, narrative_history).
domain_category(winners_curse, extractive_market).
domain_category(xi_mao_ideological_centralization, extractive_market).
domain_category(zarathustra_hazar, extractive_market).
domain_category(zipfs_law, extractive_market).% ============================================================================
% DR-AUDIT CORE: drl_audit_core.pl
% ============================================================================
:- module(drl_audit_core, [
    effective_extraction/3,
    structural_signature/3,
    ontological_fraud_check/2,
    omega_risk/4,
    pi/2
]).

% Ensure there is a blank line here.
% --- II-D: POWER MODIFIER FUNCTION (pi) ---
pi(individual_powerless, 1.5).
pi(individual_moderate, 1.0).
pi(individual_powerful, 0.5).
pi(collective_organized, 0.7).
pi(institutional, -0.2).
pi(analytical, 1.0).

% --- II-D: CHI CALCULATION (chi) ---
% chi(C, P) = X_base(C) * pi(P)
effective_extraction(X_base, Power, Chi) :-
    pi(Power, Modifier),
    Chi is X_base * Modifier.

% --- III-A: STRUCTURAL SIGNATURES ---
% Tangled Rope (TR): Hybrid coordination/extraction
structural_signature(Chi, Data, tangled_rope) :-
    Chi >= 0.40, 
    Chi =< 0.90,
    member(coord_function(true), Data), 
    !.
% Snare (N): Pure extraction
structural_signature(Chi, _, snare) :- 
    Chi >= 0.66, 
    !.
% Rope (R): Pure coordination
structural_signature(Chi, _, rope) :- 
    Chi =< 0.35, 
    !.
% Mountain (M): Default/Unscaled limit
structural_signature(_, _, mountain).

% --- IV-B: Omega Risks ---
omega_risk(snare, rope, type_iii, "Extraction masked as coordination.").
omega_risk(snare, mountain, type_vi, "Naturalization of extraction.").

% --- IV-C: FORENSIC AUDIT TOOLS (Diagnostic Flags) ---

% False Mountain (FM): High enforcement masquerading as natural law
% Logic: Claimed=mountain AND epsilon > 0.60
ontological_fraud_check(Data, fm_alert) :-
    member(claimed_type(mountain), Data),
    member(suppression_score(Epsilon), Data),
    Epsilon > 0.60, !.

% Zero Degrees of Freedom (Z): The absolute trap
% Logic: epsilon -> 1.0 AND chi -> 1.0
ontological_fraud_check(Data, z_alert) :-
    member(suppression_score(Epsilon), Data),
    Epsilon >= 0.90,
    member(base_extractiveness(X_base), Data),
    X_base >= 0.85, !.

ontological_fraud_check(_, coherent).
% ============================================================================
% DRL CORE - INDEXICAL CONSTRAINT CLASSIFICATION v4.0
% ============================================================================
% This module implements context-indexed Deferential Realism classification.
% Every Mountain/Rope/Snare judgment is INDEXED to WHO/WHEN/WHERE/HOW.
%
% BREAKING CHANGES FROM v3.x:
% - dr_type/2 now defaults to analytical context (backward compatible)
% - dr_type/3 is PRIMARY API (adds Context parameter)
% - All classification uses power-scaled extractiveness
% - Structural signatures integrated with indexical logic
% - Action routing context-aware
%
% Integration: Load after constraint_indexing.pl, before drl_modal_logic.pl
% ============================================================================

:- module(drl_core, [
    % PRIMARY API - Context-Indexed Classification
    dr_type/3,                      % dr_type(Constraint, Context, Type)
    dr_type/2,                      % Backward compat: uses default context
    
    % Action Routing (Indexed)
    dr_action/3,                    % dr_action(Constraint, Context, Action)
    dr_action/2,                    % Backward compat
    
    % Error Detection (Indexed)
    dr_mismatch/4,                  % dr_mismatch(C, Context, ErrorType, Severity)
    dr_mismatch/3,                  % Backward compat
    
    % Structural Signature Integration
    dr_signature/2,                 % dr_signature(Constraint, Signature)
    
    % Re-exported from constraint_indexing
    constraint_classification/3,    % Multifile hook for data files
    constraint_claim_indexed/2,     % Legacy wrapper
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1,

    % Centralize module references
    base_extractiveness/2,
    suppression_score/2,
    requires_active_enforcement/1,
    emerges_naturally/1,
    
    % Exposed helpers for modal_logic and testing
    is_mountain/3,                  % Indexed version
    is_rope/3,
    is_snare/3,
    is_tangled_rope/3,
    is_piton/3
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(constraint_instances).
:- use_module(domain_priors).

% Declare these as multifile to allow other modules to contribute data
:- multifile 
    base_extractiveness/2, 
    suppression_score/2, 
    requires_active_enforcement/1, 
    emerges_naturally/1.

% Provide a 'fail-safe' default clause to satisfy the compiler
base_extractiveness(_, 0.0) :- fail.
suppression_score(_, 0.0) :- fail.
requires_active_enforcement(_) :- fail.
emerges_naturally(_) :- fail.

% Re-export indexed classification predicates from constraint_indexing
:- reexport(constraint_indexing, [
    constraint_classification/3,
    constraint_claim_indexed/2,
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1
]).

% ============================================================================
% CLASSIFICATION LOGIC - INDEXED VERSION (PRIMARY)
% ============================================================================

% ----------------------------------------------------------------------------
% Mountain Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Mountain FROM A CONTEXT if:
% 1. It appears immutable given time horizon + exit options
% 2. Suppression requirement is below threshold

is_mountain(C, Context, mountain) :-
    % Check time-based immutability perception
    constraint_indexing:effective_immutability_for_context(Context, mountain),
    
    % Check suppression is low (inherent, not enforced)
    v3_1_config:param(mountain_suppression_ceiling, Ceil),
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E =< Ceil,
    !.

is_mountain(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Rope FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) is below threshold
% 2. It's changeable (time horizon allows modification)

is_rope(C, Context, rope) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check against rope threshold
    v3_1_config:param(rope_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % Must be perceived as changeable
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Snare Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Snare FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) exceeds floor
% 2. Requires active suppression (enforced)
% 3. Perceived as changeable (not Mountain)

is_snare(C, Context, snare) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check extraction floor
    v3_1_config:param(snare_extraction_floor, XFloor),
    EffectiveX >= XFloor,
    
    % Check suppression requirement
    v3_1_config:param(snare_suppression_floor, EFloor),
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E >= EFloor,
    
    % Must NOT appear as Mountain from this context
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_snare(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Tangled Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Tangled Rope FROM A CONTEXT if:
% 1. Effective extractiveness in middle-to-high range (uses config params)
% 2. High suppression (uses config params)
% 3. Has BOTH coordination function AND asymmetric extraction
% 4. Requires active enforcement
%
% Updated January 2026 based on empirical validation (168/467 constraints, 36%)
%
% This is genuinely hybrid: provides coordination (like rope) while extracting
% (like snare). Requires surgical reform to preserve coordination while cutting extraction.

is_tangled_rope(C, Context, tangled_rope) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),

    % Check tangled rope range (from config)
    v3_1_config:param(tangled_rope_extraction_floor, FloorX),
    v3_1_config:param(tangled_rope_extraction_ceil, CeilX),
    EffectiveX >= FloorX,
    EffectiveX =< CeilX,

    % High suppression required (from config)
    v3_1_config:param(tangled_rope_suppression_floor, MinS),
    narrative_ontology:constraint_metric(C, suppression_requirement, S),
    S >= MinS,

    % Must require active enforcement (constructed constraint)
    requires_active_enforcement(C),

    % Must have both coordination function AND asymmetric extraction
    narrative_ontology:has_coordination_function(C),
    narrative_ontology:has_asymmetric_extraction(C),
    !.

is_tangled_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Piton Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Piton FROM A CONTEXT if:
% 1. Low effective extractiveness
% 2. High suppression (expensive to maintain)
% 3. Should be cut but isn't

is_piton(C, Context, piton) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Low extraction
    v3_1_config:param(piton_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % High suppression (maintenance cost)
    narrative_ontology:constraint_metric(C, suppression_requirement, E),
    E > XCeil,
    !.

is_piton(_C, _Context, fail).

% ============================================================================
% CANONICAL TYPE DETERMINATION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Classification: dr_type/3
% ----------------------------------------------------------------------------
% Determines constraint type FROM A SPECIFIC CONTEXT
% Integrates: (1) Metric-based classification, (2) Structural signatures

dr_type(C, Context, Type) :-
    % Validate context
    constraint_indexing:valid_context(Context),
    
    % First: Try metric-based classification with power scaling
    metric_based_type_indexed(C, Context, MetricType),
    
    % Second: Check if structural signature overrides
    structural_signatures:integrate_signature_with_modal(C, MetricType, Type),
    !.

dr_type(_C, _Context, unknown).

% ----------------------------------------------------------------------------
% Metric-Based Classification (Indexed) - Helper
% ----------------------------------------------------------------------------

metric_based_type_indexed(C, Context, mountain) :-
    is_mountain(C, Context, mountain), !.

metric_based_type_indexed(C, Context, snare) :-
    is_snare(C, Context, snare), !.

metric_based_type_indexed(C, Context, rope) :-
    is_rope(C, Context, rope), !.

metric_based_type_indexed(C, Context, tangled_rope) :-
    is_tangled_rope(C, Context, tangled_rope), !.

metric_based_type_indexed(C, Context, piton) :-
    is_piton(C, Context, piton), !.

metric_based_type_indexed(_C, _Context, unknown).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% ----------------------------------------------------------------------------
% Legacy dr_type/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_type(C, Type) :-
    constraint_indexing:default_context(Ctx),
    dr_type(C, Ctx, Type).

% ============================================================================
% ACTION ROUTING (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Action Router: dr_action/3
% ----------------------------------------------------------------------------
% Recommends action based on constraint type FROM SPECIFIC CONTEXT

dr_action(C, Context, accept) :-
    dr_type(C, Context, mountain), !.

dr_action(C, Context, maintain) :-
    dr_type(C, Context, rope), !.

dr_action(C, Context, reform) :-
    dr_type(C, Context, tangled_rope), !.

dr_action(C, Context, cut) :-
    dr_type(C, Context, snare), !.

dr_action(C, Context, bypass) :-
    dr_type(C, Context, piton), !.

dr_action(_C, _Context, investigate).

% ----------------------------------------------------------------------------
% Legacy dr_action/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_action(C, Action) :-
    constraint_indexing:default_context(Ctx),
    dr_action(C, Ctx, Action).

% ============================================================================
% ERROR DETECTION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Type 1: False Mountain (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Mountain but ISN'T from this context

dr_mismatch(C, Context, type_1_false_mountain, severe) :-
    % Check if claimed as mountain in data
    narrative_ontology:constraint_claim(C, mountain),
    
    % Verify it's NOT a mountain from this context
    is_mountain(C, Context, fail),
    !.

% ----------------------------------------------------------------------------
% Type 3: Snare Misidentified as Rope (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Rope but is actually Snare from this context

dr_mismatch(C, Context, type_3_snare_as_rope, severe) :-
    narrative_ontology:constraint_claim(C, rope),
    is_snare(C, Context, snare),
    !.

% ----------------------------------------------------------------------------
% Type 5: Piton Misidentified as Snare (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Snare but is actually Piton from this context

dr_mismatch(C, Context, type_5_piton_as_snare, moderate) :-
    narrative_ontology:constraint_claim(C, snare),
    is_piton(C, Context, piton),
    !.

% ----------------------------------------------------------------------------
% Type 7: Perspectival Incoherence (NEW)
% ----------------------------------------------------------------------------
% Same constraint classified differently across meaningful perspectives
% This is NOT an error but a FEATURE - it indicates indexical relativity

dr_mismatch(C, perspectival_gap(Type1, Ctx1, Type2, Ctx2), 
            perspectival_incoherence, informational) :-
    % Find two different classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Types must differ
    Type1 \= Type2,
    
    % Contexts must differ in meaningful way (not analytical vs analytical)
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    P1 \= analytical,
    P2 \= analytical,
    P1 \= P2,
    !.

% ----------------------------------------------------------------------------
% Legacy dr_mismatch/3 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_mismatch(C, ErrorType, Severity) :-
    constraint_indexing:default_context(Ctx),
    dr_mismatch(C, Ctx, ErrorType, Severity).

% ============================================================================
% STRUCTURAL SIGNATURE DETECTION
% ============================================================================

%% dr_signature(+Constraint, -Signature)
%  Detects structural signature: natural_law | coordination_scaffold | 
%  constructed_constraint | ambiguous
%
%  NOTE: Signatures are NOT indexed - they represent the constraint's
%        fundamental structure, not perspectival appearance

dr_signature(C, Signature) :-
    structural_signatures:constraint_signature(C, Signature).

% ============================================================================
% PERSPECTIVAL GAP DETECTION (NEW)
% ============================================================================

%% perspectival_gap(+Constraint, -GapReport)
%  Detects when same constraint classifies differently across perspectives
%  Returns structured gap information for Omega generation

perspectival_gap(C, gap(Type1, Ctx1, Type2, Ctx2, PowerDelta)) :-
    % Find two classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Must differ in type
    Type1 \= Type2,
    
    % Extract power levels
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    
    % Must be non-analytical
    P1 \= analytical,
    P2 \= analytical,
    
    % Must differ in power
    P1 \= P2,
    
    % Calculate power delta for severity assessment
    constraint_indexing:power_modifier(P1, Mod1),
    constraint_indexing:power_modifier(P2, Mod2),
    PowerDelta is abs(Mod1 - Mod2),
    !.

% ============================================================================
% INDEXICAL ANALYSIS UTILITIES (NEW)
% ============================================================================

%% cross_context_analysis(+Constraint, -Analysis)
%  Analyzes how constraint appears across standard contexts
%  Useful for validation and debugging

cross_context_analysis(C, Analysis) :-
    findall(
        context_result(Ctx, Type),
        (standard_context(Ctx),
         dr_type(C, Ctx, Type)),
        Results
    ),
    Analysis = cross_context(C, Results).

% Standard contexts for testing
standard_context(context(agent_power(individual_powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

% ============================================================================
% VERSION & COMPATIBILITY INFO
% ============================================================================

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: dr_type/3 is now primary API (added Context)
  - NEW: Full indexical relativity integration
  - NEW: Power-scaled extractiveness in all classifications
  - NEW: Perspectival gap detection
  - NEW: dr_action/3, dr_mismatch/4 (indexed versions)
  - CHANGED: All classification uses effective_extractiveness
  - MAINTAIN: Backward compatibility via dr_type/2, dr_action/2

v3.2:
  - Added structural signature integration
  - Signature overrides metric-based classification

v3.1:
  - Consolidated namespace
  - Added piton detection

v3.0:
  - Initial metric-based classification

MIGRATION GUIDE v3.x → v4.0:
  Old: dr_type(constraint, Type)
  New: dr_type(constraint, Context, Type)
  
  For backward compat, old form still works (uses analytical context).
  
  To get indexed classification:
    constraint_indexing:default_context(Ctx),  % or build custom context
    dr_type(constraint, Ctx, Type)
*/
% ============================================================================
% CORE ENGINE: drl_engine.pl
% ============================================================================
:- module(drl_engine, [
    load_corpus/1,
    evaluate_tension/3,
    structural_twin/3
]).

% --- Logic Constants (Section II-D) ---
% Calibration values for the Power Modifier function (pi)
power_modifier(individual_powerless, 1.5).   % Experience MORE extraction
power_modifier(individual_moderate, 1.0).    % Baseline
power_modifier(individual_powerful, 0.5).    % Experience LESS extraction
power_modifier(collective_organized, 0.7).   % Shared burden
power_modifier(institutional, -0.2).         % NET BENEFICIARY
power_modifier(analytical, 1.0).             % Neutral observer

% --- 1. INGESTION ---
load_corpus(Directory) :-
    directory_files(Directory, Files),
    include(is_prolog_file, Files, CleanFiles),
    maplist(ingest_constraint, CleanFiles).

ingest_constraint(File) :-
    % Loads the data entries without logic module collisions
    consult(File).

% --- 2. EVALUATION: The chi Function ---
% chi(C, P) = X_base(C) * pi(P)
evaluate_tension(ConstraintID, AgentIndex, result(Chi, Type)) :-
    % Access the standardized fact structure
    constraint_data(ConstraintID, Data),
    member(base_extractiveness(X_base), Data),
    AgentIndex = context(Power, _, _, _),
    power_modifier(Power, Pi),
    Chi is X_base * Pi,
    classify_by_chi(Chi, Data, Type).

% --- 3. CLASSIFICATION LOGIC (Section III-A) ---
classify_by_chi(Chi, Data, tangled_rope) :-
    % TR: Hybrid coordination/extraction (0.40 <= chi <= 0.90)
    Chi >= 0.40, Chi <= 0.90,
    member(coord_function(true), Data), !.

classify_by_chi(Chi, _, snare) :-
    % Snare: Pure extraction (chi >= 0.66)
    Chi >= 0.66, !.

classify_by_chi(Chi, _, rope) :-
    % Rope: Pure coordination (chi <= 0.35)
    Chi <= 0.35, !.

classify_by_chi(_, _, mountain) :-
    % Mountain: Default for natural/unscaled limits
    true.

% --- 4. ISOMORPHISM (CROSS-DOMAIN ANALYSIS) ---
structural_twin(C1, C2, Index) :-
    evaluate_tension(C1, Index, result(Chi1, _)),
    evaluate_tension(C2, Index, result(Chi2, _)),
    abs(Chi1 - Chi2) < 0.05, % Isomorphic tolerance
    C1 \= C2.

is_prolog_file(F) :- file_name_extension(_, pl, F).

% ============================================================================
% DRL MODAL LOGIC - INDEXICAL VERSION v4.0
% ============================================================================
% This module implements context-indexed modal reasoning for Deferential Realism.
% All dependency chains, transformations, and counterfactuals are relative to
% WHO is analyzing/intervening and WHEN they're doing it.
%
% BREAKING CHANGES FROM v3.x:
% - dependency_chain/4 → dependency_chain/5 (added Context)
% - assess_scaffold_need/2 → assess_scaffold_need/3 (added Context)
% - simulate_cut/2 → simulate_cut/3 (added Context)
% - composite_type/3 → composite_type/4 (added Context)
% - All counterfactual reasoning now indexed
%
% KEY INSIGHT: "Load-bearing" depends on WHO is cutting the constraint.
% What's load-bearing for powerless individual may be non-essential for institution.
%
% Integration: Load after drl_core.pl (v4.0+)
% ============================================================================

:- module(drl_modal_logic, [
    % Stage 1: Composition Rules (INDEXED)
    composite_type/4,               % Added Context parameter
    composite_type/3,               % Backward compat
    composition_rule/3,
    detect_extraction_dominance/2,
    detect_necessity_inheritance/2,
    
    % Stage 2: Transformation Tracking (Context-aware)
    constraint_history/3,           % Added Context parameter
    constraint_history/2,           % Backward compat
    transformation_detected/5,      
    transformation_type/6,
    canonical_transformation/6,
    predict_transformation/3,
    
    % Stage 3: Counterfactual Reasoning (INDEXED)
    simulate_cut/3,                 % Added Context parameter
    simulate_cut/2,                 % Backward compat
    dependency_chain/5,             % Added Context parameter
    dependency_chain/4,             % Backward compat
    infer_structural_coupling/3,
    assess_scaffold_need/3,         % Added Context parameter
    assess_scaffold_need/2,         % Backward compat
    counterfactual_world/4,         % Added Context parameter
    counterfactual_world/3,         % Backward compat

    % Stage 4: Audit
    possibly/1,
    necessarily/1,
    is_noose/1,
    is_mountain/1,
    is_rope/1
]).

:- use_module(drl_audit_core).
:- use_module(drl_core).
:- use_module(constraint_indexing).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).

% Scaled for the Powerless
is_noose(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, individual_powerless, Chi),
    drl_audit_core:structural_signature(Chi, Data, snare).

% Scaled for the Observer
is_mountain(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, analytical, Chi),
    drl_audit_core:structural_signature(Chi, Data, mountain).

% Scaled for the Beneficiary
is_rope(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, institutional, Chi),
    drl_audit_core:structural_signature(Chi, Data, rope).

/* ================================================================
   MODAL LOGIC EXTENSION FOR DEFERENTIAL REALISM v4.0
   
   VERSION 4.0 CHANGES:
   - Full indexical relativity integration
   - All dependency analysis is context-relative
   - "Load-bearing" now indexed to WHO is cutting
   - Scaffold assessment indexed to WHO needs transition
   - Theorem 3 ("cutting load-bearing Snare requires Scaffold")
     now evaluates per perspective
   
   CRITICAL THEOREM 3 UPGRADE:
   OLD: "If Snare is load-bearing, cutting requires Scaffold"
   NEW: "If Snare is load-bearing FROM CONTEXT C, cutting from C requires Scaffold"
   
   Example: Property rights
   - FROM powerless context: load-bearing Mountain (shelter dependency)
   - FROM institutional context: non-essential Rope (coordination choice)
   - Institutional cutting WITHOUT considering powerless dependency = catastrophe
   
   This module implements three stages of indexed modal reasoning:
   1. Composition Rules - how constraints interact (context-aware)
   2. Transformation Tracking - temporal evolution (context-aware)
   3. Counterfactual Reasoning - intervention simulation (context-indexed)
   ================================================================ */

/* ================================================================
   STAGE 1: COMPOSITION RULES (INDEXED)
   Modal logic for how constraints interact and compose
   ================================================================ */

%% composite_type(+C1, +C2, +Context, -ResultType)
% PRIMARY API: Determines composite type FROM A SPECIFIC CONTEXT
composite_type(C1, C2, Context, Result) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C1, Context, T1),
    drl_core:dr_type(C2, Context, T2),
    composition_rule(T1, T2, Result).

%% composite_type(+C1, +C2, -ResultType)
% BACKWARD COMPAT: Uses analytical context
composite_type(C1, C2, Result) :-
    constraint_indexing:default_context(Ctx),
    composite_type(C1, C2, Ctx, Result).

%% composition_rule(+Type1, +Type2, -CompositeType)
% Formal modal composition rules from DR logic
% NOTE: These rules are NOT indexed - they're about logical structure
%       Context affects input types, not composition rules themselves

% Necessity Inheritance: ■ C₁ ∧ (C₁ → C₂) ⇒ ■ C₂
% If C1 is a Mountain and implies C2, then C2 is also a Mountain
composition_rule(mountain, _, mountain) :- !.
composition_rule(_, mountain, mountain) :- !.

% Extraction Dominance: ⊞C₁ ∧ ⊠ C₂ ∧ Embedded(C₂, C₁) ⇒ ⊠ (C₁ ∧ C₂)
% When a Snare is embedded in a Rope, the whole becomes extractive
composition_rule(rope, snare, snare) :- !.
composition_rule(snare, rope, snare) :- !.
composition_rule(tangled_rope, snare, snare) :- !.
composition_rule(snare, tangled_rope, snare) :- !.

% Snare Dominance: Multiple Nooses compound
composition_rule(snare, snare, snare) :- !.

% Rope Composition: ⊞C₁ ∧ ⊞C₂ ∧ Compatible(C₁, C₂) ⇒ ⊞(C₁ ∧ C₂)
% Compatible Ropes can be composed into compound Ropes
composition_rule(rope, rope, rope) :- !.

% Tangled interactions
composition_rule(tangled_rope, tangled_rope, tangled_rope) :- !.
composition_rule(rope, tangled_rope, tangled_rope) :- !.
composition_rule(tangled_rope, rope, tangled_rope) :- !.

% Piton contamination
composition_rule(piton, _, piton) :- !.
composition_rule(_, piton, piton) :- !.

% Unknown fallback
composition_rule(_, _, unknown).

%% detect_extraction_dominance(+Composite, -Evidence)
% Detects when a Rope is corrupted by an embedded Snare
% NOTE: Uses default analytical context for detection
detect_extraction_dominance(Composite, Evidence) :-
    narrative_ontology:affects_constraint(Composite, Component),
    drl_core:dr_type(Component, snare),
    narrative_ontology:constraint_metric(Component, extractiveness, X),
    X >= 0.66,
    Evidence = embedded_noose(Component, X).

%% detect_necessity_inheritance(+Source, -Derived)
% Detects when a Mountain constraint logically implies another constraint
% NOTE: Uses default analytical context for detection
detect_necessity_inheritance(Source, Derived) :-
    drl_core:dr_type(Source, mountain),
    narrative_ontology:affects_constraint(Source, Derived),
    narrative_ontology:constraint_metric(Source, suppression_requirement, E_source),
    E_source =< 0.05,
    % If the derived constraint should also be a Mountain
    narrative_ontology:constraint_metric(Derived, suppression_requirement, E_derived),
    E_derived =< 0.05.

/* ================================================================
   STAGE 2: TRANSFORMATION TRACKING (CONTEXT-AWARE)
   Temporal modal logic for constraint evolution
   ================================================================ */

%% constraint_history(+C, +Context, -Timeline)
% PRIMARY API: Collects constraint history FROM A SPECIFIC CONTEXT
% Same constraint may have different transformation patterns from different perspectives
constraint_history(C, Context, Timeline) :-
    constraint_indexing:valid_context(Context),
    findall(state(T, Type), 
            (narrative_ontology:measurement(_, C, _, T, _),
             dr_type_at(C, T, Context, Type)),
            TimelineUnsorted),
    sort(TimelineUnsorted, Timeline).

%% constraint_history(+C, -Timeline)
% BACKWARD COMPAT: Uses analytical context
constraint_history(C, Timeline) :-
    constraint_indexing:default_context(Ctx),
    constraint_history(C, Ctx, Timeline).

%% dr_type_at(+C, +Time, +Context, -Type)
% Determines constraint type at specific time FROM SPECIFIC CONTEXT
% NOTE: This is the key integration point - past metrics + current context
dr_type_at(C, Time, Context, Type) :-
    % Get metrics at this historical time
    (narrative_ontology:measurement(_, C, suppression_requirement, Time, E) -> true ; E = 0.5),
    (narrative_ontology:measurement(_, C, extractiveness, Time, BaseX) -> true ; BaseX = 0.5),
    
    % Apply current context's power scaling to historical metrics
    Context = context(agent_power(Power), _, _, _),
    constraint_indexing:power_modifier(Power, Modifier),
    EffectiveX is BaseX * Modifier,
    
    % Classify using effective extractiveness
    classify_at_time_indexed(C, E, EffectiveX, Context, Type).

%% classify_at_time_indexed(+C, +E, +EffectiveX, +Context, -Type)
% Classification logic using power-scaled extractiveness
% Recognizes: mountain, rope, snare, tangled_rope, piton, scaffold

% Scaffold (temporary support structure)
classify_at_time_indexed(C, _E, X, _Context, scaffold) :-
    narrative_ontology:entity(C, scaffold),
    v3_1_config:param(tangled_rope_extraction_ceil, Ceil),
    X =< Ceil, !.

% Mountain (appears unchangeable from this context)
classify_at_time_indexed(_C, E, _X, Context, mountain) :-
    v3_1_config:param(mountain_suppression_ceiling, Ceil),
    E =< Ceil,
    constraint_indexing:effective_immutability_for_context(Context, mountain), !.

% Snare (extractive + enforced + changeable)
classify_at_time_indexed(_C, E, X, Context, snare) :-
    v3_1_config:param(snare_extraction_floor, XFloor),
    v3_1_config:param(snare_suppression_floor, EFloor),
    X >= XFloor,
    E >= EFloor,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Tangled Rope (moderate extraction)
classify_at_time_indexed(_C, _E, X, Context, tangled_rope) :-
    v3_1_config:param(rope_extraction_ceiling, RopeX),
    v3_1_config:param(tangled_rope_extraction_ceil, TangledX),
    X > RopeX,
    X =< TangledX,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Piton (low extraction, high maintenance)
classify_at_time_indexed(_C, E, X, _Context, piton) :-
    v3_1_config:param(piton_extraction_ceiling, XCeil),
    X =< XCeil,
    E > XCeil, !.

% Rope (low extraction, changeable)
classify_at_time_indexed(_C, _E, X, Context, rope) :-
    v3_1_config:param(rope_extraction_ceiling, XCeil),
    X =< XCeil,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Unknown fallback
classify_at_time_indexed(_C, _E, _X, _Context, unknown).

%% transformation_detected(+C, +FromType, +ToType, -T1, -T2)
% Detects when constraint transformed from one type to another
% Uses actual measurement times (not iteration)
transformation_detected(C, From, To, T1, T2) :-
    constraint_history(C, Timeline),
    member(state(T1, From), Timeline),
    member(state(T2, To), Timeline),
    T2 > T1,
    From \= To,
    % Ensure no intermediate different type
    \+ (member(state(Tm, Mid), Timeline),
        Tm > T1, Tm < T2,
        Mid \= From, Mid \= To).

%% transformation_type(+C, +From, +To, +T1, +T2, -Label)
% Classifies the type of transformation with semantic label

transformation_type(C, rope, snare, T1, T2, capture) :-
    transformation_detected(C, rope, snare, T1, T2),
    check_capture_between(C, T1, T2).

transformation_type(C, rope, piton, T1, T2, obsolescence) :-
    transformation_detected(C, rope, piton, T1, T2),
    \+ check_capture_between(C, T1, T2).

transformation_type(C, scaffold, snare, T1, T2, calcification) :-
    transformation_detected(C, scaffold, snare, T1, T2),
    narrative_ontology:entity(C, scaffold),
    check_capture_between(C, T1, T2).

transformation_type(C, mountain, rope, T1, T2, discovery) :-
    transformation_detected(C, mountain, rope, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

transformation_type(C, mountain, snare, T1, T2, discovery) :-
    transformation_detected(C, mountain, snare, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

%% canonical_transformation(?C, ?From, ?To, -T1_earliest, -T2_latest, ?Label)
% Returns canonical (deduplicated) transformation
canonical_transformation(C, From, To, T1_earliest, T2_latest, Label) :-
    setof((T1, T2), transformation_type(C, From, To, T1, T2, Label), Pairs),
    findall(T1, member((T1, _), Pairs), T1s),
    findall(T2, member((_, T2), Pairs), T2s),
    min_list(T1s, T1_earliest),
    max_list(T2s, T2_latest).

%% check_capture_between(+C, +T1, +T2)
% Helper: detects if beneficiaries became concentrated
check_capture_between(C, T1, T2) :-
    narrative_ontology:measurement(_, C, extractiveness, T1, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    X2 > X1,
    X2 >= 0.66.

%% predict_transformation(+C, +CurrentType, -LikelyFutureType)
% Predicts likely future transformation based on trajectory
% NOTE: Uses analytical context for prediction
predict_transformation(C, rope, snare) :-
    findall(X, narrative_ontology:measurement(_, C, extractiveness, _, X), Xs),
    length(Xs, N), N >= 2,
    last(Xs, X_latest),
    X_latest > 0.5,
    X_latest < 0.66,
    Xs = [X_first|_],
    X_latest > X_first.

predict_transformation(C, rope, piton) :-
    findall(E, narrative_ontology:measurement(_, C, suppression_requirement, _, E), Es),
    length(Es, N), N >= 2,
    last(Es, E_latest),
    E_latest > 0.3,
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X < 0.35.

predict_transformation(C, tangled_rope, snare) :-
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X > 0.5.

/* ================================================================
   STAGE 3: COUNTERFACTUAL REASONING (INDEXED)
   Reasoning about possible worlds after interventions
   NOW INDEXED: "What happens if WE cut this?" depends on WHO "we" are
   ================================================================ */

%% simulate_cut(+Constraint, +Context, -Effects)
% PRIMARY API: Simulates cutting a constraint FROM A SPECIFIC CONTEXT
% CRITICAL: Same cut has different effects depending on who does it
%
% Example: Cutting property rights
%   FROM institutional context: moderate coordination disruption
%   FROM powerless context: catastrophic (removes only shelter access)
simulate_cut(Constraint, Context, Effects) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    (Type = snare ; Type = piton ; Type = rope),  % Only cut these types
    findall(effect(Target, Impact, Reason),
            dependency_chain(Constraint, Target, Impact, Reason, Context),
            Effects).

%% simulate_cut(+Constraint, -Effects)
% BACKWARD COMPAT: Uses analytical context
simulate_cut(Constraint, Effects) :-
    constraint_indexing:default_context(Ctx),
    simulate_cut(Constraint, Ctx, Effects).

%% dependency_chain(+Source, -Target, -Impact, -Reason, +Context)
% PRIMARY API: Discovers dependencies FROM A SPECIFIC CONTEXT
% CRITICAL UPGRADE: "Depends on" is now relative to WHO would be affected
%
% What's load-bearing from powerless context may be non-essential from institutional
dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 1. Explicit dependencies (declared in data)
    narrative_ontology:affects_constraint(Source, Target),
    estimate_impact_indexed(Source, Target, Context, Impact, Reason).

dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 2. Inferred structural coupling
    infer_structural_coupling(Source, Target, Strength),
    Strength > 0.85,
    
    % But assess impact FROM THIS CONTEXT
    (   context_depends_critically(Target, Source, Context)
    ->  Impact = catastrophic,
        Reason = inferred_load_bearing_coupling
    ;   Impact = moderate,
        Reason = inferred_weak_coupling
    ).

%% dependency_chain(+Source, -Target, -Impact, -Reason)
% BACKWARD COMPAT: Uses analytical context
dependency_chain(Source, Target, Impact, Reason) :-
    constraint_indexing:default_context(Ctx),
    dependency_chain(Source, Target, Impact, Reason, Ctx).

%% context_depends_critically(+Target, +Source, +Context)
% NEW: Determines if Target critically depends on Source FROM CONTEXT
% Used to detect load-bearing relationships per perspective
context_depends_critically(Target, Source, Context) :-
    % Target appears as Mountain from this context
    drl_core:dr_type(Target, Context, mountain),
    
    % Source provides the only perceived stability
    drl_core:dr_type(Source, Context, SourceType),
    member(SourceType, [rope, snare]),
    
    % Check if Target's stability requires Source
    narrative_ontology:affects_constraint(Source, Target).

%% estimate_impact_indexed(+Source, +Target, +Context, -Impact, -Reason)
% Estimates impact of cutting Source on Target FROM SPECIFIC CONTEXT
% CRITICAL: Same cut has different impacts depending on who's cutting

estimate_impact_indexed(Source, Target, Context, catastrophic, load_bearing) :-
    % Source is load-bearing FROM THIS CONTEXT
    drl_core:dr_type(Source, Context, snare),
    narrative_ontology:constraint_metric(Source, extractiveness, X),
    v3_1_config:param(noose_load_bearing_threshold, T),
    X > T,
    
    % Target depends on it FROM THIS CONTEXT
    drl_core:dr_type(Target, Context, mountain),
    !.

estimate_impact_indexed(Source, Target, Context, beneficial, removes_extraction) :-
    % Source is extractive, Target is functional
    drl_core:dr_type(Source, Context, snare),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(Source, Target, Context, moderate, disrupts_coordination) :-
    % Both are coordination mechanisms
    drl_core:dr_type(Source, Context, rope),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(_, _, _, negligible, no_dependency) :- !.

%% infer_structural_coupling(+C1, +C2, -Strength)
% Discovers hidden dependencies via temporal correlation
% NOTE: This is NOT indexed - coupling is structural fact
infer_structural_coupling(C1, C2, Strength) :-
    C1 \= C2,
    findall(G1, dr_gradient_at(C1, _, G1), Gs1),
    findall(G2, dr_gradient_at(C2, _, G2), Gs2),
    length(Gs1, L), L > 1, length(Gs2, L),
    calculate_coupling_strength(Gs1, Gs2, Strength).

dr_gradient_at(C, T, Grad) :-
    narrative_ontology:measurement(_, C, extractiveness, T, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    T2 > T, !,
    Grad is X2 - X1.

calculate_coupling_strength([], [], 1.0).
calculate_coupling_strength([H1|T1], [H2|T2], S) :-
    ( (H1 > 0, H2 > 0) ; (H1 < 0, H2 < 0) ; (H1 == 0, H2 == 0) ),
    calculate_coupling_strength(T1, T2, SubS),
    S is 0.2 + SubS.
calculate_coupling_strength([_|T1], [_|T2], S) :-
    calculate_coupling_strength(T1, T2, S).

%% assess_scaffold_need(+Constraint, +Context, -Assessment)
% PRIMARY API: Determines if cutting requires Scaffold FROM SPECIFIC CONTEXT
% THEOREM 3 INDEXED: "Need scaffold" depends on WHO is cutting
%
% Critical case: Institutional cutting powerless Mountain
%   FROM institutional context: no_scaffold_needed (just coordination)
%   FROM powerless context: scaffold_required (removes survival support)
%   SYSTEM MUST EVALUATE BOTH CONTEXTS before allowing cut
assess_scaffold_need(Constraint, Context, Assessment) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    member(Type, [snare, piton, rope]),
    
    simulate_cut(Constraint, Context, Effects),
    
    (   member(effect(_, catastrophic, load_bearing), Effects)
    ->  (   narrative_ontology:entity(Scaffold, scaffold),
            Scaffold \= Constraint
        ->  Assessment = scaffold_present
        ;   Assessment = scaffold_required
        )
    ;   Assessment = no_scaffold_needed
    ).

%% assess_scaffold_need(+Constraint, -Assessment)
% BACKWARD COMPAT: Uses analytical context
assess_scaffold_need(Constraint, Assessment) :-
    constraint_indexing:default_context(Ctx),
    assess_scaffold_need(Constraint, Ctx, Assessment).

%% counterfactual_world(+Intervention, +CurrentWorld, +Context, -FutureWorld)
% PRIMARY API: Models state after intervention FROM SPECIFIC CONTEXT
counterfactual_world(cut(C), current, Context, after_cut) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, Type),
    format('In world after cutting ~w (~w from ~w):~n', [C, Type, Context]),
    simulate_cut(C, Context, Effects),
    forall(member(effect(Target, Impact, Reason), Effects),
           format('  - ~w: ~w (~w)~n', [Target, Impact, Reason])).

counterfactual_world(add_scaffold(S, For), current, Context, with_scaffold) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(For, Context, snare),
    format('In world with scaffold ~w for ~w (from ~w):~n', [S, For, Context]),
    format('  - Temporary support for transition~n'),
    format('  - Allows safe removal of ~w~n', [For]).

%% counterfactual_world(+Intervention, +CurrentWorld, -FutureWorld)
% BACKWARD COMPAT: Uses analytical context
counterfactual_world(Intervention, Current, Future) :-
    constraint_indexing:default_context(Ctx),
    counterfactual_world(Intervention, Current, Ctx, Future).

/* ================================================================
   CROSS-CONTEXT DEPENDENCY ANALYSIS (NEW)
   Critical for detecting "institutional Mountain collapse"
   ================================================================ */

%% check_all_contexts(+Constraint, -MultiContextReport)
% NEW: Evaluates cutting a constraint across multiple standard contexts
% CRITICAL FOR SAFETY: Before cutting, check impact on ALL perspectives
%
% Example usage:
%   check_all_contexts(property_rights_2025, Report)
%   → Shows if cut is safe for institution but catastrophic for powerless
check_all_contexts(Constraint, Report) :-
    findall(
        context_impact(Context, Type, ScaffoldNeed, Effects),
        (   standard_context(Context),
            drl_core:dr_type(Constraint, Context, Type),
            assess_scaffold_need(Constraint, Context, ScaffoldNeed),
            simulate_cut(Constraint, Context, Effects)
        ),
        Impacts
    ),
    Report = multi_context_analysis(Constraint, Impacts).

% Standard contexts for cross-perspective analysis
standard_context(context(agent_power(individual_powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

% ============================================================================
% NEW: INDEXICAL PERSPECTIVE AUDIT
% ============================================================================
% Checks if two agents experience a structural conflict (Risk Gap)
% Implements Section IV-B
detect_perspectival_risk(ConstraintID, Agent1, Agent2, RiskLabel) :-
    % 1. Get the base extraction score for the constraint
    constraint_data(ConstraintID, Data),
    member(base_extractiveness(X_base), Data),
    
    % 2. Calculate what each agent "sees" based on their power index
    % Uses the pi scaling function from drl_audit_core
    agent_index(Agent1, context(Power1, _, _, _)),
    agent_index(Agent2, context(Power2, _, _, _)),
    
    drl_audit_core:effective_extraction(X_base, Power1, Chi1),
    drl_audit_core:effective_extraction(X_base, Power2, Chi2),
    
    % 3. Determine the structural type for each agent
    drl_audit_core:structural_signature(Chi1, Data, Type1),
    drl_audit_core:structural_signature(Chi2, Data, Type2),
    
    % 4. Match against the Risk Table
    drl_audit_core:omega_risk(Type1, Type2, RiskLabel, _).

% possibly(C) is true if the constraint is a Rope (changeable/contingent)
possibly(C) :- 
    constraint_indexing:default_context(Ctx),
    drl_core:dr_type(C, Ctx, rope).

% necessarily(C) is true if the constraint is a Mountain (fixed/required)
necessarily(C) :- 
    constraint_indexing:default_context(Ctx),
    drl_core:dr_type(C, Ctx, mountain).

/* ================================================================
   UTILITY PREDICATES
   ================================================================ */

%% last(+List, -Last)
% Gets the last element of a list
last([X], X) :- !.
last([_|Xs], Last) :- last(Xs, Last).

/* ================================================================
   VERSION & MIGRATION INFO
   ================================================================ */

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: Full indexical relativity integration
  - NEW: dependency_chain/5 (added Context)
  - NEW: assess_scaffold_need/3 (added Context)
  - NEW: simulate_cut/3 (added Context)
  - NEW: context_depends_critically/3
  - NEW: estimate_impact_indexed/5
  - NEW: check_all_contexts/2 (multi-perspective safety check)
  - CHANGED: All dependency analysis is context-relative
  - MAINTAIN: Backward compatibility via /4, /3, /2 versions

v3.x:
  - Non-indexed modal logic
  - Single "God's eye view" dependency chains

MIGRATION GUIDE v3.x → v4.0:
  Old: dependency_chain(source, target, impact, reason)
  New: dependency_chain(source, target, impact, reason, context)
  
  Old: assess_scaffold_need(snare, assessment)
  New: assess_scaffold_need(snare, context, assessment)
  
  CRITICAL NEW REQUIREMENT:
  Before cutting any constraint, MUST evaluate:
    check_all_contexts(constraint, Report)
  to detect if cut is safe from one context but catastrophic from another.
  
  This prevents "institutional Mountain collapse" - where institution
  cuts what they see as Rope, unknowingly destroying powerless Mountain.
*/
:- module(intent_engine, [
	classify_interval/3,
	analyze_intent/1
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection). % Math Provider
:- use_module(pattern_analysis).        % State Provider

/* ================================================================
   1. MAIN ENTRY
   ================================================================ */

classify_interval(IntervalID, Pattern, Confidence) :-
    % Ensure the analysis service has populated the dynamic facts
    pattern_analysis:analyze_interval(IntervalID),
    pattern_analysis:interval_preliminary_pattern(IntervalID, Prelim),
    pattern_analysis:interval_system_gradient(IntervalID, coercion, Gsys),
    pattern_analysis:interval_data_completeness(IntervalID, DataScore),
    
    collect_intent_evidence(IntervalID, Evidence),
    (   structural_coercive_intent(IntervalID, Prelim, Gsys, Evidence)
    ->  Pattern = structural_coercive_intent,
        refine_confidence(Evidence, DataScore, Confidence)
    ;   classify_non_intent(Prelim, Pattern),
        fallback_confidence(DataScore, Confidence)
    ).

/* ================================================================
   2. STRUCTURAL COERCIVE INTENT (4 CONDITIONS)
   ================================================================ */

structural_coercive_intent(_IntervalID, Prelim, Gsys, Evidence) :-
    % Condition 1: Strong Positive Gradient
    Prelim = increasing_coercion,
    v3_1_config:param(system_gradient_strong_threshold, StrongThr),
    Gsys > StrongThr,

    % Condition 2: Alternatives Rejected
    member(viable(_System, Alt), Evidence),
    member(rejected(_System2, Alt), Evidence),

    % Condition 3: Beneficiary Asymmetry
    findall((Class, Delta), member(power(Class, Delta), Evidence), PCs),
    PCs \= [],
    max_by_value((MainBeneficiary, DeltaMain), PCs),
    v3_1_config:param(beneficiary_gain_min, GainMin),
    DeltaMain >= GainMin,

    % Condition 4: Suppression/Resistance Alignment
    v3_1_config:param(structural_suppression_min, SMin),
    v3_1_config:param(structural_resistance_min, RMin),
    findall(ValS, member(supp(MainBeneficiary, structural, ValS), Evidence), Ss),
    findall(ValR, member(resist(MainBeneficiary, structural, ValR), Evidence), Rs),
    Ss \= [], Rs \= [],
    average_list(Ss, AvgS), AvgS >= SMin,
    average_list(Rs, AvgR), AvgR >= RMin.

/* ================================================================
   3. HELPERS & UTILS
   ================================================================ */

collect_intent_evidence(IntervalID, Evidence) :-
    findall(viable(S,A), intent_viable_alternative(IntervalID, S, A), VAs),
    findall(rejected(S,A), intent_alternative_rejected(IntervalID, S, A), RAs),
    findall(power(C,D), intent_power_change(IntervalID, C, D), PCs),
    findall(supp(C,L,V), intent_suppression_level(IntervalID, C, L, V), Supps),
    findall(resist(C,L,V), intent_resistance_level(IntervalID, C, L, V), Ress),
    append([VAs, RAs, PCs, Supps, Ress], Evidence).

classify_non_intent(Prelim, Pattern) :-
    (Prelim = increasing_coercion -> Pattern = increasing_coercion 
    ; Prelim = decreasing_coercion -> Pattern = decreasing_coercion 
    ; Pattern = stable).

refine_confidence(Evidence, DataScore, Conf) :-
    length(Evidence, NEv),
    v3_1_config:param(data_high_threshold, DH),
    (DataScore >= DH, NEv >= 5 -> Conf = high ; Conf = medium).

fallback_confidence(DataScore, Conf) :-
    v3_1_config:param(data_high_threshold, DH),
    (DataScore >= DH -> Conf = high ; Conf = low).

% Local helper predicates (not exported)
% FIXED: Renamed to avoid conflicts with library predicates

% Safe average that handles empty lists
average_list([], 0).
average_list(List, Avg) :- 
    List \= [],
    sum_list(List, Sum), 
    length(List, N), 
    Avg is Sum / N.

% Find tuple with maximum second element
% FIXED: Renamed from max_member to avoid conflict with library(lists)
max_by_value((C, D), List) :- 
    member((C, D), List), 
    \+ (member((_, D2), List), D2 > D).

%% analyze_intent(+IntervalID)
%  Harness wrapper to satisfy test_harness.pl.
analyze_intent(IntervalID) :-
    (   classify_interval(IntervalID, Pattern, Confidence)
    ->  format('  [INTENT] Result: ~w (Confidence: ~w)~n', [Pattern, Confidence])
    ;   format('  [INTENT] Analysis failed for ~w~n', [IntervalID])
    ).
:- module(isomorphism_engine, [
    find_isomorphism/3,
    cluster_by_signature/2,
    generate_cross_domain_index/1,
    find_high_risk_isomorphism/3
]).

:- use_module(structural_signatures).
:- use_module(narrative_ontology).
:- use_module(domain_priors).
:- use_module(v3_1_config).

%% find_isomorphism(+ConstraintA, -ConstraintB, -SimilarityScore)
%  Calculates the structural similarity between two constraints based on 
%  their 7-point signature profile.
find_isomorphism(C1, C2, Score) :-
    C1 \= C2,
    structural_signatures:get_constraint_profile(C1, Profile1),
    structural_signatures:get_constraint_profile(C2, Profile2),
    calculate_profile_distance(Profile1, Profile2, Distance),
    Score is 1.0 - Distance,
    v3_1_config:param(isomorphism_threshold, T),
    Score >= T.

%% calculate_profile_distance(+P1, +P2, -Distance)
%  Computes normalized Euclidean distance across the metric components 
%  of the structural profiles.
calculate_profile_distance(
    profile(A1, S1, R1, B1, Alt1, _, _),
    profile(A2, S2, R2, B2, Alt2, _, _),
    Distance
) :-
    % Normalized Beneficiary Delta (capped at 5 for scale)
    BN1 is min(B1, 5) / 5,
    BN2 is min(B2, 5) / 5,
    % Alternative parity (0 if same, 1 if different)
    (Alt1 == Alt2 -> AltD = 0 ; AltD = 1),
    
    D2 is (A1-A2)^2 + (S1-S2)^2 + (R1-R2)^2 + (BN1-BN2)^2 + (AltD * 0.5)^2,
    Distance is sqrt(D2) / 2.5. % Normalized to [0,1]

%% cluster_by_signature(+Signature, -Cluster)
%  Finds all constraints sharing a specific structural signature.
cluster_by_signature(Sig, Cluster) :-
    findall(C, structural_signatures:constraint_signature(C, Sig), Cluster).

%% generate_cross_domain_index(-Index)
%  The "Pattern Search" entry point.
generate_cross_domain_index(Index) :-
    findall(iso(C1, C2, S), (
        narrative_ontology:constraint_claim(C1, _),
        domain_priors:category_of(C1, Cat1),
        find_isomorphism(C1, C2, S),
        domain_priors:category_of(C2, Cat2),
        Cat1 \= Cat2 % Only return cross-domain matches
	    ), Index).

%% find_high_risk_isomorphism(-C1, -C2, -Score)
%  Filters isomorphisms specifically for "Snare" or "Tangled Rope" clusters.
find_high_risk_isomorphism(C1, C2, Score) :-
    find_isomorphism(C1, C2, Score),
    is_high_risk(C1),
    is_high_risk(C2).

%% is_high_risk(+Constraint)
%  Checks if a constraint is classified as a Snare or Tangled Rope 
%  from the default analytical perspective.
is_high_risk(C) :-
    drl_core:dr_type(C, Type),
    member(Type, [snare, tangled_rope]).
:- module(isomorphism_report, [
    generate_isomorphism_report/0,
    report_isomorphism_to_file/1
]).

:- use_module(isomorphism_engine).
:- use_module(narrative_ontology).
:- use_module(domain_priors).

%% generate_isomorphism_report
%  Scans the current Knowledge Base and prints a Markdown-formatted 
%  table of structural isomorphisms across different domains.
generate_isomorphism_report :-
    format('~n# CROSS-DOMAIN ISOMORPHISM INDEX~n'),
    format('| Domain A (Technical/Formal) | Domain B (Social/Institutional) | Similarity | Structural Logic |~n'),
    format('| :--- | :--- | :--- | :--- |~n'),
    
    % Generate the index using the engine
    isomorphism_engine:generate_cross_domain_index(Index),
    
    % Filter and sort by score for the report
    sort(3, @>=, Index, SortedIndex),
    
    forall(member(iso(C1, C2, Score), SortedIndex),
           (   % Only report if C1 is "technical" and C2 is "social" to highlight the thesis
               domain_priors:category_of(C1, Cat1),
               domain_priors:category_of(C2, Cat2),
               (is_technical(Cat1), is_social(Cat2))
           ->  get_logic_explanation(C1, C2, Explanation),
               format('| ~w | ~w | ~2f | ~w |~n', [C1, C2, Score, Explanation])
           ;   true
           )).

%% is_technical(+Category)
%  Helper to identify formal/technical domains[cite: 103, 104, 115].
is_technical(physical_natural).
is_technical(formal_logic).
is_technical(extractive_market). % Often technical in your datasets

%% is_social(+Category)
%  Helper to identify social/historical domains[cite: 106, 107, 128].
is_social(narrative_history).
is_social(statutory_formal).
is_social(election_cycle).

%% get_logic_explanation(+C1, +C2, -Explanation)
%  Summarizes why the two constraints are twins[cite: 457, 458, 459].
get_logic_explanation(C1, C2, Explanation) :-
    structural_signatures:constraint_signature(C1, Sig),
    structural_signatures:explain_signature(C1, Sig, BaseExpl),
    % Truncate or simplify the explanation for table format
    format(atom(Explanation), 'Both function as ~w.', [Sig]).

%% generate_high_risk_index
%  Generates a Markdown report limited to high-risk structural twins.
generate_high_risk_index :-
    format('~n# HIGH-RISK STRUCTURAL ISOMORPHISM AUDIT~n'),
    format('| Risk Cluster (Formal) | Risk Cluster (Social) | Similarity | Risk Type |~n'),
    format('| :--- | :--- | :--- | :--- |~n'),
    
    findall(iso(C1, C2, S), (
        domain_priors:category_of(C1, Cat1),
        find_high_risk_isomorphism(C1, C2, S),
        domain_priors:category_of(C2, Cat2),
        Cat1 \= Cat2,
        is_technical(Cat1) % Source is a technical system
    ), HighRiskIndex),
    
    sort(3, @>=, HighRiskIndex, Sorted),
    
    forall(member(iso(C1, C2, Score), Sorted),
           (   drl_core:dr_type(C1, Type),
               format('| ~w | ~w | ~2f | ~w |~n', [C1, C2, Score, Type])
           )).
:- module(narrative_ontology, [
    % Core ontology
    entity/2,
    interval/3,
    event/4,

    % CE v2.0 constraint layer
    constraint_claim/2,
    recommendation/2,
    affects_constraint/2,
    veto_actor/1,
    veto_exposed/2,
    constraint_metric/3,
    omega_variable/3,

    % Optional measurement layer (v3.1 coercion metrics)
    measurement/5,

    % Optional intent evidence layer
    intent_viable_alternative/3,
    intent_alternative_rejected/3,
    intent_beneficiary_class/2,
    intent_power_change/3,
    intent_suppression_level/4,
    intent_resistance_level/4,
    intent_norm_strength/3,

    % Tangled rope category (Added January 2026)
    constraint_type/1,
    constraint_type_name/2,
    constraint_type_threshold/4,
    is_tangled_rope/1,
    has_coordination_function/1,
    has_asymmetric_extraction/1,

    % Validation entry point
    validate_ontology/0
]).

/* ============================================================
   1. MULTIFILE & DYNAMIC DECLARATIONS
   ============================================================ */

:- multifile
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5,
    intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3,
    constraint_beneficiary/2, constraint_victim/2.

:- dynamic
    attribute/3, has_mandatrophy_declaration/1,
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5,
    intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3,
    constraint_beneficiary/2, constraint_victim/2.

/* ============================================================
   2. VALIDATION LOGIC
   ============================================================ */
%% attribute(+Subject, +Key, +Value)
%  Generic metadata getter/setter used for indexical resolution.
%  This links the metadata check in is_indexical_resolution_declared/1 
%  to the actual stored metrics.
attribute(S, K, V) :- 
    narrative_ontology:constraint_metric(S, K, V).

%% has_mandatrophy_declaration(+Constraint)
%  A manual override flag used by check_indexical_relativity/1.
%  If a constraint is explicitly marked as 'mandatrophy' in its metadata,
%  it passes the indexical relativity gate.
has_mandatrophy_declaration(C) :- 
    attribute(C, lifecycle, mandatrophy).

%% validate_ontology
%  Master entry point for checking Knowledge Base integrity.
validate_ontology :-
    (   validate_entities,
        validate_intervals,
        validate_events,
        validate_constraint_claims,
        validate_constraint_metrics,
        validate_measurements,
        validate_omegas,
        validate_intent
    ).

validate_entities :-
    forall(entity(ID,Type),
        ( atom(ID),
          member(Type, [individual_powerless, individual_powerful, 
                        institutional, analytical, class])
        -> true
        ;  format('ERROR: Invalid entity(~w,~w)~n',[ID,Type]), fail
        )).

validate_intervals :-
    forall(interval(ID,Start,End),
        ( atom(ID), integer(Start), integer(End), Start =< End
        -> true
        ;  format('ERROR: Invalid interval(~w,~w,~w)~n',[ID,Start,End]), fail
        )).

validate_events :-
    forall(event(ID,Time,Actor,Type),
        ( atom(ID), integer(Time), (entity(Actor,_) ; atom(Actor)), atom(Type)
        -> true
        ;  format('ERROR: Invalid event(~w,~w,~w,~w)~n',[ID,Time,Actor,Type]), fail
        )).

%% validate_constraint_claims
%  Updated for v3.2.4 schema expansion.
%  Added tangled_rope category (January 2026) based on empirical validation of 467 constraints.
validate_constraint_claims :-
    forall(constraint_claim(Name, Type),
        ( member(Type, [mountain, rope, tangled_rope, snare, piton])
        -> true
        ;  format('ERROR: Ontological Violation in ~w: "~w" is not a valid constraint type.~n', [Name, Type]),
           fail
        )).

validate_constraint_metrics :-
    forall(constraint_metric(Name,Metric,Val),
        ( (constraint_claim(Name,_) ; true),
          atom(Metric),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid constraint_metric(~w,~w,~w)~n',[Name,Metric,Val]), fail
        )).

validate_measurements :-
    forall(measurement(ID,Target,Metric,Time,Val),
        ( atom(ID),
          (entity(Target,_) ; interval(Target,_,_)),
          (atom(Metric) ; compound(Metric)),
          integer(Time),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid measurement(~w,~w,~w,~w,~w)~n',
                  [ID,Target,Metric,Time,Val]), fail
        )).

validate_omegas :-
    forall(omega_variable(ID, Type, Desc),
        ( atom(ID),
          member(Type, [empirical, conceptual, preference]),
          (atom(Desc) ; string(Desc))
        -> true
        ;  format('ERROR: Invalid omega_variable(~w,~w,~w)~n',[ID,Type,Desc]), fail
        )).

validate_intent :-
    forall(intent_viable_alternative(I,S,A),
        ( (interval(I,_,_) ; atom(I)), (entity(S,_) ; atom(S)), atom(A)
        -> true
        ;  format('ERROR: Invalid intent_viable_alternative(~w,~w,~w)~n',[I,S,A]), fail
        )).

/* ==========================================================================
   TANGLED ROPE CATEGORY - EMPIRICAL VALIDATION (Added January 2026)
   ========================================================================== */

/**
 * TANGLED ROPE CATEGORY - EMPIRICAL VALIDATION
 *
 * Added based on corpus analysis of 467 constraints (January 2026):
 * - 168 constraints (36%) show hybrid coordination/extraction pattern
 * - Cannot be explained by indexing alone (structural hybridity is real)
 * - Pattern mining confirmed empirical necessity
 *
 * Examples from corpus:
 * - carbon_credit_markets (0.55 extraction, 0.60 suppression)
 * - academic_tenure_system (0.75 extraction, 0.60 suppression)
 * - platform_network_effects (coordination + extraction)
 *
 * Key distinction from pure types:
 * - NOT pure rope (extraction too high, >0.40)
 * - NOT pure snare (has genuine coordination function)
 * - Requires surgical reform: preserve coordination, cut extraction
 */

%% constraint_type(?Type)
%  Valid constraint types in the framework.
constraint_type(mountain).
constraint_type(rope).
constraint_type(tangled_rope).  % Validated by corpus analysis (168/467 constraints, 36%)
constraint_type(snare).
constraint_type(piton).

%% constraint_type_name(?Type, ?Name)
%  Human-readable names for constraint types.
constraint_type_name(mountain, 'Mountain (Natural Constraint)').
constraint_type_name(rope, 'Rope (Pure Coordination)').
constraint_type_name(tangled_rope, 'Tangled Rope (Hybrid Coordination/Extraction)').
constraint_type_name(snare, 'Snare (Pure Extraction)').
constraint_type_name(piton, 'Piton (Degraded Coordination)').


%% constraint_type_threshold(?Type, ?Metric, ?Min, ?Max)
%  Quantification thresholds for constraint type classification.
constraint_type_threshold(mountain, extractiveness, 0.0, 0.20).
constraint_type_threshold(rope, extractiveness, 0.0, 0.40).
constraint_type_threshold(tangled_rope, extractiveness, 0.40, 0.90).
constraint_type_threshold(tangled_rope, suppression, 0.50, 1.00).
constraint_type_threshold(snare, extractiveness, 0.65, 1.00).

%% is_tangled_rope(+ConstraintID)
%  Tangled rope signature detection.
%  Must have BOTH coordination function AND asymmetric extraction.
is_tangled_rope(ConstraintID) :-
    domain_priors:base_extractiveness(ConstraintID, E),
    E >= 0.40, E =< 0.90,
    domain_priors:suppression_score(ConstraintID, S),
    S >= 0.50,
    domain_priors:requires_active_enforcement(ConstraintID),
    % Must have both coordination function AND extraction
    has_coordination_function(ConstraintID),
    has_asymmetric_extraction(ConstraintID).

%% has_coordination_function(+ConstraintID)
%  Check if constraint solves a collective action problem.
%  Evidence: Has multiple beneficiaries or provides network effects.
%  Note: constraint_beneficiary/2 is defined in individual test files.
has_coordination_function(ConstraintID) :-
    constraint_beneficiary(ConstraintID, _),
    !.

%% has_asymmetric_extraction(+ConstraintID)
%  Check for asymmetric beneficiary distribution.
%  Evidence: Has victims or concentrated benefits.
%  Note: constraint_victim/2 is defined in individual test files.
has_asymmetric_extraction(ConstraintID) :-
    constraint_victim(ConstraintID, _),
    !.

/* ==========================================================================
   INDEXICAL GATE (v3.1)
   ========================================================================== */

% Indexical Gate: Flags Mountains that are actually Shadow Nooses.
check_indexical_relativity(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    domain_priors:base_extractiveness(ID, E),
    E > 0.7,
    % Require a manual "Mandatrophy Acknowledgement" in the file metadata
    \+ has_mandatrophy_declaration(ID).

% Every domain must be indexed to power-perspectives (mountain/rope/tangled_rope/snare).
% Note: With tangled_rope addition, we now have 4 categories but validation remains
% focused on ensuring at least the traditional 3-pillar coverage is maintained.
validate_indexical_completeness(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    constraint_indexing:constraint_classification(ID, rope, _),
    constraint_indexing:constraint_classification(ID, snare, _),
    !.
validate_indexical_completeness(ID) :-
    format('ERROR: Perspectival Gap in ~w. Missing 3-pillar coverage.~n', [ID]),
    fail.

/* ==========================================================================
   MANDATROPHY RECONCILIATION (v3.1)
   ========================================================================== */

% is_mandatrophy_resolved/1: Explicitly standardizes the 2 residual Omegas.
is_mandatrophy_resolved(gale_shapley).        % The Algorithm is the Mandate.
is_mandatrophy_resolved(planetary_boundaries). % The Biological Limit is the Mandate.

% detect_omega/2: Identifies logical friction points.
% This rule is updated to exempt "Hardened Mandatrophy."
detect_omega(Name, mandatrophy) :-
    constraint_indexing:constraint_classification(Name, mountain, _),
    domain_priors:base_extractiveness(Name, E),
    E > 0.7,
    % The Paradox: A Mountain (Fact) behaves like a Snare (Trap).
    % If the domain is recognized as Mandatrophic, it is no longer an Omega.
    \+ is_mandatrophy_resolved(Name).

% System Insight: Logic for the Parsing Suite
count_unresolved_omegas(Count) :-
    aggregate_all(count, detect_omega(_, _), Count).

% Mandatrophy Detector: Flags Mountains that function as Traps.
detect_mandatrophy_omega(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    domain_priors:base_extractiveness(ID, E),
    E > 0.7,
    % Check for the explicit resolution marker in the file
    \+ is_indexical_resolution_declared(ID).

is_indexical_resolution_declared(ID) :-
    % Looks for the standardized resolution hook in the metadata
    attribute(ID, indexical_resolution, resolved).
:- module(pattern_analysis, [
    analyze_interval/1,
    interval_system_gradient/3,
    interval_data_completeness/2,
    interval_preliminary_pattern/2
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).

:- dynamic interval_system_gradient/3.
:- dynamic interval_data_completeness/2.
:- dynamic interval_preliminary_pattern/2.

analyze_interval(IntervalID) :-
    interval(IntervalID, T0, _),
    retractall(interval_system_gradient(IntervalID, _, _)),
    retractall(interval_data_completeness(IntervalID, _)),
    retractall(interval_preliminary_pattern(IntervalID, _)),
    
    % Explicitly call the math module to solve the warning
    v3_1_coercion_projection:system_gradient(IntervalID, T0, Gsys),
    assertz(interval_system_gradient(IntervalID, coercion, Gsys)),
    
    compute_completeness(IntervalID, Score),
    assertz(interval_data_completeness(IntervalID, Score)),
    
    param(system_gradient_threshold, Thr),
    (Gsys > Thr -> P = increasing_coercion ; Gsys < -Thr -> P = decreasing_coercion ; P = stable),
    assertz(interval_preliminary_pattern(IntervalID, P)).

compute_completeness(ID, Score) :-
    interval(ID, T0, Tn),
    % Explicit call to solve warning
    findall((L, T), (level(L), member(T, [T0, Tn]), v3_1_coercion_projection:coercion_vector(L, T, _)), Vectors),
    length(Vectors, N),
    Score is N / 8.

:- module(report_generator, [
    generate_full_report/1,
    generate_indexed_report/3,
    generate_omegas_from_gaps/1,
    omega_from_gap/5,
    cross_domain_audit/0,
    forensic_audit_false_mountains/0,
    generate_omega_resolution_scenarios/0,
    generate_omega_triage/0
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(intent_engine, except([classify_interval/3])).
:- use_module(v3_1_coercion_projection).
:- use_module(pattern_analysis).
:- use_module(constraint_bridge).
:- use_module(drl_core).
:- use_module(uke_dr_bridge).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(isomorphism_engine). % Required for isomorphism audit
:- use_module(domain_priors).      % Required for forensic audit
:- use_module(utils).              % Safe helpers for defensive programming

% Suppress warning - we intentionally override intent_engine:classify_interval/3
:- discontiguous classify_interval/3.

/* ============================================================================
   TYPE DESCRIPTIONS & STRATEGIES (Updated January 2026 for Tangled Rope)
   ============================================================================ */

%% type_description(?Type, ?Description)
%  Human-readable descriptions for constraint types.
type_description(mountain,
    'Natural constraint - unchangeable given current understanding of reality').
type_description(rope,
    'Pure coordination - low extraction, solves collective action problems').
type_description(tangled_rope,
    'Hybrid coordination/extraction - provides genuine coordination while extracting asymmetrically').
type_description(snare,
    'Pure extraction - minimal coordination benefit, high asymmetric extraction').
type_description(piton,
    'Maintained constraint - low extraction but high suppression costs, should be cut but isn''t').

%% type_strategy(?Type, ?Strategy)
%  Strategic recommendations for each constraint type.
type_strategy(mountain,
    'Accept - Work within natural constraints, adapt strategies accordingly').
type_strategy(rope,
    'Maintain - Preserve coordination mechanisms, ensure fair access and participation').
type_strategy(tangled_rope,
    'Reform carefully - Preserve coordination core while cutting extractive elements. Requires surgical separation.').
type_strategy(snare,
    'Cut - Remove extractive constraints, replace with fair alternatives if coordination needed').
type_strategy(piton,
    'Bypass or eliminate - High maintenance cost without value, find alternatives').

%% type_color(?Type, ?Color)
%  Color coding for visualization and reports.
type_color(mountain, blue).
type_color(rope, green).
type_color(tangled_rope, orange).  % Orange for hybrid nature
type_color(snare, red).
type_color(piton, gray).

/* ============================================================================
   1. EXECUTIVE SUMMARY (MAIN ENTRY)
   ============================================================================ */

generate_full_report(IntervalID) :-
    interval(IntervalID, T_start, Tn),
    classify_interval(IntervalID, Pattern, Conf),
    
    format('~n~n====================================================~n'),
    format('   DEFERENTIAL REALISM (DR) EXECUTIVE SUMMARY      ~n'),
    format('====================================================~n'),
    format('Timeline:       ~w to ~w~n', [T_start, Tn]),
    format('Structural Pattern: ~w~n', [Pattern]),
    format('Confidence:     ~w~n', [Conf]),
    
    % --- SECTION 1: DRL INDEXICAL AUDIT ---
    format('~n[CONSTRAINT INVENTORY: INDEXICAL AUDIT]~n'),
    forall(
        narrative_ontology:constraint_claim(C, Claimed),
        (
            format('~n~nConstraint: ~w~n', [C]),
            format('  Claimed Type: ~w~n', [Claimed]),
            format('  Perspectives:~n'),
            forall(
                constraint_indexing:constraint_classification(C, Type, Context),
                (
                    format('    - [~w]: ~w', [Context, Type]),
                    ( Type == Claimed -> format(' (Matches Claim)~n')
                    ; format(' (Mismatch)~n')
                    )
                )
            )
        )
    ),

    % --- SECTION 2: ISOMORPHISM AUDIT ---
    generate_isomorphism_audit(IntervalID),

    % --- SECTION 2A: COMPREHENSIVE CROSS-DOMAIN AUDIT ---
    cross_domain_audit,

    % --- SECTION 3: META-LOGICAL AUDIT ---
    format('~n[META-LOGICAL AUDIT: ONTOLOGICAL FRAUD DETECTION]~n'),
    (   setof((C, Err, Sev), drl_core:dr_mismatch(C, Err, Sev), Errors)
    ->  forall(member((C, Err, Sev), Errors),
               format('  ! ALERT [~w]: ~w detected for ~w~n', [Sev, Err, C]))
    ;   format('  No classification errors detected. System is Ontologically Coherent.~n')
    ),

    % --- SECTION 3A: FORENSIC AUDIT FOR FALSE MOUNTAINS ---
    forensic_audit_false_mountains,

    % --- SECTION 4: STRUCTURAL SIGNATURE ANALYSIS ---
    format('~n[STRUCTURAL SIGNATURE ANALYSIS]~n'),
    (   catch(
            forall(narrative_ontology:constraint_claim(CSig, _Claim),
                   report_constraint_signature(CSig)),
            Error,
            format('  [FAIL] Exception: ~w~n', [Error]))
    ;   true
    ),

    % --- SECTION 5: UKE_DR FEASIBILITY BRIDGE ---
    format('~n[UKE_DR FEASIBILITY BRIDGE]~n'),
    format('  ~40s | ~12s~n', ['Recommendation', 'UKE Status']),
    format('  ----------------------------------------------------------------------~n'),
    (   forall(narrative_ontology:recommendation(RID, Summary),
               ( ( uke_dr_bridge:uke_status(RID, UKEStatus, Reasons) 
                 -> format('  - ~40w | ~12w~n', [Summary, UKEStatus]),
                    forall(member(R, Reasons), format('    > ~w~n', [R]))
                 ;  format('  - ~40w | ~12s~n', [Summary, 'DATA_MISSING'])
                 )
               ))
    ;   true
    ),
    
    % --- SECTION 6: KINETIC MAGNITUDE ---
    findall(Kappa, (v3_1_config:level(L), v3_1_coercion_projection:coercion_magnitude(L, Tn, Kappa)), Kappas),
    (   Kappas \= [] 
    ->  sum_list(Kappas, SumK), length(Kappas, NK), AvgK is SumK / NK,
        format('~nAggregate Magnitude (Kappa) at Tn: ~2f~n', [AvgK])
    ;   format('~nAggregate Magnitude (Kappa): DATA_INSUFFICIENT~n')
    ),
    
    % --- SECTION 7: PERSPECTIVAL GAP ANALYSIS ---
    format('~n[PERSPECTIVAL GAP ANALYSIS]~n'),
    (   forall(narrative_ontology:constraint_claim(CGap, _),
               perspectival_gap_audit(CGap))
    ;   true
    ),
    
    % --- SECTION 8: OMEGA GENERATION ---
    generate_omegas_from_gaps(IntervalID),

    % --- SECTION 8A: OMEGA TRIAGE ---
    generate_omega_triage,

    % --- SECTION 8B: OMEGA RESOLUTION SCENARIOS ---
    generate_omega_resolution_scenarios,

    format('====================================================~n').

/* ============================================================================
   2. OMEGA GENERATION
   ============================================================================ */

generate_omegas_from_gaps(IntervalID) :-
    format('~n[OMEGA GENERATION FROM PERSPECTIVAL GAPS: ~w]~n', [IntervalID]),
    findall(
        omega_entry(OmegaID, Type, Question, Gap),
        (   narrative_ontology:constraint_claim(C, _),  % Look at ALL claimed constraints
            detect_gap_pattern(C, Gap),
            omega_from_gap(C, Gap, OmegaID, Type, Question)
        ),
        OmegaEntries
    ),
    process_omega_entries(OmegaEntries).

process_omega_entries([]) :- 
    format('  No perspectival gaps detected requiring Ω tracking.~n').
process_omega_entries(OmegaEntries) :-
    OmegaEntries \= [],
    length(OmegaEntries, Count),
    format('  Generated ~w Omega variables from perspectival gaps:~n~n', [Count]),
    forall(member(omega_entry(OID, OType, OQuestion, OGap), OmegaEntries),
           (   format('  Ω: ~w (~w)~n', [OID, OType]),
               format('     Question: ~w~n', [OQuestion]),
               format('     Source: ~w~n~n', [OGap]),
               assert_omega_if_new(OID, OType, OQuestion)
           )).

% detect_gap_pattern and omega_from_gap logic remains unchanged...
% [Included below for completeness in your file]

% Pattern 1: Snare masked as Rope - MOST CRITICAL (extraction blindness)
detect_gap_pattern(C, gap(noose_masked_as_rope, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = snare, 
    TypeI = rope, 
    !.

% Pattern 2: Snare/Mountain confusion - CRITICAL (learned helplessness)
detect_gap_pattern(C, gap(noose_mountain_confusion, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = snare, 
    TypeI = mountain, 
    !.

% Pattern 3: Mountain/Rope confusion - REQUIRES SCAFFOLD (catastrophic cut risk)
detect_gap_pattern(C, gap(mountain_coordination_confusion, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = mountain, 
    TypeI = rope, 
    !.

% Pattern 4: General catch-all - MUST BE LAST (any other mismatch)
detect_gap_pattern(C, gap(general_type_mismatch, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP \= TypeI, 
    TypeP \= none, 
    TypeI \= none.

omega_from_gap(C, gap(noose_masked_as_rope, snare, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_extraction_blindness_~w', [C]),
    format(atom(Question), 'Constraint ~w appears extractive (Snare) to individuals but functional (Rope) to institutions...', [C]), !.

omega_from_gap(C, gap(mountain_coordination_confusion, mountain, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_cut_safety_~w', [C]),
    format(atom(Question), 'Constraint ~w appears unchangeable (Mountain) to individuals but optional (Rope) to institutions...', [C]), !.

omega_from_gap(C, gap(noose_mountain_confusion, snare, mountain), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_learned_helplessness_~w', [C]),
    format(atom(Question), 'Constraint ~w appears extractive (Snare) to individuals but unchangeable (Mountain) to institutions...', [C]), !.

omega_from_gap(C, gap(general_type_mismatch, TypeP, TypeI), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_perspectival_~w', [C]),
    format(atom(Question), 'Constraint ~w appears as ~w to individuals but ~w to institutions...', [C, TypeP, TypeI]), !.

assert_omega_if_new(OmegaID, Type, Question) :-
    (   narrative_ontology:omega_variable(OmegaID, _, _)
    ->  true
    ;   assertz(narrative_ontology:omega_variable(OmegaID, Type, Question))
    ).

/* ============================================================================
   3. INDEXED REPORTING & AUDITS
   ============================================================================ */

perspectival_gap_audit(C) :-
    format('~n  Analysis for Constraint: ~w~n', [C]),
    (constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)) -> true ; TypeP = none),
    (constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)) -> true ; TypeI = none),
    (TypeP == mountain, TypeI == rope -> format('    ! GAP: Institutional "Rope" appears as "Mountain" to Powerless.~n') ; true),
    (TypeP == snare, TypeI == rope -> format('    ! ALERT: Extractive "Snare" is masked as functional "Rope".~n') ; true),
    format('    - Individual (Powerless): ~w~n', [TypeP]),
    format('    - Institutional (Manager): ~w~n', [TypeI]).

report_constraint_signature(C) :-
    drl_core:dr_signature(C, Signature),
    structural_signatures:signature_confidence(C, Signature, Confidence),
    structural_signatures:explain_signature(C, Signature, Explanation),
    format('  ~20w: ~20w (confidence: ~w)~n', [C, Signature, Confidence]),
    (Signature \= ambiguous -> format('    → ~w~n', [Explanation]) ; true).

% Remaining placeholders (generate_indexed_report, extract_constraints, generate_llm_feedback, sublist, etc.) 
% should be placed here as top-level predicates...

generate_indexed_report(Text, Context, Report) :-
    extract_constraints(Text, Constraints),
    maplist(classify_with_context(Context), Constraints, Classifications),
    format_indexed_report(Classifications, Context, Report).

classify_with_context(Context, Constraint, classification(Constraint, Type)) :-
    constraint_indexing:constraint_classification(Constraint, Type, Context).

extract_constraints(Text, Constraints) :-
    atom_codes(Text, Codes),
    findall(C, (constraint_keyword(C), atom_codes(C, CCode), sublist(CCode, Codes)), Cs),
    sort(Cs, Constraints).

constraint_keyword(catholic_church_1200).
constraint_keyword(property_rights_2025).

format_indexed_report(Classifications, Context, Report) :-
    Context = context(agent_power(Power), time_horizon(Time), exit_options(Exit), spatial_scope(Scope)),
    with_output_to(atom(Report),
        (format('~n[INDEXED CONSTRAINT ANALYSIS]~n'),
         format('Perspective: ~w / ~w / ~w / ~w~n~n', [Power, Time, Exit, Scope]),
         format('Classifications:~n'),
         forall(member(classification(C, T), Classifications), format('  ~w: ~w~n', [C, T])))).

generate_llm_feedback(IntervalID) :-
    format('~n### START LLM REFINEMENT MANIFEST: ~w ###~n', [IntervalID]),
    format('~n[PERSPECTIVAL_GAPS]~n'),
    (forall(narrative_ontology:constraint_claim(C, _),
           (constraint_indexing:constraint_classification(C, TypeP, context(agent_power(individual_powerless), _, _, _)),
            constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
            TypeP \= TypeI, format('  - Constraint "~w": Individual sees ~w, but Institution sees ~w.~n', [C, TypeP, TypeI]))) ; true),
    format('~n[ONTOLOGICAL_MISMATCHES]~n'),
    (setof((CM, Err, Sev), drl_core:dr_mismatch(CM, Err, Sev), Errors) -> forall(member((CM, Err, Sev), Errors), format('  - ~w: [~w] ~w detected.~n', [CM, Sev, Err])) ; format('  - None detected.~n')),
    format('~n[UNRESOLVED_OMEGAS]~n'),
    (setof((OID, OTy, ODe), narrative_ontology:omega_variable(OID, OTy, ODe), Omegas) -> forall(member((OID, OTy, ODe), Omegas), format('  - ~w (~w): ~w~n', [OID, OTy, ODe])) ; format('  - None detected.~n')),
    format('~n### END REFINEMENT MANIFEST ###~n').

sublist([], _).
sublist([H|T], [H|T2]) :- !, sublist(T, T2).
sublist(Sub, [_|T]) :- sublist(Sub, T).

classify_interval(_IntervalID, stable, high).

% Ensure these are at the BOTTOM of report_generator.pl, NOT inside generate_full_report
generate_isomorphism_audit(IntervalID) :-
    format('~n[CROSS-DOMAIN ISOMORPHISM & RISK AUDIT: ~w]~n', [IntervalID]),
    (   setof(iso(C, Twin, Score, Type),
              (narrative_ontology:constraint_claim(C, _),  % Changed: use all constraints in current KB
               isomorphism_engine:find_high_risk_isomorphism(C, Twin, Score),
               drl_core:dr_type(C, Type)),
              Isos)
    ->  display_isomorphisms(Isos)
    ;   format('  No high-risk isomorphisms detected for current constraints.~n')
    ).

display_isomorphisms([]).
display_isomorphisms([iso(C, T, S, Ty)|Rest]) :-
    format('  ! ALERT: ~w (~w) is a Structural Twin to ~w (Score: ~2f)~n', [C, Ty, T, S]),
    format('    > Strategy: Search for ~w resolutions in KB.~n', [T]),
    display_isomorphisms(Rest).

/* ============================================================================
   4. ONTOLOGICAL FORENSIC AUDIT: FALSE MOUNTAINS
   ============================================================================ */

%% forensic_audit_false_mountains/0
%  Provides detailed analysis of constraints claiming "Mountain" status
%  but failing validation. Explains WHY each fails and recommends reclassification.
forensic_audit_false_mountains :-
    format('~n[ONTOLOGICAL FORENSIC AUDIT: FALSE MOUNTAINS]~n'),
    (   setof(C-Ctx, Sev^(drl_core:dr_mismatch(C, Ctx, type_1_false_mountain, Sev)),
              FalseMountains)
    ->  (length(FalseMountains, Count),
         format('  Detected ~w constraint(s) falsely claiming "Mountain" status:~n~n', [Count]),
         forall(member(C-Context, FalseMountains),
                forensic_explain_false_mountain(C, Context)))
    ;   format('  All mountains are structurally validated.~n')
    ).

%% forensic_explain_false_mountain(+Constraint, +Context)
%  Explains in detail why a constraint fails mountain validation.
%  Now using safe helpers for defensive programming.
forensic_explain_false_mountain(C, Context) :-
    format('  ┌─ CONSTRAINT: ~w~n', [C]),
    format('  │  Context: ~w~n', [Context]),
    format('  │~n', []),

    % Get metrics using safe helpers (with defaults and logging)
    utils:safe_get_metric(C, suppression_requirement, Supp, 0.0, false),
    (Supp = 0.0
    -> format('  │  Suppression Requirement: MISSING (using default 0.0)~n', [])
    ;  format('  │  Suppression Requirement: ~2f~n', [Supp])),

    % Get mountain ceiling safely
    utils:safe_get_config(mountain_suppression_ceiling, Ceil, 0.15),
    (Ceil = 0.15
    -> format('  │  Mountain Ceiling (threshold): ~2f (default)~n', [Ceil])
    ;  format('  │  Mountain Ceiling (threshold): ~2f~n', [Ceil])),

    % Analyze why it fails
    format('  │~n', []),
    format('  │  FAILURE ANALYSIS:~n', []),
    (Supp > Ceil
    -> format('  │  ✗ Requires active enforcement (suppression ~2f > ~2f threshold)~n', [Supp, Ceil])
    ;  format('  │  ? Suppression within range, checking other factors...~n', [])),

    % Get extractiveness safely
    utils:safe_get_extractiveness(C, Extr, 0.0, false),
    (Extr = 0.0
    -> format('  │  Base Extractiveness: MISSING (using default 0.0)~n', [])
    ;  (format('  │  Base Extractiveness: ~2f~n', [Extr]),
        (Extr > 0.35
        -> format('  │  ✗ Shows extractive pattern (E > 0.35)~n', [])
        ;  format('  │  ✓ Non-extractive pattern (E ≤ 0.35)~n', [])))),

    % Check resistance to change safely
    utils:safe_get_metric(C, resistance_to_change, Resist, 0.0, false),
    (Resist = 0.0
    -> format('  │  Resistance to Change: MISSING (using default 0.0)~n', [])
    ;  format('  │  Resistance to Change: ~2f~n', [Resist])),

    % Provide forensic verdict
    format('  │~n', []),
    format('  │  FORENSIC VERDICT:~n', []),
    determine_correct_classification(Supp, Extr, Ceil, Verdict, Rationale),
    format('  │  → Should be classified as: ~w~n', [Verdict]),
    format('  │  → Rationale: ~w~n', [Rationale]),

    % Check for mandatrophy (mountain that functions as trap)
    (Extr > 0.7
    -> format('  │  ⚠ WARNING: Possible MANDATROPHY detected~n', []),
       format('  │    (Genuinely unchangeable BUT highly extractive)~n', [])
    ;  true),

    format('  └─~n~n', []).

%% determine_correct_classification(+Supp, +Extr, +Ceil, -Verdict, -Rationale)
%  Logic to determine what a false mountain should actually be classified as.
determine_correct_classification(Supp, Extr, Ceil, Verdict, Rationale) :-
    (Supp > Ceil, Extr > 0.66
    -> (Verdict = 'NOOSE',
        Rationale = 'High enforcement + high extraction = extractive trap')
    ; Supp > Ceil, Extr > 0.35
    -> (Verdict = 'TANGLED_ROPE',
        Rationale = 'Moderate enforcement + moderate extraction = complex coordination with extractive elements')
    ; Supp > Ceil
    -> (Verdict = 'ROPE',
        Rationale = 'Requires enforcement but not extractive = changeable rule')
    ; Extr > 0.66
    -> (Verdict = 'NOOSE (check metrics)',
        Rationale = 'High extraction despite low suppression suggests misclassification or measurement error')
    ;  (Verdict = 'AMBIGUOUS (review data)',
        Rationale = 'Metrics inconclusive, manual review required')
    ).

/* ============================================================================
   5. OMEGA RESOLUTION SCENARIOS
   ============================================================================ */

%% generate_omega_resolution_scenarios/0
%  Generates actionable test scenarios for resolving each unresolved omega.
%  This drives scenario creation by providing specific resolution strategies.
generate_omega_resolution_scenarios :-
    format('~n[OMEGA RESOLUTION SCENARIO GENERATION]~n'),
    findall(omega_data(OID, OType, ODesc, Constraint, GapPattern),
            (narrative_ontology:omega_variable(OID, OType, ODesc),
             extract_constraint_from_omega_id(OID, Constraint),
             determine_gap_pattern(OID, Constraint, GapPattern)),
            Omegas),
    (Omegas = []
    -> format('  No unresolved Omegas. System is epistemically complete.~n')
    ;  (length(Omegas, N),
        format('  Generated ~w resolution scenario(s):~n~n', [N]),
        forall(member(omega_data(OID, OType, ODesc, C, Gap), Omegas),
               generate_scenario_for_omega(OID, OType, ODesc, C, Gap)))
    ).

%% extract_constraint_from_omega_id(+OmegaID, -Constraint)
%  Extracts the constraint name from omega IDs like omega_extraction_blindness_CONSTRAINT
extract_constraint_from_omega_id(OmegaID, Constraint) :-
    atom_string(OmegaID, OIDStr),
    (sub_string(OIDStr, _, _, _, "omega_extraction_blindness_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "extraction", "blindness"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_learned_helplessness_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "learned", "helplessness"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_cut_safety_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "cut", "safety"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_perspectival_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "perspectival"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ;  Constraint = unknown
    ).

%% determine_gap_pattern(+OmegaID, +Constraint, -Pattern)
%  Determines which gap pattern caused this omega
determine_gap_pattern(OmegaID, Constraint, Pattern) :-
    atom_string(OmegaID, OIDStr),
    (sub_string(OIDStr, _, _, _, "extraction_blindness")
    -> (Pattern = noose_masked_as_rope)
    ; sub_string(OIDStr, _, _, _, "learned_helplessness")
    -> (Pattern = noose_mountain_confusion)
    ; sub_string(OIDStr, _, _, _, "cut_safety")
    -> (Pattern = mountain_coordination_confusion)
    ;  (Constraint \= unknown,
        detect_gap_pattern(Constraint, gap(Pattern, _, _))
       -> true
       ;  Pattern = general_type_mismatch)
    ).

%% generate_scenario_for_omega(+OmegaID, +Type, +Description, +Constraint, +GapPattern)
%  Generates a specific resolution scenario based on omega type and gap pattern.
generate_scenario_for_omega(OID, empirical, Desc, C, _Gap) :-
    format('  ┌─ [~w] EMPIRICAL DATA COLLECTION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Design measurement protocol for ~w~n', [C]),
    format('  │  2. Collect data from N=30+ real-world instances~n', []),
    format('  │  3. Calculate empirical metrics:~n', []),
    format('  │     - suppression_requirement (enforcement needed)~n', []),
    format('  │     - resistance_to_change (pushback level)~n', []),
    format('  │     - base_extractiveness (asymmetric benefit flow)~n', []),
    format('  │  4. Update constraint_metric/3 declarations with data~n', []),
    format('  │  5. Re-run classification to resolve perspectival gap~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, noose_masked_as_rope) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  CRITICAL: Extraction Masking Detected~n', []),
    format('  │  Powerless see: NOOSE (extractive trap)~n', []),
    format('  │  Institutions see: ROPE (functional rule)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Interview affected individuals (N=10+):~n', []),
    format('  │     - Who benefits from ~w?~n', [C]),
    format('  │     - Can you change/exit this constraint?~n', []),
    format('  │     - What would happen if you tried?~n', []),
    format('  │  2. Interview institutional actors (N=10+):~n', []),
    format('  │     - What function does ~w serve?~n', [C]),
    format('  │     - Who would object to removing it?~n', []),
    format('  │     - What alternatives exist?~n', []),
    format('  │  3. Document benefit flows:~n', []),
    format('  │     - Track who gains vs. who loses from status quo~n', []),
    format('  │     - Measure asymmetric benefit distribution~n', []),
    format('  │  4. Decision tree:~n', []),
    format('  │     IF extraction confirmed → Reclassify as NOOSE~n', []),
    format('  │     IF functional & fair → Reclassify as ROPE~n', []),
    format('  │     IF context-dependent → Add indexical resolution~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, noose_mountain_confusion) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  CRITICAL: Learned Helplessness Pattern~n', []),
    format('  │  Powerless see: NOOSE (extractive trap)~n', []),
    format('  │  Institutions see: MOUNTAIN (unchangeable law)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Test changeability:~n', []),
    format('  │     - Can institutions modify ~w?~n', [C]),
    format('  │     - What legal/political mechanisms exist?~n', []),
    format('  │     - Historical precedents of change?~n', []),
    format('  │  2. Test extraction:~n', []),
    format('  │     - Is benefit flow symmetric or asymmetric?~n', []),
    format('  │     - Who has veto power over changes?~n', []),
    format('  │  3. Decision tree:~n', []),
    format('  │     IF truly unchangeable + extractive → MANDATROPHY~n', []),
    format('  │     IF changeable + extractive → Correct to NOOSE~n', []),
    format('  │     IF unchangeable + fair → Correct to MOUNTAIN~n', []),
    format('  │     IF institutions falsely claim necessity → NOOSE + fraud flag~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, mountain_coordination_confusion) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  HIGH RISK: Coordination Cut Safety~n', []),
    format('  │  Powerless see: MOUNTAIN (unchangeable, survival-critical)~n', []),
    format('  │  Institutions see: ROPE (optional, changeable)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. SAFETY ASSESSMENT (DO NOT SKIP):~n', []),
    format('  │     - If institutions cut ~w, do individuals have alternatives?~n', [C]),
    format('  │     - Is this their only survival mechanism?~n', []),
    format('  │     - What scaffolding exists for transition?~n', []),
    format('  │  2. Test institutional perception:~n', []),
    format('  │     - Can institutions unilaterally change this?~n', []),
    format('  │     - Do they understand downstream impacts?~n', []),
    format('  │     - Is their "optional" view empirically accurate?~n', []),
    format('  │  3. Decision tree:~n', []),
    format('  │     IF truly unchangeable → Correct institutional view to MOUNTAIN~n', []),
    format('  │     IF changeable + safe alternatives → Correct powerless view to ROPE~n', []),
    format('  │     IF changeable + NO alternatives → ADD SCAFFOLD before any change~n', []),
    format('  │     IF uncertainty → HALT changes until resolved~n', []),
    format('  │  4. CRITICAL: Never proceed with changes until safety verified~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, general_type_mismatch) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Map stakeholder perspectives:~n', []),
    format('  │     - Document how different actors perceive ~w~n', [C]),
    format('  │     - Identify source of divergence~n', []),
    format('  │  2. Gather evidence:~n', []),
    format('  │     - Empirical metrics (suppression, extraction, resistance)~n', []),
    format('  │     - Historical behavior patterns~n', []),
    format('  │  3. Create indexical classification:~n', []),
    format('  │     - From powerless context: classify as X~n', []),
    format('  │     - From institutional context: classify as Y~n', []),
    format('  │     - Add explicit context annotations~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, preference, Desc, C, _Gap) :-
    format('  ┌─ [~w] VALUE ARBITRATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  NOTE: Not resolvable via data or logic alone~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Document competing value frameworks:~n', []),
    format('  │     - What values support current ~w?~n', [C]),
    format('  │     - What values oppose it?~n', []),
    format('  │     - Are these incommensurable?~n', []),
    format('  │  2. Propose scaffolded solution:~n', []),
    format('  │     - Design mechanism respecting both value sets~n', []),
    format('  │     - Create exit options for dissenters~n', []),
    format('  │     - Allow preference-based sorting~n', []),
    format('  │  3. Accept unresolvability if necessary:~n', []),
    format('  │     - Some omegas represent genuine value pluralism~n', []),
    format('  │     - Solution: coexistence, not consensus~n', []),
    format('  └─~n~n', []).

/* ============================================================================
   6. OMEGA SEVERITY TRIAGE
   ============================================================================ */

%% omega_severity(+OmegaID, -Severity)
%  Prioritizes omegas by severity/urgency.
omega_severity(OID, critical) :-
    atom(OID),
    (sub_atom(OID, _, _, _, extraction_blindness)
    ; (narrative_ontology:omega_variable(OID, _, Desc),
       atom(Desc),
       (sub_atom(Desc, _, _, _, extraction)
       ; sub_atom(Desc, _, _, _, snare)
       ; sub_atom(Desc, _, _, _, 'Snare')
       ; sub_atom(Desc, _, _, _, trap)))
    ), !.

omega_severity(OID, high) :-
    atom(OID),
    (sub_atom(OID, _, _, _, learned_helplessness)
    ; sub_atom(OID, _, _, _, cut_safety)
    ; narrative_ontology:omega_variable(OID, conceptual, _)
    ), !.

omega_severity(OID, moderate) :-
    atom(OID),
    narrative_ontology:omega_variable(OID, empirical, _), !.

omega_severity(OID, low) :-
    atom(OID),
    narrative_ontology:omega_variable(OID, preference, _), !.

omega_severity(_, unknown).

%% generate_omega_triage/0
%  Displays omegas organized by severity level.
generate_omega_triage :-
    format('~n[OMEGA TRIAGE & PRIORITIZATION]~n'),
    % First collect all actual omegas
    findall(OID, narrative_ontology:omega_variable(OID, _, _), AllOmegas),
    (AllOmegas = []
    -> format('  No omegas to triage.~n')
    ;  % Then organize by severity
       forall(member(Sev, [critical, high, moderate, low]),
              (findall(OID,
                       (member(OID, AllOmegas), omega_severity(OID, Sev)),
                       OIDs),
               (OIDs \= []
               -> (length(OIDs, N),
                   format('~n  [~w] ~w omega(s):~n', [Sev, N]),
                   forall(member(OID, OIDs),
                          (narrative_ontology:omega_variable(OID, Type, Desc),
                           format('    - ~w (~w)~n      ~w~n', [OID, Type, Desc]))))
               ;  true)))
    ).

/* ============================================================================
   7. COMPREHENSIVE CROSS-DOMAIN AUDIT
   ============================================================================ */

%% cross_domain_audit/0
%  Scans ALL constraints in current KB and reports cross-domain structural twins.
%  This provides a comprehensive view of isomorphic patterns across different domains.
cross_domain_audit :-
    format('~n[COMPREHENSIVE CROSS-DOMAIN STRUCTURAL TWINS]~n'),
    findall(iso(C1, C2, Score, Cat1, Cat2),
            (narrative_ontology:constraint_claim(C1, _),
             domain_priors:category_of(C1, Cat1),
             isomorphism_engine:find_isomorphism(C1, C2, Score),
             domain_priors:category_of(C2, Cat2),
             Cat1 \= Cat2,  % Only cross-domain twins
             C1 @< C2),     % Prevent duplicate pairs (A,B) and (B,A)
            Isos),
    (Isos = []
    -> format('  No cross-domain isomorphisms detected.~n')
    ;  (length(Isos, N),
        format('  Found ~w cross-domain structural twins:~n~n', [N]),
        forall(member(iso(C1, C2, S, Cat1, Cat2), Isos),
               (format('  ~w (~w) ≈ ~w (~w)~n', [C1, Cat1, C2, Cat2]),
                format('    Similarity Score: ~2f~n', [S]),
                display_twin_rationale(C1, C2),
                nl)))
    ).

%% display_twin_rationale(+C1, +C2)
%  Explains why two constraints are considered structural twins.
display_twin_rationale(C1, C2) :-
    (structural_signatures:get_constraint_profile(C1, Profile1),
     structural_signatures:get_constraint_profile(C2, Profile2)
    -> (Profile1 = profile(A1, S1, R1, B1, Alt1, _, _),
        Profile2 = profile(A2, S2, R2, B2, Alt2, _, _),
        format('    Metrics: ', []),
        (abs(A1 - A2) < 0.15 -> format('Accum≈ ', []) ; true),
        (abs(S1 - S2) < 0.15 -> format('Supp≈ ', []) ; true),
        (abs(R1 - R2) < 0.15 -> format('Repr≈ ', []) ; true),
        (abs(B1 - B2) < 1.0 -> format('BenefΔ≈ ', []) ; true),
        (Alt1 = Alt2 -> format('AltMatch ', []) ; true),
        nl,
        format('    Implication: Solutions for ~w may inform ~w~n', [C1, C2]))
    ;  format('    (Profile data incomplete)~n')
    ).
:- module(scenario_manager, [
    clear_kb/0,
    load_and_run/2,
    list_active_intervals/0
]).

:- use_module(narrative_ontology).
:- use_module(test_harness).

% 1. FORCE DYNAMIC STATE
% This prevents "Redefined static procedure" errors even if the dataset 
% is generated without dynamic headers.
:- dynamic 
    narrative_ontology:entity/2, 
    narrative_ontology:interval/3, 
    narrative_ontology:event/4, 
    narrative_ontology:measurement/2, 
    narrative_ontology:constraint_claim/2, 
    narrative_ontology:constraint_metric/3, 
    narrative_ontology:omega_variable/3, 
    narrative_ontology:recommendation/2, 
    narrative_ontology:affects_constraint/2, 
    narrative_ontology:veto_actor/1, 
    narrative_ontology:veto_exposed/2,
    narrative_ontology:intent_fact/4.

/**
 * clear_kb
 * Forcefully retracts all facts.
 */
clear_kb :-
    format('~n[SCENARIO MANAGER] Clearing Knowledge Base...~n'),
    % Core Layers
    retractall(narrative_ontology:entity(_, _)),
    retractall(narrative_ontology:interval(_, _, _)),
    retractall(narrative_ontology:event(_, _, _, _)),
    retractall(narrative_ontology:measurement(_, _, _, _, _)),
    % Constraint Layer
    retractall(narrative_ontology:constraint_claim(_, _)),
    retractall(narrative_ontology:constraint_metric(_, _, _)),
    retractall(narrative_ontology:omega_variable(_,_,_)),
    retractall(narrative_ontology:recommendation(_, _)),
    retractall(narrative_ontology:affects_constraint(_, _)),
    retractall(narrative_ontology:veto_actor(_)),
    retractall(narrative_ontology:veto_exposed(_, _)),
    % Intent Layer
    retractall(narrative_ontology:intent_viable_alternative(_, _, _)),
    retractall(narrative_ontology:intent_alternative_rejected(_, _, _)),
    retractall(narrative_ontology:intent_beneficiary_class(_, _)),
    retractall(narrative_ontology:intent_power_change(_, _, _)),
    retractall(narrative_ontology:intent_suppression_level(_, _, _, _)),
    retractall(narrative_ontology:intent_resistance_level(_, _, _, _)),
    retractall(narrative_ontology:intent_norm_strength(_, _, _)),
    format('[OK] Knowledge Base is empty.~n').

% =============================================================================
% UPDATED Section 3: GLOBAL TEMPORAL SANITIZATION
% =============================================================================
% Iterate through EVERY interval in the KB to satisfy the Broad Auditor.
sanitize_all_intervals :-
    forall(narrative_ontology:interval(_ID, Start, End), (
        ensure_endpoint(Start),
        ensure_endpoint(End)
    )).

ensure_endpoint(T) :-
    narrative_ontology:measurement(T, _) -> true ; 
    % Impute neutral padding for any endpoint found in any interval.
    assertz(narrative_ontology:measurement(T, [0.5, 0.5, 0.5, 0.5])).

% 4. OMEGA ROUTER
% Routes Omega variables to appropriate resolution channels based 
% on the classification framework.
route_omega(ID) :-
    narrative_ontology:omega_variable(ID, Type, Desc),
    format('[OMEGA] Identified ~w (~w): ~w~n', [ID, Type, Desc]),
    (   Type == empirical  -> format(' -> Action: Design Measurement/Experiment.~n')
    ;   Type == conceptual -> format(' -> Action: Define Framework/Terms.~n')
    ;   Type == preference -> format(' -> Action: Escalate to Stakeholders.~n')
    ;   format(' -> Warning: Unknown Omega Type.~n')
    ). % Added missing closing parenthesis and period.

% =============================================================================
% UPDATED Section 5: TEST EXECUTION (Scenario Manager)
% =============================================================================
load_and_run(File, IntervalID) :-
    clear_kb,
    (   exists_file(File)
    ->  format('[SCENARIO MANAGER] Loading: ~w...~n', [File]),
        user:consult(File),

	% INJECT STRUCTURAL ANCHOR: Resolves [STEP 1] errors
        % This provides the audit suite with the interval it expects.
        assertz(narrative_ontology:interval(IntervalID, 0, 10)),
        inject_minimal_measurements(IntervalID),
	
        % FIX: Repair ALL intervals found in the KB, not just the primary one.
        format('[SCENARIO MANAGER] Performing Global Repair...~n'),
        forall(narrative_ontology:interval(ID, _, _), 
               v3_1_data_repair:repair_interval(ID)),
        
        % Proceed with the standard test suite
        test_harness:run_all_tests(IntervalID)
    ;   format('[ERROR] File ~w not found.~n', [File])
    ).

% 6. HELPER
list_active_intervals :-
    findall(ID, narrative_ontology:interval(ID, _, _), IDs),
    format('~nActive Intervals in KB: ~w~n', [IDs]).

% Helper to keep the main predicate clean
inject_minimal_measurements(ID) :-
    forall(member(T, [0, 10]),
        ( assertz(narrative_ontology:measurement(m_gen, ID, accessibility_collapse(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, stakes_inflation(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, suppression(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, resistance(structural), T, 0.5))
        )).
:- module(signature_mapper, [
    map_custom_pillar/3
]).

:- use_module(narrative_ontology).
:- use_module(structural_signatures).
:- use_module(v3_1_config).

%% map_custom_pillar(+Constraint, +CustomType, -StandardType)
%  Maps non-standard terminology to v3.1 standard pillars based on metrics.
map_custom_pillar(_C, CustomType, StandardType) :-
    % If already standard, do nothing
    member(CustomType, [mountain, rope, snare, piton]),
    StandardType = CustomType, !.

map_custom_pillar(C, _CustomType, StandardType) :-
    % Analyze structural signature based on current metrics
    structural_signatures:constraint_signature(C, Signature),
    resolve_mapping(Signature, StandardType).

% Natural Laws and high-stability invariants are Mountains
resolve_mapping(natural_law, mountain).
% Successful voluntary coordination (like decentralized_governance) are Ropes
resolve_mapping(coordination_scaffold, rope).
% A scaffold that has decayed into a liability is a Piton
resolve_mapping(piton_signature, piton).
% Asymmetric, enforced, or extractive rules are Nooses
resolve_mapping(constructed_constraint, snare).
% Fallback for ambiguous data
resolve_mapping(ambiguous, rope).
:- module(structural_signatures, [
    constraint_signature/2,
    signature_confidence/3,
    explain_signature/3,
    integrate_signature_with_modal/3
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

/* ================================================================
   STRUCTURAL SIGNATURE DETECTION v3.2
   
   Problem Statement (from Copilot's analysis):
   "Your classifier sees MAGNITUDE but not TYPE."
   
   The current DRL classifier uses only metric thresholds:
   - suppression > 0.1 → not a mountain
   - extractiveness > 0.7 → snare
   
   This causes misclassification of conceptual constraints:
   - Chaitin's Ω: collapse=1.0, suppression=0.0 → classified as mountain
   - Special Relativity: collapse=1.0, suppression=0.0 → classified as mountain
   - Arrow's Theorem: collapse=0.9, suppression=0.1 → fraud detection fires
   
   But these are STRUCTURALLY DIFFERENT:
   - Chaitin's Ω = NATURAL LAW (inherent impossibility)
   - Special Relativity = COORDINATION SCAFFOLD (successful standard)
   - Arrow's Theorem = NATURAL LAW (mathematical impossibility)
   
   Solution: Add STRUCTURAL SIGNATURES that detect constraint ORIGIN
   rather than just constraint METRICS.
   
   Three Core Signatures:
   1. Natural Law - empirical invariant, no alternatives possible
   2. Coordination Scaffold - voluntary equilibrium, alternatives existed
   3. Constructed Constraint - enforced rule, power asymmetries
   ================================================================ */

%% constraint_signature(+ConstraintID, -Signature)
%  Main entry point: classifies structural signature
%  Returns: natural_law | coordination_scaffold | constructed_constraint | ambiguous
constraint_signature(C, Signature) :-
    get_constraint_profile(C, Profile),
    classify_by_signature(Profile, Signature).

/* ================================================================
   PROFILE EXTRACTION
   
   Extracts 7 key features for signature classification:
   1. Accessibility Collapse (avg across time)
   2. Suppression Requirement (avg across time)
   3. Resistance Level (avg across time)
   4. Beneficiary Count (how many asymmetric winners)
   5. Has Viable Alternatives (were there choices?)
   6. Temporal Stability (does it evolve or remain constant?)
   7. Coordination Success (high access + low enforcement)
   ================================================================ */

get_constraint_profile(C, 
                      profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives, 
                             TemporalStability, CoordinationSuccess)) :-
    
    % Get averaged metrics across all levels
    get_metric_average(C, accessibility_collapse, AccessCollapse),
    get_metric_average(C, suppression_requirement, Suppression),
    get_metric_average(C, resistance, Resistance),
    
    % Count asymmetric beneficiaries
    count_power_beneficiaries(C, BeneficiaryCount),
    
    % Check for viable alternatives
    has_viable_alternatives(C, HasAlternatives),
    
    % Compute temporal stability
    compute_temporal_stability(C, TemporalStability),
    
    % Check coordination success pattern
    CoordinationSuccess = (AccessCollapse > 0.8, Suppression < 0.2).

%% get_metric_average(+Constraint, +MetricType, -Average)
%  Averages a metric across all levels (structural, organizational, class, individual)
get_metric_average(C, MetricType, Average) :-
    findall(Val, narrative_ontology:constraint_metric(C, MetricType, Val), Vals),
    (   Vals \= []
    ->  sum_list(Vals, Sum),
        length(Vals, N),
        Average is Sum / N
    ;   Average = 0.5  % Default if no data
    ).

%% count_power_beneficiaries(+Constraint, -Count)
%  Counts distinct classes with positive power changes
count_power_beneficiaries(C, Count) :-
    % Find intervals affecting this constraint
    findall(Class, (
        narrative_ontology:affects_constraint(I, C),
        narrative_ontology:intent_power_change(I, Class, Delta),
        Delta > 0.1  % Meaningful gain threshold
    ), Beneficiaries),
    sort(Beneficiaries, UniqueBeneficiaries),
    length(UniqueBeneficiaries, Count).

%% has_viable_alternatives(+Constraint, -HasAlternatives)
%  Checks if viable alternatives were considered (indicates choice vs necessity)
has_viable_alternatives(C, true) :-
    narrative_ontology:affects_constraint(I, C),
    narrative_ontology:intent_viable_alternative(I, _, _), !.
has_viable_alternatives(_, false).

%% compute_temporal_stability(+Constraint, -Stability)
%  Measures whether constraint metrics remain stable over time
%  Returns: stable | evolving
compute_temporal_stability(C, Stability) :-
    % Get suppression values at different time points for this constraint
    findall(Val, 
            narrative_ontology:constraint_metric(C, suppression_requirement, Val),
            Vals),
    (   Vals = []
    ->  Stability = unknown
    ;   Vals = [_SingleVal]
    ->  Stability = stable  % Only one measurement
    ;   compute_variance(Vals, Variance),
        (   Variance < 0.05
        ->  Stability = stable
        ;   Stability = evolving
        )
    ).

compute_variance(Vals, Variance) :-
    length(Vals, N),
    N > 0,
    sum_list(Vals, Sum),
    Mean is Sum / N,
    findall(SqDiff, (member(V, Vals), SqDiff is (V - Mean) * (V - Mean)), SqDiffs),
    sum_list(SqDiffs, SumSqDiffs),
    Variance is SumSqDiffs / N.

/* ================================================================
   SIGNATURE CLASSIFICATION LOGIC
   
   Decision Tree:
   
   1. Check Natural Law signature FIRST (most specific)
      - Extreme collapse + minimal enforcement + no alternatives
      - Examples: Chaitin's Ω, Heisenberg, Arrow's Theorem
      
   2. Check Coordination Scaffold SECOND
      - Extreme collapse + minimal enforcement + HAS alternatives
      - Examples: Special Relativity, SI Units, ISO Standards
      
   3. Check Constructed Constraint LAST (most general)
      - Positive enforcement OR beneficiary asymmetries
      - Examples: 26 USC §469, GS1 Barcodes, Hammurabi's Code
      
   4. Otherwise: ambiguous
   ================================================================ */

classify_by_signature(Profile, natural_law) :-
    natural_law_signature(Profile), !.

classify_by_signature(Profile, coordination_scaffold) :-
    coordination_scaffold_signature(Profile), !.

classify_by_signature(Profile, piton_signature) :-
    piton_signature(Profile), !.

classify_by_signature(Profile, constructed_constraint) :-
    constructed_constraint_signature(Profile), !.

classify_by_signature(_, ambiguous).

/* ================================================================
   SIGNATURE 1: NATURAL LAW
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero beneficiaries (no asymmetric winners)
   ✓ No viable alternatives (not a choice)
   ✓ Temporally stable (doesn't evolve)
   
   Interpretation:
   This is an INHERENT PROPERTY of the system, not a human choice.
   It cannot be changed by coordination or enforcement.
   
   Examples:
   - Chaitin's Omega (algorithmic information limit)
   - Heisenberg Uncertainty (quantum measurement limit)
   - Arrow's Impossibility (social choice limit)
   - Second Law of Thermodynamics (entropy increase)
   ================================================================ */

natural_law_signature(profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives,
                             TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions
    v3_1_config:param(natural_law_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    v3_1_config:param(natural_law_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    v3_1_config:param(natural_law_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (CRITICAL for distinguishing from coordination)
    BeneficiaryCount == 0,  % No asymmetric winners
    HasAlternatives == false,  % Not a choice
    TemporalStability == stable.  % Doesn't evolve

/* ================================================================
   SIGNATURE 2: COORDINATION SCAFFOLD
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero or few beneficiaries (symmetric benefits)
   ✓ HAS viable alternatives (WAS a choice)
   ✓ May be stable or evolving (can be refined)
   
   KEY DISTINCTION from Natural Law:
   - Alternatives EXISTED → this was a COORDINATION CHOICE
   - Success is CONTINGENT → depends on continued acceptance
   - Could theoretically be replaced → not inherent to reality
   
   Interpretation:
   This is a SUCCESSFUL VOLUNTARY STANDARD that everyone adopted
   because it provides symmetric coordination benefits.
   
   Examples:
   - Special Relativity (replaced Newtonian mechanics)
   - SI Metric System (replaced imperial units)
   - UTC Time Standard (replaced local solar time)
   - IP Protocol (replaced other network protocols)
   ================================================================ */

coordination_scaffold_signature(profile(AccessCollapse, Suppression, Resistance,
                                       BeneficiaryCount, HasAlternatives,
                                       _TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions (same as natural law)
    v3_1_config:param(coordination_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    v3_1_config:param(coordination_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    v3_1_config:param(coordination_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (DIFFERENT from natural law)
    BeneficiaryCount =< 1,  % Symmetric or near-symmetric
    HasAlternatives == true.  % KEY: This WAS a choice

/* ================================================================
   SIGNATURE 3: PITON
   
   Diagnostic Pattern:
   ✓ Variable accessibility collapse
   ✓ Low suppression (≤ 0.2) - persists through inertia, not force
   ✓ Positive resistance (> 0.2) - it's now causing friction
   ✓ Had viable alternatives - it was originally a choice
   ✓ Temporally evolving - it got worse over time
   
   Interpretation:
   This was once a useful coordination scaffold (a Rope), but has since
   ossified and now creates more problems than it solves. It persists
   due to high switching costs and institutional inertia. It is a Piton
   stuck in the mountain.
   
   Examples:
   - QWERTY Keyboard Layout
   - Legacy software monoliths
   ================================================================ */

piton_signature(profile(_AccessCollapse, Suppression, Resistance,
                                   _BeneficiaryCount, HasAlternatives,
                                   TemporalStability, _CoordinationSuccess)) :-
    Suppression =< 0.2,       % Low active enforcement
    Resistance > 0.2,         % But people are pushing back
    HasAlternatives == true,  % It was a choice
    TemporalStability == evolving. % It has decayed or gotten worse

/* ================================================================
   SIGNATURE 4: CONSTRUCTED CONSTRAINT
   
   Diagnostic Pattern:
   ✓ Variable accessibility collapse
   ✓ Positive suppression (> 0.2) OR
   ✓ Positive resistance (> 0.2) OR
   ✓ Multiple beneficiaries (asymmetric gains)
   
   Interpretation:
   This is an INSTITUTIONALLY ENFORCED RULE that requires
   active maintenance and produces asymmetric outcomes.
   
   Examples:
   - 26 USC §469 (passive loss limitation)
   - GS1 Barcode System (licensing monopoly)
   - Hammurabi's Code (benefice system)
   - Lehman's Repo 105 (accounting fiction)
   ================================================================ */

constructed_constraint_signature(profile(_AccessCollapse, Suppression, Resistance,
                                        BeneficiaryCount, _HasAlternatives,
                                        _TemporalStability, _CoordinationSuccess)) :-
    
    % At least one indicator of constructed constraint
    (   Suppression > 0.2        % Requires enforcement
    ;   Resistance > 0.2         % Faces opposition  
    ;   BeneficiaryCount > 1     % Asymmetric benefits
    ).

/* ================================================================
   CONFIDENCE SCORING
   
   Returns confidence level based on how strongly the signature
   pattern matches the classification.
   ================================================================ */

%% signature_confidence(+ConstraintID, +Signature, -Confidence)
%  Returns: high | medium | low
signature_confidence(C, Signature, Confidence) :-
    get_constraint_profile(C, Profile),
    compute_signature_confidence(Profile, Signature, Confidence).

compute_signature_confidence(Profile, natural_law, Confidence) :-
    Profile = profile(AccessCollapse, Suppression, Resistance, _, _, _, _),
    
    % Count strong indicators
    findall(1, (
        (AccessCollapse > 0.95);
        (Suppression < 0.05);
        (Resistance < 0.05)
    ), Indicators),
    length(Indicators, Count),
    
    (   Count >= 3 -> Confidence = high
    ;   Count >= 2 -> Confidence = medium
    ;   Confidence = low
    ).

compute_signature_confidence(Profile, coordination_scaffold, Confidence) :-

    Profile = profile(AccessCollapse, Suppression, _, _, HasAlternatives, _, _),

    

    % Strong indicators

    findall(1, (

        (AccessCollapse > 0.95);

        (Suppression < 0.05);

        (HasAlternatives == true)  % Critical for coordination

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 3 -> Confidence = high

    ;   Count >= 2 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(Profile, piton_signature, Confidence) :-

    Profile = profile(_, Suppression, Resistance, _, HasAlternatives, TemporalStability, _),

    

    % Count strong indicators for a piton

    findall(1, (

        (Suppression =< 0.2);

        (Resistance > 0.5);

        (HasAlternatives == true);

        (TemporalStability == evolving)

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 3 -> Confidence = high

    ;   Count >= 2 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(Profile, constructed_constraint, Confidence) :-

    Profile = profile(_, Suppression, Resistance, BeneficiaryCount, _, _, _),

    

    % Count enforcement indicators

    findall(1, (

        (Suppression > 0.5);

        (Resistance > 0.5);

        (BeneficiaryCount > 2)

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 2 -> Confidence = high

    ;   Count >= 1 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(_, ambiguous, low).

/* ================================================================
   EXPLANATION GENERATION
   ================================================================ */

%% explain_signature(+ConstraintID, +Signature, -Explanation)
explain_signature(C, natural_law, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, R, _, _, _, _),
    format(atom(Explanation),
           'NATURAL LAW signature for ~w: Extreme inaccessibility (collapse=~2f) with minimal enforcement (suppression=~2f, resistance=~2f). No viable alternatives exist. This represents an inherent property of the system, not a coordination choice. Cannot be changed by policy.',
           [C, AC, S, R]).

explain_signature(C, coordination_scaffold, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, _, _, _, _, _),
    format(atom(Explanation),
           'COORDINATION SCAFFOLD signature for ~w: Extreme accessibility (collapse=~2f) with minimal enforcement (suppression=~2f). Viable alternatives existed historically, indicating this is a successful coordination standard rather than a natural law. Maintains adoption through symmetric benefits.',
           [C, AC, S]).

explain_signature(C, piton_signature, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(_, S, R, _, _, _, _),
    format(atom(Explanation),
           'PITON signature for ~w: Persists through inertia (suppression=~2f) but faces user friction (resistance=~2f). Was once a choice, but has now become an ossified liability. This is a Piton.',
           [C, S, R]).

explain_signature(C, constructed_constraint, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(_, S, R, BC, _, _, _),
    format(atom(Explanation),
           'CONSTRUCTED CONSTRAINT signature for ~w: Active enforcement detected (suppression=~2f, resistance=~2f) with ~d asymmetric beneficiaries. This is an institutionally maintained rule requiring ongoing suppression energy.',
           [C, S, R, BC]).

explain_signature(C, ambiguous, Explanation) :-
    format(atom(Explanation),
           'AMBIGUOUS signature for ~w: Insufficient structural differentiation to classify. Consider gathering more data on alternatives, beneficiaries, and temporal evolution.',
           [C]).

/* ================================================================
   INTEGRATION WITH MODAL CLASSIFICATION
   
   This is the key integration point: structural signatures
   OVERRIDE modal classification when there's a mismatch.
   
   Example: Special Relativity
   - Modal classifier says: "mountain" (suppression=0, snapback=0)
   - Signature detector says: "coordination_scaffold"
   - Integrated result: "rope" with note about coordination success
   ================================================================ */

%% integrate_signature_with_modal(+Constraint, +ModalType, -AdjustedType)
%  Adjusts modal classification based on structural signature
integrate_signature_with_modal(C, ModalType, AdjustedType) :-
    constraint_signature(C, Signature),
    resolve_modal_signature_conflict(ModalType, Signature, AdjustedType).

% Natural laws stay as mountains (correct classification)
resolve_modal_signature_conflict(mountain, natural_law, mountain) :- !.

% Coordination scaffolds should be ROPES not mountains
resolve_modal_signature_conflict(mountain, coordination_scaffold, rope) :- !.

% Constructed constraints override mountain classification
resolve_modal_signature_conflict(mountain, constructed_constraint, tangled_rope) :- !.

% No conflict - keep original classification
resolve_modal_signature_conflict(ModalType, _, ModalType).
% ============================================================================ 
% REFERENCE IMPLEMENTATIONS: Tangled Rope Category 
% ============================================================================ 
% Purpose: Canonical examples validated by corpus analysis 
% Added: January 2026 (based on empirical validation of 467 constraints) 
% Empirical finding: 168/467 constraints (36%) show hybrid coordination/extraction pattern 
% 
% NOTE: This file is a collection of examples and not a standard constraint story. 
% ============================================================================ 

:- module(tangled_rope_examples, []). 

:- use_module(constraint_indexing). 
:- use_module(domain_priors). 
:- use_module(narrative_ontology). 

% Multifile declarations for predicates defined across test files 
:- multifile 
    domain_priors:base_extractiveness/2, 
    domain_priors:suppression_score/2, 
    domain_priors:requires_active_enforcement/1, 
    constraint_indexing:constraint_classification/3, 
    constraint_beneficiary/2, 
    constraint_victim/2. 

% Discontiguous declarations for predicates defined in multiple places 
:- discontiguous 
    domain_priors:base_extractiveness/2, 
    domain_priors:suppression_score/2, 
    domain_priors:requires_active_enforcement/1, 
    constraint_beneficiary/2, 
    constraint_victim/2. 

/* ========================================================================== 
   EXAMPLE 1: Carbon Credit Trading (Canonical Tangled Rope) 
   ========================================================================== */ 

/** 
 * CANONICAL TANGLED ROPE EXAMPLE 
 * 
 * Coordination function (ROPE properties): 
 * - Creates price signal for emissions reduction 
 * - Enables market-based climate action 
 * - Coordinates international climate policy 
 * 
 * Extractive function (NOOSE properties): 
 * - Financial intermediation extracts from real economy 
 * - Offset fraud and greenwashing enable extraction 
 * - Compliance costs hit small businesses harder 
 * 
 * Why tangled_rope classification matters: 
 * - "Just remove it" → loses coordination (price signal) 
 * - "Just maintain it" → perpetuates extraction 
 * - Reform path: Preserve price mechanism, reduce financial extraction 
 * 
 * Empirical metrics from corpus analysis: 
 * - Extraction: 0.55 (mid-range) 
 * - Suppression: 0.60 (requires enforcement) 
 * - Has both beneficiaries AND victims 
 */ 

% Core Constraint Declaration 
narrative_ontology:interval(carbon_market_era, 2000, 2026). 
narrative_ontology:constraint_claim(carbon_credit_trading_canonical, tangled_rope). 

% Base Metrics 
domain_priors:base_extractiveness(carbon_credit_trading_canonical, 0.55). 
domain_priors:suppression_score(carbon_credit_trading_canonical, 0.60). 
domain_priors:requires_active_enforcement(carbon_credit_trading_canonical). 

% Metrics for Executive Summary 
narrative_ontology:constraint_metric(carbon_credit_trading_canonical, extractiveness, 0.55). 
narrative_ontology:constraint_metric(carbon_credit_trading_canonical, suppression_requirement, 0.60). 

% Beneficiaries & Victims (demonstrates hybridity) 
constraint_beneficiary(carbon_credit_trading_canonical, multinational_corporations). 
constraint_beneficiary(carbon_credit_trading_canonical, financial_sector). 
constraint_beneficiary(carbon_credit_trading_canonical, climate_policy_coordination). 
constraint_victim(carbon_credit_trading_canonical, small_businesses). 
constraint_victim(carbon_credit_trading_canonical, offset_sellers). 
constraint_victim(carbon_credit_trading_canonical, greenwashing_targets). 

% Index-dependent classifications 
constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    rope, 
    context( 
        agent_power(institutional), 
        time_horizon(generational), 
        exit_options(mobile), 
        spatial_scope(global) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    tangled_rope, 
    context( 
        agent_power(analytical), 
        time_horizon(historical), 
        exit_options(analytical), 
        spatial_scope(global) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    snare, 
    context( 
        agent_power(individual_moderate), 
        time_horizon(biographical), 
        exit_options(constrained), 
        spatial_scope(national) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    snare, 
    context( 
        agent_power(individual_powerless), 
        time_horizon(biographical), 
        exit_options(trapped), 
        spatial_scope(local) 
    ) 
) :- !. 


/* ========================================================================== 
   EXAMPLE 2: Academic Tenure System (From Existing Corpus) 
   ========================================================================== */ 

/** 
 * ACADEMIC TENURE AS TANGLED ROPE 
 * 
 * Coordination function (ROPE properties): 
 * - Protects academic freedom 
 * - Enables long-term research projects 
 * - Coordinates faculty stability 
 * 
 * Extractive function (NOOSE properties): 
 * - Extracts hyper-productivity from pre-tenure faculty 
 * - Excludes adjuncts from security 
 * - Concentrates benefits in senior faculty 
 * 
 * Reclassified from corpus analysis: 
 * - Previously: rope (claimed type) 
 * - Empirical: extraction 0.75, suppression 0.60 
 * - New classification: tangled_rope 
 */ 

% Note: academic_tenure_system.pl already exists in testsets/ 
% This would be updated to claim tangled_rope instead of rope 

/* ========================================================================== 
   EXAMPLE 3: Platform Network Effects (Generic Template) 
   ========================================================================== */ 

/** 
 * PLATFORM MONOPOLIES AS TANGLED ROPE 
 * 
 * Coordination function (ROPE properties): 
 * - Coordinates user connections (network effects) 
 * - Enables communication and commerce 
 * - Provides standardized interface 
 * 
 * Extractive function (NOOSE properties): 
 * - Monopoly power extracts through pricing 
 * - Data harvesting and surveillance 
 * - Lock-in effects trap users 
 * 
 * Reform strategy: 
 * - Preserve network coordination (interoperability) 
 * - Cut extraction (data portability, competition) 
 */ 

narrative_ontology:constraint_claim(platform_network_monopoly_canonical, tangled_rope). 

domain_priors:base_extractiveness(platform_network_monopoly_canonical, 0.65). 
domain_priors:suppression_score(platform_network_monopoly_canonical, 0.55). 
domain_priors:requires_active_enforcement(platform_network_monopoly_canonical). 

narrative_ontology:constraint_metric(platform_network_monopoly_canonical, extractiveness, 0.65). 
narrative_ontology:constraint_metric(platform_network_monopoly_canonical, suppression_requirement, 0.55). 

constraint_beneficiary(platform_network_monopoly_canonical, platform_owners). 
constraint_beneficiary(platform_network_monopoly_canonical, advertisers). 
constraint_beneficiary(platform_network_monopoly_canonical, network_coordination). 
constraint_victim(platform_network_monopoly_canonical, users_privacy). 
constraint_victim(platform_network_monopoly_canonical, small_competitors). 
constraint_victim(platform_network_monopoly_canonical, innovation_potential). 

/* ========================================================================== 
   USAGE NOTES 
   ========================================================================== */ 

/** 
 * HOW TO IDENTIFY TANGLED ROPE CONSTRAINTS 
 * 
 * 1. Check metrics: 
 *    - base_extractiveness: 0.40-0.90 
 *    - suppression_score: >= 0.50 
 *    - requires_active_enforcement: true 
 * 
 * 2. Verify hybridity: 
 *    - Has coordination function: multiple beneficiaries or network effects 
 *    - Has asymmetric extraction: has victims or concentrated benefits 
 * 
 * 3. Test strategic implications: 
 *    - "Just remove it" → loses something valuable (coordination) 
 *    - "Just maintain it" → perpetuates harm (extraction) 
 *    - Reform approach → surgical separation possible 
 * 
 * EXAMPLES FROM CORPUS REQUIRING RECLASSIFICATION: 
 * - academic_tenure_system.pl (claimed: rope, should be: tangled_rope) 
 * - carbon_credit_markets_2026.pl (claimed: rope, should be: tangled_rope) 
 * - regulatory_capture.pl (claimed: snare, should be: tangled_rope) 
 * - gig_economy_algorithmic_managment.pl (check metrics) 
 * 
 * GREP SEARCH TO FIND CANDIDATES: 
 * Find files with extraction 0.40-0.90 AND suppression > 0.50: 
 * 
 * grep -l "base_extractiveness.*0\.[4-9]" testsets/*.pl | \ 
 * xargs grep -l "suppression_score.*0\.[5-9]" 
 */
*/:- module(test_harness, [
    load_scenario/1,
    run_all_tests/0,    % New: One-button alias
    run_all_tests/1,
    run_all_tests/2,
    quick_check/1
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(v3_1_coercion_projection).
:- use_module(v3_1_data_repair).
:- use_module(data_verification).
:- use_module(pattern_analysis).
:- use_module(intent_engine).
:- use_module(constraint_bridge).
:- use_module(constraint_indexing).
:- use_module(drl_core).
:- use_module(report_generator).

% Alias for quick execution using the most recent target
run_all_tests :-
    run_all_tests('tax_code_section_469'). % Targeted ID from your analysis

run_all_tests(IntervalID) :-
    constraint_indexing:default_context(Ctx),
    run_all_tests(IntervalID, Ctx).

run_all_tests(IntervalID, Context) :-
    format('~n>>> INITIATING v3.2.0 DR-AUDIT SUITE: ~w~n', [IntervalID]),
    
    % Step 1: Data Repair
    v3_1_data_repair:repair_interval(IntervalID),

    % Step 2: Verification Gate
    (   data_verification:verify_all,
        data_verification:check_paired_measurements
    ->  format('[OK] Verification passed.~n')
    ;   format('[FAIL] Verification failed for ~w.~n', [IntervalID]), fail),

    % Step 3: Indexical Audit
    forall(narrative_ontology:constraint_claim(C, _),
           constraint_indexing:compare_perspectives(C, Context)),

    % Step 4: Intent and Reporting
    intent_engine:analyze_intent(IntervalID),
    constraint_bridge:dr_diagnostic_report(IntervalID),

    % Step 5: System Insights (New)
    format('~n--- SYSTEM INSIGHTS ---~n'),
    narrative_ontology:count_unresolved_omegas(OmegaCount),
    format('  Omegas Identified: ~w~n', [OmegaCount]),
    report_generator:generate_full_report(IntervalID).

% Ensure quick_check uses the predicates from the authoritative module
quick_check(IntervalID) :-
    format('--- Diagnostic: ~w ---~n', [IntervalID]),
    (   drl_core:base_extractiveness(Name, E), E > 0.8
    ->  format('CRITICAL EXTRACTIVENESS: ~w (~2f)~n', [Name, E])
    ;   format('No critical extractiveness detected.~n')).

%% load_scenario(+Path)
load_scenario(Path) :-
    exists_file(Path),
    consult(Path),
    format('~n[SCENARIO] Successfully loaded: ~w~n', [Path]).
load_scenario(Path) :-
    \+ exists_file(Path), 
    format('~n[ERROR] Scenario file not found: ~w~n', [Path]),
    fail.
% ============================================================================
% INDEXICAL CLASSIFICATION INTEGRATION TEST
% ============================================================================

% Test that the indexical system loads and basic queries work

:- begin_tests(indexical_integration).

% Test 1: Default context works
test(default_context_defined) :-
    constraint_indexing:default_context(Ctx),
    Ctx = context(
        agent_power(analytical),
        time_horizon(civilizational),
        exit_options(analytical),
        spatial_scope(global)
    ).

% Test 2: Catholic Church multi-perspective
test(catholic_church_multi_perspective) :-
    % Serf sees Mountain
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        mountain,
        context(agent_power(individual_powerless), 
                time_horizon(biographical), 
                exit_options(trapped), 
                spatial_scope(local))
    ),
    % Historian sees Snare
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        snare,
        context(agent_power(analytical), 
                time_horizon(civilizational), 
                exit_options(analytical), 
                spatial_scope(continental))
    ),
    % Pope sees Rope
    constraint_indexing:constraint_classification(
        catholic_church_1200,
        rope,
        context(agent_power(institutional), 
                time_horizon(generational), 
                exit_options(arbitrage), 
                spatial_scope(continental))
    ).

% Test 3: Property rights perspectives
test(property_rights_perspectives) :-
    % Powerless sees Snare
    constraint_indexing:constraint_classification(
        property_rights_2025,
        snare,
        context(agent_power(individual_powerless),
                time_horizon(biographical),
                exit_options(trapped),
                spatial_scope(national))
    ),
    % Middle class sees Rope
    constraint_indexing:constraint_classification(
        property_rights_2025,
        rope,
        context(agent_power(individual_moderate),
                time_horizon(biographical),
                exit_options(mobile),
                spatial_scope(national))
    ).

% Test 4: Extractiveness scales with power
test(extractiveness_power_scaling) :-
    Context1 = context(agent_power(individual_powerless), 
                       time_horizon(biographical), 
                       exit_options(trapped), 
                       spatial_scope(national)),
    Context2 = context(agent_power(institutional), 
                       time_horizon(generational), 
                       exit_options(arbitrage), 
                       spatial_scope(global)),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, Context1, Score1),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, Context2, Score2),
    Score1 > Score2.  % Powerless experience more extraction

% Test 5: Immutability varies with time horizon
test(time_horizon_immutability) :-
    constraint_indexing:effective_immutability(biographical, trapped, mountain),
    constraint_indexing:effective_immutability(civilizational, trapped, rope).

% Test 6: Base extractiveness defined
test(base_extractiveness_defined) :-
    domain_priors:base_extractiveness(catholic_church_1200, E1),
    E1 = 0.7,
    domain_priors:base_extractiveness(property_rights_2025, E2),
    E2 = 0.5.

:- end_tests(indexical_integration).

% To run: swipl -g "consult('test_indexical_integration.pl'), run_tests." -t halt
:- module(uke_dr_bridge, [
    uke_status/3
]).

:- use_module(drl_core).
:- use_module(narrative_ontology).
:- use_module(constraint_bridge).

% Map Feasibility + DRL Type to UKE Status
uke_status(RecID, Status, Reasons) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is actually a recommendation
    narrative_ontology:affects_constraint(RecID, C),
    drl_core:dr_type(C, Type),
    constraint_bridge:recommendation_feasibility(RecID, Feas, Vetoes),
    determine_status(C, Type, Feas, Vetoes, Status, Reasons). % Passed C here

% --- Status Routing ---

determine_status(_, mountain, _, _, fantasy, 
    ['Recommendation attempts to modify a natural constraint (Mountain).']).

% Fixed: Uses C to check load-bearing status
determine_status(C, snare, _, _, blocked, 
    ['CRITICAL: Load-bearing Snare removal attempted without Scaffold.']) :-
    is_load_bearing(C),
    \+ narrative_ontology:entity(_, scaffold).

determine_status(_, Type, viable, [], viable, 
    ['No structural or political vetoes detected.']) :-
    member(Type, [rope, snare, piton]).

determine_status(_, tangled_rope, _, _, aspirational, 
    ['System is Tangled: Extraction is rising. Coordination remains, but Reform is required.']).

% Fallback for unclassified constraints
determine_status(_, unknown, _, _, investigate, 
    ['Structural audit incomplete: Constraint metrics do not match known types.']).

determine_status(_, _, blocked_by_veto, Vetoes, blocked, [Msg]) :-
    format(string(Msg), 'Vetoed by: ~w', [Vetoes]).

% Helper
is_load_bearing(C) :- 
    drl_core:dr_type(C, snare),
    v3_1_config:param(noose_load_bearing_threshold, T),
    narrative_ontology:constraint_metric(C, extractiveness, X), 
    X > T.
:- module(utils, [
    safe_get_metric/4,
    safe_get_metric/5,
    safe_get_category/3,
    safe_call/2,
    safe_call/3,
    log/3,
    set_log_level/1,
    get_log_level/1,
    require_metric/3,
    validate_metric_value/2
]).

:- use_module(narrative_ontology).
:- use_module(domain_priors).
:- use_module(v3_1_config).

/* ============================================================================
   DEFENSIVE PROGRAMMING UTILITIES
   ============================================================================

   This module provides safe wrappers for common operations that might fail,
   enabling defensive programming practices across the codebase.

   Key features:
   - Safe metric retrieval with defaults
   - Exception handling wrappers
   - Configurable logging
   - Validation helpers

   ============================================================================ */

:- dynamic log_level/1.
log_level(info).  % Default log level: debug, info, warn, error

/* ============================================================================
   1. SAFE METRIC RETRIEVAL
   ============================================================================ */

%% safe_get_metric(+Constraint, +Metric, -Value, +Default)
%  Retrieves a metric value, using default if missing.
%  Does NOT log warnings (silent fallback).
safe_get_metric(Constraint, Metric, Value, Default) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, V)
    -> Value = V
    ;  Value = Default).

%% safe_get_metric(+Constraint, +Metric, -Value, +Default, +LogWarning)
%  Retrieves a metric value, using default if missing.
%  Logs warning if LogWarning = true and metric is missing.
safe_get_metric(Constraint, Metric, Value, Default, LogWarning) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, V)
    -> Value = V
    ;  (Value = Default,
        (LogWarning = true
        -> log(warn, 'Missing metric ~w for ~w, using default ~w',
               [Metric, Constraint, Default])
        ;  true))).

%% safe_get_category(+Constraint, -Category, +Default)
%  Retrieves domain category, using default if missing.
safe_get_category(Constraint, Category, Default) :-
    (domain_priors:category_of(Constraint, Cat)
    -> (Cat \= unknown, Cat \= unknown_novel
       -> Category = Cat
       ;  (Category = Default,
           log(warn, 'Unknown category for ~w, using default ~w',
               [Constraint, Default])))
    ;  (Category = Default,
        log(warn, 'No category for ~w, using default ~w',
            [Constraint, Default]))).

%% require_metric(+Constraint, +Metric, -Value)
%  Retrieves a metric value, FAILING if missing (strict mode).
%  Use this when a metric is truly required for correctness.
require_metric(Constraint, Metric, Value) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, Value)
    -> true
    ;  (log(error, 'REQUIRED metric ~w missing for ~w',
            [Metric, Constraint]),
        fail)).

%% validate_metric_value(+Metric, +Value)
%  Validates that a metric value is in acceptable range.
validate_metric_value(_Metric, Value) :-
    number(Value),
    Value >= 0.0,
    Value =< 1.0.

/* ============================================================================
   2. SAFE CALL WRAPPERS
   ============================================================================ */

%% safe_call(+Goal, +ErrorMessage)
%  Executes Goal with exception handling.
%  Logs error and fails gracefully if exception occurs.
safe_call(Goal, ErrorMessage) :-
    catch(Goal,
          Error,
          (log(error, '~w: ~w', [ErrorMessage, Error]),
           fail)).

%% safe_call(+Goal, +ErrorMessage, +Default)
%  Executes Goal with exception handling.
%  Returns Default if Goal fails or throws exception.
safe_call(Goal, _ErrorMessage, _Default) :-
    catch(Goal, _, fail),
    !.
safe_call(_Goal, ErrorMessage, Default) :-
    log(warn, '~w, using default: ~w', [ErrorMessage, Default]),
    Default = Default.

/* ============================================================================
   3. LOGGING INFRASTRUCTURE
   ============================================================================ */

%% set_log_level(+Level)
%  Sets the logging level.
%  Levels: debug < info < warn < error
set_log_level(Level) :-
    member(Level, [debug, info, warn, error]),
    retractall(log_level(_)),
    assertz(log_level(Level)).

%% get_log_level(-Level)
%  Gets the current logging level.
get_log_level(Level) :-
    log_level(Level).

%% log(+Level, +Format, +Args)
%  Logs a message at the specified level.
%  Only logs if current log level permits.
log(Level, Format, Args) :-
    log_level(CurrentLevel),
    level_priority(Level, LP),
    level_priority(CurrentLevel, CP),
    (LP >= CP
    -> format_log_message(Level, Format, Args)
    ;  true).

%% level_priority(+Level, -Priority)
%  Maps log levels to numeric priorities.
level_priority(debug, 0).
level_priority(info, 1).
level_priority(warn, 2).
level_priority(error, 3).

%% format_log_message(+Level, +Format, +Args)
%  Formats and displays a log message.
format_log_message(Level, Format, Args) :-
    level_prefix(Level, Prefix),
    format('[~w] ', [Prefix]),
    format(Format, Args),
    nl.

%% level_prefix(+Level, -Prefix)
%  Maps log levels to display prefixes.
level_prefix(debug, 'DEBUG').
level_prefix(info, 'INFO').
level_prefix(warn, 'WARN').
level_prefix(error, 'ERROR').

/* ============================================================================
   4. ENHANCED METRIC RETRIEVAL WITH VALIDATION
   ============================================================================ */

%% safe_get_extractiveness(+Constraint, -Extractiveness)
%  Safe retrieval of base extractiveness with validation.
safe_get_extractiveness(Constraint, Extractiveness) :-
    safe_get_extractiveness(Constraint, Extractiveness, 0.0, true).

%% safe_get_extractiveness(+Constraint, -Extractiveness, +Default, +Warn)
safe_get_extractiveness(Constraint, Extractiveness, Default, Warn) :-
    (domain_priors:base_extractiveness(Constraint, E)
    -> (validate_metric_value(extractiveness, E)
       -> Extractiveness = E
       ;  (log(error, 'Invalid extractiveness ~w for ~w (must be 0.0-1.0)',
                [E, Constraint]),
           Extractiveness = Default))
    ;  (Extractiveness = Default,
        (Warn = true
        -> log(warn, 'Missing extractiveness for ~w, using default ~w',
               [Constraint, Default])
        ;  true))).

%% safe_get_suppression(+Constraint, -Suppression)
%  Safe retrieval of suppression requirement with validation.
safe_get_suppression(Constraint, Suppression) :-
    safe_get_suppression(Constraint, Suppression, 0.0, true).

%% safe_get_suppression(+Constraint, -Suppression, +Default, +Warn)
safe_get_suppression(Constraint, Suppression, Default, Warn) :-
    safe_get_metric(Constraint, suppression_requirement, Suppression, Default, Warn).

/* ============================================================================
   5. BATCH OPERATIONS WITH SAFE RETRIEVAL
   ============================================================================ */

%% safe_get_all_metrics(+Constraint, -Metrics)
%  Retrieves all standard metrics for a constraint.
%  Returns metrics(Extr, Supp, Resist, Category) structure.
safe_get_all_metrics(Constraint, metrics(Extr, Supp, Resist, Category)) :-
    safe_get_extractiveness(Constraint, Extr, 0.0, false),
    safe_get_suppression(Constraint, Supp, 0.0, false),
    safe_get_metric(Constraint, resistance_to_change, Resist, 0.0, false),
    safe_get_category(Constraint, Category, unknown).

%% safe_get_profile_components(+Constraint, -Components)
%  Safely retrieves all components needed for structural signature.
safe_get_profile_components(Constraint, components(Accum, Supp, Resist, BenefDelta, AltPresent)) :-
    safe_get_metric(Constraint, accumulation_speed, Accum, 0.0, false),
    safe_get_metric(Constraint, suppression_requirement, Supp, 0.0, false),
    safe_get_metric(Constraint, resistance_to_change, Resist, 0.0, false),

    % Calculate beneficiary delta safely
    (findall(B, narrative_ontology:veto_actor(B), Beneficiaries)
    -> length(Beneficiaries, BenefDelta)
    ;  BenefDelta = 0),

    % Check for alternatives safely
    (narrative_ontology:intent_viable_alternative(_, _, _)
    -> AltPresent = present
    ;  AltPresent = absent).

/* ============================================================================
   6. DEFENSIVE CONFIG RETRIEVAL
   ============================================================================ */

%% safe_get_config(+ParamName, -Value, +Default)
%  Safely retrieves configuration parameter.
safe_get_config(ParamName, Value, Default) :-
    (v3_1_config:param(ParamName, V)
    -> Value = V
    ;  (Value = Default,
        log(warn, 'Missing config parameter ~w, using default ~w',
            [ParamName, Default]))).

%% require_config(+ParamName, -Value)
%  Retrieves config parameter, failing if missing (strict mode).
require_config(ParamName, Value) :-
    (v3_1_config:param(ParamName, Value)
    -> true
    ;  (log(error, 'REQUIRED config parameter ~w is missing', [ParamName]),
        fail)).

/* ============================================================================
   7. SAFE LIST OPERATIONS
   ============================================================================ */

%% safe_member(+Element, +List, +Default)
%  Checks membership, returning Default if List is not a list.
safe_member(Element, List, Default) :-
    (is_list(List)
    -> member(Element, List)
    ;  (log(warn, 'Expected list but got ~w, using default ~w',
            [List, Default]),
        Element = Default)).

%% safe_length(+List, -Length)
%  Gets list length, returning 0 if not a list.
safe_length(List, Length) :-
    (is_list(List)
    -> length(List, Length)
    ;  (log(warn, 'Expected list but got ~w, returning length 0', [List]),
        Length = 0)).

/* ============================================================================
   8. CONSTRAINT EXISTENCE CHECKS
   ============================================================================ */

%% constraint_exists(+Constraint)
%  Checks if a constraint is defined in the knowledge base.
constraint_exists(Constraint) :-
    narrative_ontology:constraint_claim(Constraint, _).

%% require_constraint(+Constraint)
%  Requires that a constraint exists, failing with error if not.
require_constraint(Constraint) :-
    (constraint_exists(Constraint)
    -> true
    ;  (log(error, 'Constraint ~w does not exist in knowledge base', [Constraint]),
        fail)).

/* ============================================================================
   9. NUMERIC SAFETY HELPERS
   ============================================================================ */

%% safe_divide(+Numerator, +Denominator, -Result, +Default)
%  Safe division with zero-denominator handling.
safe_divide(Num, Denom, Result, Default) :-
    (Denom =\= 0
    -> Result is Num / Denom
    ;  (Result = Default,
        log(warn, 'Division by zero: ~w / ~w, using default ~w',
            [Num, Denom, Default]))).

%% safe_sqrt(+Value, -Result, +Default)
%  Safe square root with negative value handling.
safe_sqrt(Value, Result, Default) :-
    (Value >= 0
    -> Result is sqrt(Value)
    ;  (Result = Default,
        log(warn, 'Square root of negative value ~w, using default ~w',
            [Value, Default]))).

%% clamp(+Value, +Min, +Max, -ClampedValue)
%  Clamps a value to [Min, Max] range.
clamp(Value, Min, Max, ClampedValue) :-
    (Value < Min
    -> (ClampedValue = Min,
        log(debug, 'Value ~w clamped to minimum ~w', [Value, Min]))
    ; Value > Max
    -> (ClampedValue = Max,
        log(debug, 'Value ~w clamped to maximum ~w', [Value, Max]))
    ;  ClampedValue = Value).

/* ============================================================================
   10. DEBUGGING HELPERS
   ============================================================================ */

%% debug_constraint(+Constraint)
%  Prints all available information about a constraint for debugging.
debug_constraint(Constraint) :-
    format('~n=== DEBUG INFO: ~w ===~n', [Constraint]),

    % Check existence
    (constraint_exists(Constraint)
    -> format('  Status: EXISTS~n')
    ;  format('  Status: NOT FOUND~n')),

    % Show claimed type
    (narrative_ontology:constraint_claim(Constraint, Type)
    -> format('  Claimed Type: ~w~n', [Type])
    ;  format('  Claimed Type: NONE~n')),

    % Show metrics
    format('  Metrics:~n'),
    (narrative_ontology:constraint_metric(Constraint, extractiveness, E)
    -> format('    extractiveness: ~2f~n', [E])
    ;  format('    extractiveness: MISSING~n')),

    (narrative_ontology:constraint_metric(Constraint, suppression_requirement, S)
    -> format('    suppression_requirement: ~2f~n', [S])
    ;  format('    suppression_requirement: MISSING~n')),

    (narrative_ontology:constraint_metric(Constraint, resistance_to_change, R)
    -> format('    resistance_to_change: ~2f~n', [R])
    ;  format('    resistance_to_change: MISSING~n')),

    % Show category
    (domain_priors:category_of(Constraint, Cat)
    -> format('  Category: ~w~n', [Cat])
    ;  format('  Category: MISSING~n')),

    format('=================~n~n').

%% trace_metric_retrieval(+Constraint, +Metric)
%  Traces all attempts to retrieve a metric for debugging.
trace_metric_retrieval(Constraint, Metric) :-
    format('~n=== TRACING: ~w.~w ===~n', [Constraint, Metric]),

    (narrative_ontology:constraint_metric(Constraint, Metric, Value)
    -> format('  ✓ Found: ~w~n', [Value])
    ;  format('  ✗ Not found~n')),

    format('  All metrics for ~w:~n', [Constraint]),
    forall(narrative_ontology:constraint_metric(Constraint, M, V),
           format('    ~w: ~w~n', [M, V])),

    format('=================~n~n').
:- module(v3_1_coercion_projection, [
    coercion_vector/3,
    coercion_magnitude/3,
    coercion_gradient/4,
    system_gradient/3,
    time_point_in_interval/2
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(v3_1_config).

% Base Vector
coercion_vector(Level, Time, [A, S, U, R]) :-
    measurement(_, _, accessibility_collapse(Level), Time, A),
    measurement(_, _, stakes_inflation(Level),      Time, S),
    measurement(_, _, suppression(Level),           Time, U),
    measurement(_, _, resistance(Level),            Time, R).

% Magnitude logic
coercion_magnitude(Level, Time, Kappa) :-
    coercion_vector(Level, Time, [A, S, U, R]),
    aggregation_weights(Level, WA, WS, WU, WR),
    Kappa is (WA * A) + (WS * S) + (WU * U) + (WR * R).

% Time points helper (Optimized)
time_point_in_interval(IntervalID, Time) :-
    interval(IntervalID, T_start, T_end),
    % Find all unique times present in the measurement database
    setof(T, is_measurement_time(T), AllTimes),
    member(Time, AllTimes),
    Time >= T_start,
    Time =< T_end,
    !.

% Helper to isolate the cross-module dynamic call
is_measurement_time(T) :-
    narrative_ontology:measurement(_, _, _, T, _).

% Gradient logic (Guarded)
coercion_gradient(Level, IntervalID, T_now, Grad) :-
    interval(IntervalID, _, T_end),
    T_now < T_end,
    % Use setof to find future points but wrap in a conditional to prevent looping
    (   setof(T_next, 
              (time_point_in_interval(IntervalID, T_next), T_next > T_now), 
              FuturePoints)
    ->  FuturePoints = [T_next|_], % Take the immediate next point
        coercion_magnitude(Level, T_now, K_now),
        coercion_magnitude(Level, T_next, K_next),
        Grad is K_next - K_now,
        ! % Prevent backtracking into the setof search
    ;   fail % Explicitly fail if no future points exist in the interval
    ).

% System Gradient (Safe Aggregation)
system_gradient(IntervalID, Time, SysGrad) :-
    findall(WG,
        ( level(L),
          influence_weight(L, W),
          % Ensure coercion_gradient succeeds before calculating
          coercion_gradient(L, IntervalID, Time, G),
          WG is W * G
        ),
        WGList),
    % Guard against empty lists at the end of a timeline
    (   WGList \= []
    ->  sum_list(WGList, SysGrad), !
    ;   SysGrad = 0.0 % Return neutral gradient if no changes are detected
    ).
:- module(v3_1_config, [
    param/2,
    aggregation_weights/5,
    influence_weight/2,
    level/1
]).

/* ================================================================
   1. HIERARCHY DEFINITIONS
   ================================================================ */

%% level(?Level)
% Defines the four analytical levels of the system.
level(structural).
level(organizational).
level(class).
level(individual).

/* ================================================================
   2. COMPONENT WEIGHTS (Alpha)
   Maps components (A, S, U, R) to magnitude (Kappa) per level.
   Formula: $\kappa = (\alpha_A \cdot A) + (\alpha_S \cdot S) + (\alpha_U \cdot U) + (\alpha_R \cdot R)$.
   ================================================================ */

%% aggregation_weights(+Level, -AlphaA, -AlphaS, -AlphaU, -AlphaR)
% Weights are shifted based on level-specific significance.
aggregation_weights(structural,     0.30, 0.20, 0.20, 0.20).
aggregation_weights(organizational, 0.30, 0.40, 0.15, 0.15).
aggregation_weights(class,          0.30, 0.20, 0.30, 0.30).
aggregation_weights(individual,     0.25, 0.25, 0.25, 0.25).

/* ================================================================
   3. INFLUENCE WEIGHTS (w_i)
   Determines how much each level contributes to the System Gradient (Gsys).
   ================================================================ */

%% influence_weight(+Level, -Weight)
influence_weight(structural,     0.40). % Highest impact on system stability.
influence_weight(organizational, 0.30).
influence_weight(class,          0.20).
influence_weight(individual,     0.10).

/* ================================================================
   4. INTENT & DETECTION THRESHOLDS
   Consolidated parameters for the intent_engine and pattern_analysis.
   ================================================================ */

% --- Gradient Thresholds ---
% Minimum change to be considered non-stable.
param(system_gradient_threshold, 0.01).
% Threshold for "Strong" intent classification.
param(system_gradient_strong_threshold, 1.00).

% --- Beneficiary Asymmetry ---
% Min power gain required to be identified as the "Main Beneficiary".
param(beneficiary_gain_min, 0.50).
% Max gain allowed for other classes to maintain "Asymmetry".
param(loser_loss_max_gain, 0.10).

% --- Suppression & Resistance Alignment ---
% Required thresholds for structural-level alignment.
param(structural_suppression_min, 0.70). 
param(structural_resistance_min, 0.70).

% --- Data Integrity ---
% Thresholds for high/medium confidence classification.
param(data_high_threshold, 0.95).
param(data_medium_threshold, 0.75).

/* ================================================================
   5. DEFERENTIAL REALISM (DR) THRESHOLDS
   ================================================================ */

% --- Mountain Boundaries ---
param(mountain_suppression_ceiling, 0.05). % noise floor
param(mountain_snap_back_ceiling,    0.00). 

% --- Rope Boundaries ---
param(rope_extraction_ceiling,       0.35). % Pure coordination
param(rope_suppression_ceiling,      0.15). 

% --- Tangled Rope (Hybrid Zone) ---
% Updated January 2026 based on empirical corpus analysis (168/467 constraints, 36%)
% Hybrid coordination/extraction: provides genuine coordination while extracting asymmetrically
% Extraction range: 0.40-0.90 (above rope ceiling, below pure extraction)
% Suppression floor: 0.50 (requires active enforcement)
param(tangled_rope_extraction_floor, 0.40).  % Above rope ceiling
param(tangled_rope_extraction_ceil,  0.90).  % Below pure extraction ceiling
param(tangled_rope_suppression_floor, 0.50). % Requires active enforcement

% --- Snare Boundaries ---
param(snare_extraction_floor,        0.66). 
param(snare_suppression_floor,       0.46). 
param(noose_load_bearing_threshold,  0.70). 

% --- Piton Boundaries ---
param(piton_extraction_ceiling,     0.10).

/* ================================================================
   6. STRUCTURAL SIGNATURE THRESHOLDS (v3.2)
   These parameters enable detection of constraint ORIGIN
   (natural law vs coordination scaffold vs constructed constraint)
   rather than just constraint METRICS.
   ================================================================ */

% --- Natural Law Signature ---
% Identifies inherent properties of reality (no alternatives possible)
param(natural_law_collapse_min,      0.85).  % Extreme universal inaccessibility
param(natural_law_suppression_max,   0.15).  % No enforcement needed
param(natural_law_resistance_max,    0.15).  % Cannot be resisted

% --- Coordination Scaffold Signature ---
% Identifies successful voluntary standards (alternatives existed)
param(coordination_collapse_min,     0.85).  % Universal adoption achieved
param(coordination_suppression_max,  0.15).  % Voluntary compliance
param(coordination_resistance_max,   0.15).  % Minimal opposition

% --- Constructed Constraint Signature ---
% Identifies institutionally enforced rules (power asymmetries)
param(constructed_suppression_min,   0.20).  % Requires enforcement
param(constructed_resistance_min,    0.20).  % Faces opposition
param(constructed_beneficiary_min,   2).     % Asymmetric gains threshold

% --- Isomorphism Threshold ---
param(isomorphism_threshold, 0.85).
:- module(v3_1_data_repair, [
    repair_interval/1
]).

:- use_module(narrative_ontology).
:- use_module(v3_1_config).
:- use_module(domain_priors). % NEW: Hook into the Epistemic Prior Library
:- use_module(signature_mapper).

% Ensure we can add facts to the ontology's measurement predicate
:- dynamic narrative_ontology:measurement/5.

/* ============================================================
   REPAIR ORCHESTRATOR
   ============================================================ */

%% repair_interval(+IntervalID)
% Audits the measurement vectors for a given interval and repairs gaps
% using domain-specific epistemic priors.
repair_interval(IntervalID) :-
    (   narrative_ontology:interval(IntervalID, T0, Tn)
    ->  format('~n[REPAIR] Auditing vectors for: ~w...~n', [IntervalID]),
        
        % 1. PILLAR REMAPPING: Fix non-standard claims before verification
        forall(narrative_ontology:constraint_claim(C, Type),
               (   signature_mapper:map_custom_pillar(C, Type, Standard),
                   (Type \= Standard -> 
                    retract(narrative_ontology:constraint_claim(C, Type)),
                    assertz(narrative_ontology:constraint_claim(C, Standard)),
                    format('  [FIXED] Remapped ~w: ~w -> ~w~n', [C, Type, Standard])
                   ; true)
               )),

        % 2. VECTOR REPAIR: Impute missing measurements
        forall(v3_1_config:level(L), 
               ( repair_point(L, T0, IntervalID), 
                 repair_point(L, Tn, IntervalID) 
               ))
    ;   format('~n[ERROR] Interval ~w not found.~n', [IntervalID]),
        false
    ).

%% repair_point(+Level, +Time, +IntervalID)
% Iterates through the 4-component coercion vector at a specific time point.
repair_point(Level, Time, IntervalID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components), 
           ensure_metric_exists(Metric, Time, IntervalID)).

%% ensure_metric_exists(+Metric, +Time, +IntervalID)
% Core v3.2 Imputation Logic:
% 1. Checks for existing data.
% 2. Resolves prior based on domain type.
% 3. Flags novelty if the domain is unmapped.
ensure_metric_exists(Metric, Time, IntervalID) :-
    % Look directly into the ontology for existing measurement
    narrative_ontology:measurement(_, _, Metric, Time, _)
    ->  true
    ;   (   % NEW: Fetch prior value instead of hard-coded 0.5
            domain_priors:get_prior(IntervalID, Metric, Value),
            
            % NEW: Surface novelty alert to the LLM/User
            (domain_priors:is_known_domain(IntervalID) -> true ; domain_priors:flag_novelty(IntervalID)),
            
            gensym(repair_m_, SyntheticID),
            % Assert the synthetic fact into the global ontology
            assertz(narrative_ontology:measurement(SyntheticID, IntervalID, Metric, Time, Value)),
            format('  [FIXED] Imputed ~w for ~w at T=~w~n', [Value, Metric, Time])
    ).
:- module(v3_1_stack, [
    initialize_system/0,
    run_scenario/2
]).

% 1. Load Core Knowledge Schema
:- use_module(narrative_ontology).      % Schema & Global Expansion
:- use_module(v3_1_config).             % Grounded Weights & Thresholds

% 2. Load Management & Control (NEW)
:- use_module(scenario_manager, []).    % Lifecycle Controller

% 3. Load Functional Engines (Imported but silenced for namespace safety)
:- use_module(v3_1_coercion_projection, []).
:- use_module(drl_core, []).
:- use_module(drl_modal_logic, []).
:- use_module(drl_audit_core, []).
:- use_module(structural_signatures, []).  % NEW: v3.2 signature detection
:- use_module(v3_1_data_repair, []).
:- use_module(data_verification, []).
:- use_module(pattern_analysis, []).
:- use_module(intent_engine, []).

% 4. Load Diagnostic & UI
:- use_module(constraint_bridge, []).
:- use_module(uke_dr_bridge, []).
:- use_module(report_generator, []).
:- use_module(test_harness, []).

% Add the main prolog directory to the library search path
:- asserta(user:file_search_path(library, '.')).
:- asserta(user:file_search_path(library, '..')).

/* ================================================================
   SCENARIO ALIASES
   ================================================================ */

%% run_scenario(+File, +IntervalID)
%  Convenience alias for the Scenario Manager's load_and_run predicate.
run_scenario(File, IntervalID) :-
    scenario_manager:load_and_run(File, IntervalID).

/* ================================================================
   INITIALIZATION
   ================================================================ */

initialize_system :-
    format('~n====================================================~n'),
    format('   v3.1 STRUCTURAL ANALYSIS STACK INITIALIZED      ~n'),
    format('====================================================~n'),
    format('Namespace:  Consolidated & Grounded (v3.1)~n'),
    format('Control:    Scenario Manager Active~n'),
    format('Usage:      run_scenario(\'file.pl\', interval_id).~n'),
    format('====================================================~n').

:- initialize_system.
/* ================================================================
   v3.2 STRUCTURAL SIGNATURE CONFIGURATION
   
   Add these parameters to v3_1_config.pl to enable signature detection
   ================================================================ */

% NATURAL LAW SIGNATURE THRESHOLDS
% These identify constraints that are inherent properties of reality

param(natural_law_collapse_min, 0.85).
% Minimum accessibility collapse for natural law
% Natural laws affect everyone equally (high collapse)

param(natural_law_suppression_max, 0.15).
% Maximum suppression for natural law
% Natural laws don't require enforcement

param(natural_law_resistance_max, 0.15).
% Maximum resistance for natural law
% Natural laws cannot be effectively resisted

% COORDINATION SCAFFOLD SIGNATURE THRESHOLDS  
% These identify successful voluntary coordination standards

param(coordination_collapse_min, 0.85).
% Minimum accessibility collapse for coordination
% Successful standards achieve universal adoption

param(coordination_suppression_max, 0.15).
% Maximum suppression for coordination
% Coordination scaffolds are adopted voluntarily

param(coordination_resistance_max, 0.15).
% Maximum resistance for coordination
% Successful coordination faces minimal opposition

% CONSTRUCTED CONSTRAINT SIGNATURE THRESHOLDS
% These identify institutionally enforced rules

param(constructed_suppression_min, 0.20).
% Minimum suppression indicating institutional enforcement
% Constructed constraints require active maintenance

param(constructed_resistance_min, 0.20).
% Minimum resistance indicating opposition
% Constructed constraints face pushback

param(constructed_beneficiary_min, 2).
% Minimum beneficiary count for asymmetric gains
% Constructed constraints often benefit specific groups

/* ================================================================
   USAGE NOTES
   
   1. Natural Law vs Coordination Scaffold Distinction:
      Both have extreme collapse + minimal enforcement
      KEY DIFFERENCE: Coordination had viable alternatives
      
   2. Calibration Recommendations:
      - Start with these defaults
      - Monitor false positives in conceptual domains
      - Adjust collapse_min down if too restrictive
      - Adjust suppression_max up if missing constructs
      
   3. Integration with Existing System:
      - Structural signatures OVERRIDE modal classification
      - Use integrate_signature_with_modal/3 in report flow
      - Add signature explanations to audit output
   ================================================================ */
:- use_module(scenario_manager).
:- use_module(data_validation).
:- dynamic test_passed/1.
:- dynamic test_failed/2.
:- working_directory(_, '../prolog/').

run_dynamic_suite :-
    retractall(test_passed(_)),
    retractall(test_failed(_, _)),
    writeln('--- STARTING DYNAMIC VALIDATION ---'),
    test_file('../prolog/testsets/26usc469.pl', '26usc469', '26USC469', 1),
    test_file('../prolog/testsets/26usc469_real_estate_exemption.pl', '26usc469_real_estate_exemption', '26USC469_REAL_ESTATE_EXEMPTION', 2),
    test_file('../prolog/testsets/academic_peer_review_gatekeeping.pl', 'academic_peer_review_gatekeeping', 'ACADEMIC_PEER_REVIEW_GATEKEEPING', 3),
    test_file('../prolog/testsets/academic_tenure_system.pl', 'academic_tenure_system', 'ACADEMIC_TENURE_SYSTEM', 4),
    test_file('../prolog/testsets/adverse_possession.pl', 'adverse_possession_interval', 'ADVERSE_POSSESSION', 5),
    test_file('../prolog/testsets/advice_as_dangerous_gift.pl', 'advice_as_dangerous_gift', 'ADVICE_AS_DANGEROUS_GIFT', 6),
    test_file('../prolog/testsets/ai_cognitive_diversity_arbitrage.pl', 'ai_cognitive_diversity_arbitrage', 'AI_COGNITIVE_DIVERSITY_ARBITRAGE', 7),
    test_file('../prolog/testsets/ai_driven_surveillance_sensor_layer.pl', 'ai_driven_surveillance_sensor_layer', 'AI_DRIVEN_SURVEILLANCE_SENSOR_LAYER', 8),
    test_file('../prolog/testsets/ai_edu_decentralization.pl', 'ai_edu_decentralization', 'AI_EDU_DECENTRALIZATION', 9),
    test_file('../prolog/testsets/ai_evaluators_matching.pl', 'ai_evaluators_matching', 'AI_EVALUATORS_MATCHING', 10),
    test_file('../prolog/testsets/ai_professional_displacement.pl', 'ai_professional_displacement', 'AI_PROFESSIONAL_DISPLACEMENT', 11),
    test_file('../prolog/testsets/ai_task_horizon_reliability.pl', 'ai_task_horizon_reliability', 'AI_TASK_HORIZON_RELIABILITY', 12),
    test_file('../prolog/testsets/algorithmic_bias.pl', 'algorithmic_bias', 'ALGORITHMIC_BIAS', 13),
    test_file('../prolog/testsets/amish_technological_renunciation.pl', 'amish_technological_renunciation', 'AMISH_TECHNOLOGICAL_RENUNCIATION', 14),
    test_file('../prolog/testsets/ancient_grudge_verona.pl', 'ancient_grudge_verona', 'ANCIENT_GRUDGE_VERONA', 15),
    test_file('../prolog/testsets/antifragility.pl', 'antifragility', 'ANTIFRAGILITY', 16),
    test_file('../prolog/testsets/apartheid_nuclear_program.pl', 'apartheid_nuclear_program', 'APARTHEID_NUCLEAR_PROGRAM', 17),
    test_file('../prolog/testsets/arctic_geopolitical_flashpoint.pl', 'arctic_geopolitical_flashpoint', 'ARCTIC_GEOPOLITICAL_FLASHPOINT', 18),
    test_file('../prolog/testsets/arrows_impossibility_theorem.pl', 'arrows_era', 'ARROWS_IMPOSSIBILITY_THEOREM', 19),
    test_file('../prolog/testsets/asce_7_22_seismic_design.pl', 'asce_cycle_22', 'ASCE_7_22_SEISMIC_DESIGN', 20),
    test_file('../prolog/testsets/asshole_filter_2015.pl', 'asshole_filter_2015', 'ASSHOLE_FILTER_2015', 21),
    test_file('../prolog/testsets/astm_d638_tensile_testing.pl', 'industrial_testing_regime', 'ASTM_D638_TENSILE_TESTING', 22),
    test_file('../prolog/testsets/authoritarian_power_paradox.pl', 'authoritarian_power_paradox', 'AUTHORITARIAN_POWER_PARADOX', 23),
    test_file('../prolog/testsets/automatic_enrollment_defaults.pl', 'automatic_enrollment_defaults', 'AUTOMATIC_ENROLLMENT_DEFAULTS', 24),
    test_file('../prolog/testsets/availability_heuristic.pl', 'availability_heuristic', 'AVAILABILITY_HEURISTIC', 25),
    test_file('../prolog/testsets/axiom_of_choice_determinacy.pl', 'ac_era', 'AXIOM_OF_CHOICE_DETERMINACY', 26),
    test_file('../prolog/testsets/banach_fixed_point.pl', 'banach_era', 'BANACH_FIXED_POINT', 27),
    test_file('../prolog/testsets/banach_tarski_paradox.pl', 'banach_tarski_era', 'BANACH_TARSKI_PARADOX', 28),
    test_file('../prolog/testsets/bap_of_pigs_operational_silo.pl', 'operation_zapata_timeline', 'BAP_OF_PIGS_OPERATIONAL_SILO', 29),
    test_file('../prolog/testsets/base_pair_complementarity.pl', 'dna_structure_discovery', 'BASE_PAIR_COMPLEMENTARITY', 30),
    test_file('../prolog/testsets/basel_problem_convergence.pl', 'basel_era', 'BASEL_PROBLEM_CONVERGENCE', 31),
    test_file('../prolog/testsets/bedouin_sedentary_transition.pl', 'bedouin_sedentary_transition', 'BEDOUIN_SEDENTARY_TRANSITION', 32),
    test_file('../prolog/testsets/beief_argument_conclusion.pl', 'belief_argument_conclusion_interval', 'BEIEF_ARGUMENT_CONCLUSION', 33),
    test_file('../prolog/testsets/berkshire_compounding_culture.pl', 'berkshire_compounding_culture', 'BERKSHIRE_COMPOUNDING_CULTURE', 34),
    test_file('../prolog/testsets/big_data_astrophysics_arbitrage.pl', 'big_data_astrophysics_arbitrage', 'BIG_DATA_ASTROPHYSICS_ARBITRAGE', 35),
    test_file('../prolog/testsets/biological_curiosity.pl', 'biological_curiosity', 'BIOLOGICAL_CURIOSITY', 36),
    test_file('../prolog/testsets/bip_narrative_illusion.pl', 'bip_narrative_illusion_interval', 'BIP_NARRATIVE_ILLUSION', 37),
    test_file('../prolog/testsets/birthday_paradox_collison.pl', 'birthday_era', 'BIRTHDAY_PARADOX_COLLISON', 38),
    test_file('../prolog/testsets/blackstone_carried_interest_taxation.pl', 'blackstone_ipo_restructuring', 'BLACKSTONE_CARRIED_INTEREST_TAXATION', 39),
    test_file('../prolog/testsets/blackstone_conflicts_of_interest.pl', 'blackstone_conflict_era', 'BLACKSTONE_CONFLICTS_OF_INTEREST', 40),
    test_file('../prolog/testsets/blackstone_smd_control.pl', 'blackstone_smd_control', 'BLACKSTONE_SMD_CONTROL', 41),
    test_file('../prolog/testsets/blackstone_tax_receiveable_agreement.pl', 'blackstone_tra_life', 'BLACKSTONE_TAX_RECEIVEABLE_AGREEMENT', 42),
    test_file('../prolog/testsets/brain_network_paradigm_2026.pl', 'brain_network_paradigm_2026', 'BRAIN_NETWORK_PARADIGM_2026', 43),
    test_file('../prolog/testsets/broke_vs_poor_grocery_math.pl', 'broke_vs_poor_grocery_math', 'BROKE_VS_POOR_GROCERY_MATH', 44),
    test_file('../prolog/testsets/brouwer_fixed_point.pl', 'brouwer_era', 'BROUWER_FIXED_POINT', 45),
    test_file('../prolog/testsets/buffons_needle_pi_estimation.pl', 'buffon_era', 'BUFFONS_NEEDLE_PI_ESTIMATION', 46),
    test_file('../prolog/testsets/burali_forte_paradox.pl', 'burali_forti_interval', 'BURALI_FORTE_PARADOX', 47),
    test_file('../prolog/testsets/burden_of_proof_engineering_safety.pl', 'challenger_launch_decision', 'BURDEN_OF_PROOF_ENGINEERING_SAFETY', 48),
    test_file('../prolog/testsets/burden_of_proof_legal_criminal.pl', 'criminal_trial_sequence', 'BURDEN_OF_PROOF_LEGAL_CRIMINAL', 49),
    test_file('../prolog/testsets/burden_of_proof_scientific_empirical.pl', 'scientific_revolution_current', 'BURDEN_OF_PROOF_SCIENTIFIC_EMPIRICAL', 50),
    test_file('../prolog/testsets/bushman_money_magic.pl', 'bushman_money_magic_interval', 'BUSHMAN_MONEY_MAGIC', 51),
    test_file('../prolog/testsets/busy_beaver_noncomputability.pl', 'busy_beaver_era', 'BUSY_BEAVER_NONCOMPUTABILITY', 52),
    test_file('../prolog/testsets/cantor_set_topology.pl', 'cantor_set_topology', 'CANTOR_SET_TOPOLOGY', 53),
    test_file('../prolog/testsets/cap_theorem.pl', 'cap_theorem_interval', 'CAP_THEOREM', 54),
    test_file('../prolog/testsets/carbon_credit_markets_2026.pl', 'carbon_credit_markets_2026_int', 'CARBON_CREDIT_MARKETS_2026', 55),
    test_file('../prolog/testsets/carrying_capacity.pl', 'carrying_capacity_interval', 'CARRYING_CAPACITY', 56),
    test_file('../prolog/testsets/castration_longevity_choice.pl', 'castration_longevity_choice', 'CASTRATION_LONGEVITY_CHOICE', 57),
    test_file('../prolog/testsets/cbdc_implementation.pl', 'cbdc_deployment', 'CBDC_IMPLEMENTATION', 58),
    test_file('../prolog/testsets/central_limit_theorem_convergence.pl', 'clt_era', 'CENTRAL_LIMIT_THEOREM_CONVERGENCE', 59),
    test_file('../prolog/testsets/chaitins_omega_undecidability.pl', 'chaitin_era', 'CHAITINS_OMEGA_UNDECIDABILITY', 60),
    test_file('../prolog/testsets/challenger_o_ring_integrity.pl', 'challenger_o_ring_integrity', 'CHALLENGER_O_RING_INTEGRITY', 61),
    test_file('../prolog/testsets/china_critical_mineral_chokepoint.pl', 'china_critical_mineral_chokepoint', 'CHINA_CRITICAL_MINERAL_CHOKEPOINT', 62),
    test_file('../prolog/testsets/china_taiwan_reunification_mandate.pl', 'rejuvenation_centenary_cycle', 'CHINA_TAIWAN_REUNIFICATION_MANDATE', 63),
    test_file('../prolog/testsets/choice_architecture_design.pl', 'rope_design', 'CHOICE_ARCHITECTURE_DESIGN', 64),
    test_file('../prolog/testsets/church_turing_thesis.pl', 'church_turing_era', 'CHURCH_TURING_THESIS', 65),
    test_file('../prolog/testsets/cia_fbi_legal_wall.pl', 'pre_911_silo_regime', 'CIA_FBI_LEGAL_WALL', 66),
    test_file('../prolog/testsets/cinderella_midnight_deadline.pl', 'midnight_deadline_period', 'CINDERELLA_MIDNIGHT_DEADLINE', 67),
    test_file('../prolog/testsets/click_chemistry_paradigm_2026.pl', 'click_chemistry_paradigm_2026', 'CLICK_CHEMISTRY_PARADIGM_2026', 68),
    test_file('../prolog/testsets/climate_attribution_2026.pl', 'climate_attribution_2026', 'CLIMATE_ATTRIBUTION_2026', 69),
    test_file('../prolog/testsets/climate_target_one_point_five.pl', 'climate_target_one_point_five', 'CLIMATE_TARGET_ONE_POINT_FIVE', 70),
    test_file('../prolog/testsets/cloudflare_dual_class_asymmetry.pl', 'cloudflare_dual_class_asymmetry', 'CLOUDFLARE_DUAL_CLASS_ASYMMETRY', 71),
    test_file('../prolog/testsets/cobra_effect.pl', 'cobra_effect', 'COBRA_EFFECT', 72),
    test_file('../prolog/testsets/cognitive_diversity_arbitrage.pl', 'cognitive_diversity_arbitrage', 'COGNITIVE_DIVERSITY_ARBITRAGE', 73),
    test_file('../prolog/testsets/cognitive_induction_gap.pl', 'cognitive_induction_gap', 'COGNITIVE_INDUCTION_GAP', 74),
    test_file('../prolog/testsets/cognitive_mimicry_arbitrage.pl', 'cognitive_mimicry_arbitrage', 'COGNITIVE_MIMICRY_ARBITRAGE', 75),
    test_file('../prolog/testsets/cognitive_surrender_to_system_3.pl', 'system_3_emergence', 'COGNITIVE_SURRENDER_TO_SYSTEM_3', 76),
    test_file('../prolog/testsets/coinbase_crypto_volatility.pl', 'coinbase_ipo_window', 'COINBASE_CRYPTO_VOLATILITY', 77),
    test_file('../prolog/testsets/coinbase_regulatory_uncertainty.pl', 'coinbase_regulatory_uncertainty', 'COINBASE_REGULATORY_UNCERTAINTY', 78),
    test_file('../prolog/testsets/collatz_conjecture_determinism.pl', 'collatz_era', 'COLLATZ_CONJECTURE_DETERMINISM', 79),
    test_file('../prolog/testsets/college_admissions_market.pl', 'college_admissions_market', 'COLLEGE_ADMISSIONS_MARKET', 80),
    test_file('../prolog/testsets/colorado_sbe_decentralization_friction.pl', 'colorado_sbe_decentralization_friction', 'COLORADO_SBE_DECENTRALIZATION_FRICTION', 81),
    test_file('../prolog/testsets/columbia_2026_elections.pl', 'colombia_2026_presidential_election', 'COLUMBIA_2026_ELECTIONS', 82),
    test_file('../prolog/testsets/comitatus_bond.pl', 'comitatus_era', 'COMITATUS_BOND', 83),
    test_file('../prolog/testsets/compounding_logic.pl', 'compounding_logic', 'COMPOUNDING_LOGIC', 84),
    test_file('../prolog/testsets/confirmation_bias.pl', 'confirmation_bias_interval', 'CONFIRMATION_BIAS', 85),
    test_file('../prolog/testsets/constitutional_consecration.pl', 'gettysburg_address_analysis', 'CONSTITUTIONAL_CONSECRATION', 86),
    test_file('../prolog/testsets/constitutional_supremacy.pl', 'constitutional_supremacy', 'CONSTITUTIONAL_SUPREMACY', 87),
    test_file('../prolog/testsets/continuum_hypothesis_undecidability.pl', 'continuum_era', 'CONTINUUM_HYPOTHESIS_UNDECIDABILITY', 88),
    test_file('../prolog/testsets/conversational_dogmas_interuption.pl', 'conversational_dogmas_interruption', 'CONVERSATIONAL_DOGMAS_INTERUPTION', 89),
    test_file('../prolog/testsets/conways_game_of_life_dynamics.pl', 'conway_era', 'CONWAYS_GAME_OF_LIFE_DYNAMICS', 90),
    test_file('../prolog/testsets/copyleft_viral_licensing.pl', 'copyleft_viral_licensing', 'COPYLEFT_VIRAL_LICENSING', 91),
    test_file('../prolog/testsets/copyright_protection.pl', 'copyright_protection', 'COPYRIGHT_PROTECTION', 92),
    test_file('../prolog/testsets/cost_of_observation.pl', 'evolutionary_pressure_01', 'COST_OF_OBSERVATION', 93),
    test_file('../prolog/testsets/countable_infinity_cardinality.pl', 'countable_infinity_cardinality', 'COUNTABLE_INFINITY_CARDINALITY', 94),
    test_file('../prolog/testsets/couples_residency_match.pl', 'couples_residency_match', 'COUPLES_RESIDENCY_MATCH', 95),
    test_file('../prolog/testsets/cow_field_poop.pl', 'cow_field_poop', 'COW_FIELD_POOP', 96),
    test_file('../prolog/testsets/creative_commons_licensing.pl', 'creative_commons_licensing', 'CREATIVE_COMMONS_LICENSING', 97),
    test_file('../prolog/testsets/crispr_genomic_rewrite_2026.pl', 'crispr_genomic_rewrite_2026', 'CRISPR_GENOMIC_REWRITE_2026', 98),
    test_file('../prolog/testsets/cuba_mandatrophic_collapse.pl', 'cuba_blackout_cycle', 'CUBA_MANDATROPHIC_COLLAPSE', 99),
    test_file('../prolog/testsets/cuban_missile_crisis_excomm_delibration.pl', 'thirteen_days_crisis', 'CUBAN_MISSILE_CRISIS_EXCOMM_DELIBRATION', 100),
    test_file('../prolog/testsets/currys_paradox.pl', 'currys_paradox_interval', 'CURRYS_PARADOX', 101),
    test_file('../prolog/testsets/damped_harmonics.pl', 'damped_harmonics', 'DAMPED_HARMONICS', 102),
    test_file('../prolog/testsets/dark_patterns_manipulation.pl', 'dark_patterns_manipulation', 'DARK_PATTERNS_MANIPULATION', 103),
    test_file('../prolog/testsets/dead_sea_effect.pl', 'dead_sea_effect', 'DEAD_SEA_EFFECT', 104),
    test_file('../prolog/testsets/deferential_realism_core.pl', 'dr_recursive_int', 'DEFERENTIAL_REALISM_CORE', 105),
    test_file('../prolog/testsets/digital_credentialing_verification.pl', 'credentialing_shift_2026', 'DIGITAL_CREDENTIALING_VERIFICATION', 106),
    test_file('../prolog/testsets/dionysaic_frenzy.pl', 'dionysiac_frenzy_interval', 'DIONYSAIC_FRENZY', 107),
    test_file('../prolog/testsets/dldr_information_policy.pl', 'dldr_policy_interval', 'DLDR_INFORMATION_POLICY', 108),
    test_file('../prolog/testsets/dunbars_number.pl', 'dunbar_interval', 'DUNBARS_NUMBER', 109),
    test_file('../prolog/testsets/dunning_kruger_effect.pl', 'dunning_kruger_effect', 'DUNNING_KRUGER_EFFECT', 110),
    test_file('../prolog/testsets/e2ee_digital_privacy_2026.pl', 'e2ee_digital_privacy_2026', 'E2EE_DIGITAL_PRIVACY_2026', 111),
    test_file('../prolog/testsets/educational_unbundling_implementation.pl', 'implementation_window_2026', 'EDUCATIONAL_UNBUNDLING_IMPLEMENTATION', 112),
    test_file('../prolog/testsets/electrification_scale_2026.pl', 'electrification_scale_2026', 'ELECTRIFICATION_SCALE_2026', 113),
    test_file('../prolog/testsets/elencher_identity_transformation.pl', 'elencher_identity_transformation', 'ELENCHER_IDENTITY_TRANSFORMATION', 114),
    test_file('../prolog/testsets/empty_tomb_transformation.pl', 'empty_tomb_transformation', 'EMPTY_TOMB_TRANSFORMATION', 115),
    test_file('../prolog/testsets/emrgency_medicine_clinical_guidelines.pl', 'em_practice_v2', 'EMRGENCY_MEDICINE_CLINICAL_GUIDELINES', 116),
    test_file('../prolog/testsets/endowment_effect.pl', 'endowment_interval', 'ENDOWMENT_EFFECT', 117),
    test_file('../prolog/testsets/epigenetics_complexity_2026.pl', 'epigenetics_complexity_2026', 'EPIGENETICS_COMPLEXITY_2026', 118),
    test_file('../prolog/testsets/ergo_autolykos_asic_resistance.pl', 'ergo_autolykos_asic_resistance', 'ERGO_AUTOLYKOS_ASIC_RESISTANCE', 119),
    test_file('../prolog/testsets/ergo_dexy_gold_protocol.pl', 'dexy_gold_interval', 'ERGO_DEXY_GOLD_PROTOCOL', 120),
    test_file('../prolog/testsets/ergo_lets_protocol.pl', 'ergo_lets_interval', 'ERGO_LETS_PROTOCOL', 121),
    test_file('../prolog/testsets/ergo_mixer_protocol.pl', 'ergo_mixer_protocol', 'ERGO_MIXER_PROTOCOL', 122),
    test_file('../prolog/testsets/ergo_nipopows.pl', 'ergo_nipopows', 'ERGO_NIPOPOWS', 123),
    test_file('../prolog/testsets/ergo_rosen_bridge_protocol.pl', 'rosen_bridge_interval', 'ERGO_ROSEN_BRIDGE_PROTOCOL', 124),
    test_file('../prolog/testsets/ergo_sig_usd_protocol.pl', 'sig_usd_interval', 'ERGO_SIG_USD_PROTOCOL', 125),
    test_file('../prolog/testsets/ergo_storage_rent.pl', 'ergo_storage_rent', 'ERGO_STORAGE_RENT', 126),
    test_file('../prolog/testsets/ergo_storage_rent_mechanism.pl', 'ergo_storage_rent_mechanism', 'ERGO_STORAGE_RENT_MECHANISM', 127),
    test_file('../prolog/testsets/ergodic_theorems.pl', 'ergodic_interval', 'ERGODIC_THEOREMS', 128),
    test_file('../prolog/testsets/ergot_grain_poisoning.pl', 'ergot_grain_poisoning_interval', 'ERGOT_GRAIN_POISONING', 129),
    test_file('../prolog/testsets/euler_characteristic_topology.pl', 'euler_era', 'EULER_CHARACTERISTIC_TOPOLOGY', 130),
    test_file('../prolog/testsets/exoplanet_habitability_arbitrage.pl', 'exoplanetary_habitability_arbitrage', 'EXOPLANET_HABITABILITY_ARBITRAGE', 131),
    test_file('../prolog/testsets/exploration_vs_exploitation.pl', 'exploration_vs_exploitation', 'EXPLORATION_VS_EXPLOITATION', 132),
    test_file('../prolog/testsets/extraordinary_narrative_shift.pl', 'extraordinary_narrative_shift', 'EXTRAORDINARY_NARRATIVE_SHIFT', 133),
    test_file('../prolog/testsets/factional_instability.pl', 'federalist_10_analysis', 'FACTIONAL_INSTABILITY', 134),
    test_file('../prolog/testsets/faint_blue_neural_bifurcation.pl', 'faint_blue_neural_bifurcation', 'FAINT_BLUE_NEURAL_BIFURCATION', 135),
    test_file('../prolog/testsets/fair_use_doctrine.pl', 'fair_use_doctrine', 'FAIR_USE_DOCTRINE', 136),
    test_file('../prolog/testsets/family_estrangement_ratio.pl', 'family_estrangement_ratio', 'FAMILY_ESTRANGEMENT_RATIO', 137),
    test_file('../prolog/testsets/family_succession_and_decadence.pl', 'atsumono_period', 'FAMILY_SUCCESSION_AND_DECADENCE', 138),
    test_file('../prolog/testsets/fast_growing_hierarchy.pl', 'fast_growing_hierarchy', 'FAST_GROWING_HIERARCHY', 139),
    test_file('../prolog/testsets/feigenbaum_universality.pl', 'feigenbaum_universality', 'FEIGENBAUM_UNIVERSALITY', 140),
    test_file('../prolog/testsets/finite_pool_of_worry.pl', 'finite_pool_of_worry_interval', 'FINITE_POOL_OF_WORRY', 141),
    test_file('../prolog/testsets/finite_simple_groups_classification.pl', 'cfsg_era', 'FINITE_SIMPLE_GROUPS_CLASSIFICATION', 142),
    test_file('../prolog/testsets/fittss_law.pl', 'fittss_law_interval', 'FITTSS_LAW', 143),
    test_file('../prolog/testsets/fmeca_procedures_1980.pl', 'fmeca_standard_era', 'FMECA_PROCEDURES_1980', 144),
    test_file('../prolog/testsets/four_color_theorem_topological_bound.pl', 'four_color_era', 'FOUR_COLOR_THEOREM_TOPOLOGICAL_BOUND', 145),
    test_file('../prolog/testsets/framing_effect.pl', 'framing_effect_interval', 'FRAMING_EFFECT', 146),
    test_file('../prolog/testsets/frankenstein_creation_hubris.pl', 'frankenstein_creation_hubris', 'FRANKENSTEIN_CREATION_HUBRIS', 147),
    test_file('../prolog/testsets/fundamental_theorem_of_algebra.pl', 'fta_era', 'FUNDAMENTAL_THEOREM_OF_ALGEBRA', 148),
    test_file('../prolog/testsets/gale_shapley.pl', 'gale_shapley', 'GALE_SHAPLEY', 149),
    test_file('../prolog/testsets/galois_theory_symmetry.pl', 'galois_era', 'GALOIS_THEORY_SYMMETRY', 150),
    test_file('../prolog/testsets/gamblers_ruin_stochastic_extinction.pl', 'ruin_era', 'GAMBLERS_RUIN_STOCHASTIC_EXTINCTION', 151),
    test_file('../prolog/testsets/gauss_bonnet_topology.pl', 'gauss_bonnet_era', 'GAUSS_BONNET_TOPOLOGY', 152),
    test_file('../prolog/testsets/generational_replacement_inertia.pl', 'generational_replacement_inertia', 'GENERATIONAL_REPLACEMENT_INERTIA', 153),
    test_file('../prolog/testsets/genetic_algorithms_evolution.pl', 'genetic_algorithms_evolution', 'GENETIC_ALGORITHMS_EVOLUTION', 154),
    test_file('../prolog/testsets/genetic_predisposition.pl', 'genetic_predisposition_interval', 'GENETIC_PREDISPOSITION', 155),
    test_file('../prolog/testsets/germline_regulation_threshold_2026.pl', 'germline_regulation_threshold_2026', 'GERMLINE_REGULATION_THRESHOLD_2026', 156),
    test_file('../prolog/testsets/gig_economy_algorithmic_managment.pl', 'platform_labor_epoch', 'GIG_ECONOMY_ALGORITHMIC_MANAGMENT', 157),
    test_file('../prolog/testsets/gilgamesh_mortality_limit.pl', 'gilgamesh_epic_cycle', 'GILGAMESH_MORTALITY_LIMIT', 158),
    test_file('../prolog/testsets/gita_kurukshetra.pl', 'gita_kurukshetra', 'GITA_KURUKSHETRA', 159),
    test_file('../prolog/testsets/glp1_payload_efficiency_pivot.pl', 'glp1_market_impact_2026', 'GLP1_PAYLOAD_EFFICIENCY_PIVOT', 160),
    test_file('../prolog/testsets/godels_incompleteness_theorems.pl', 'goedel_era', 'GODELS_INCOMPLETENESS_THEOREMS', 161),
    test_file('../prolog/testsets/goldbach_conjecture.pl', 'goldbach_era', 'GOLDBACH_CONJECTURE', 162),
    test_file('../prolog/testsets/golden_handcuffs.pl', 'golden_handcuffs', 'GOLDEN_HANDCUFFS', 163),
    test_file('../prolog/testsets/goodharts_law.pl', 'goodharts_law_interval', 'GOODHARTS_LAW', 164),
    test_file('../prolog/testsets/gradient_descent_optimization.pl', 'gradient_descent_optimization', 'GRADIENT_DESCENT_OPTIMIZATION', 165),
    test_file('../prolog/testsets/graph_coloring_complexity.pl', 'graph_coloring_interval', 'GRAPH_COLORING_COMPLEXITY', 166),
    test_file('../prolog/testsets/greenland_seizure_trade_war.pl', 'greenland_crisis_2026', 'GREENLAND_SEIZURE_TRADE_WAR', 167),
    test_file('../prolog/testsets/greshams_law.pl', 'greshams_law', 'GRESHAMS_LAW', 168),
    test_file('../prolog/testsets/grete_samsa_transition.pl', 'grete_samsa_transition', 'GRETE_SAMSA_TRANSITION', 169),
    test_file('../prolog/testsets/gs1_gln_identification.pl', 'gln_standard_lifecycle', 'GS1_GLN_IDENTIFICATION', 170),
    test_file('../prolog/testsets/gs1_standardized_identification.pl', 'gs1_spec_v25', 'GS1_STANDARDIZED_IDENTIFICATION', 171),
    test_file('../prolog/testsets/halting_problem_undecidability.pl', 'halting_era', 'HALTING_PROBLEM_UNDECIDABILITY', 172),
    test_file('../prolog/testsets/hamiltonian_path_complexity.pl', 'hamiltonian_path_complexity', 'HAMILTONIAN_PATH_COMPLEXITY', 173),
    test_file('../prolog/testsets/hammurabi.pl', 'hammurabi_lex_talionis', 'HAMMURABI', 174),
    test_file('../prolog/testsets/hanlons_razor.pl', 'hanlons_razor', 'HANLONS_RAZOR', 175),
    test_file('../prolog/testsets/happiness_of_others.pl', 'happiness_of_others', 'HAPPINESS_OF_OTHERS', 176),
    test_file('../prolog/testsets/harm_principle_liberty.pl', 'on_liberty_analysis', 'HARM_PRINCIPLE_LIBERTY', 177),
    test_file('../prolog/testsets/hawthorne_effect.pl', 'hawthorne_interval', 'HAWTHORNE_EFFECT', 178),
    test_file('../prolog/testsets/heisenberg_uncertainty.pl', 'heisenberg_interval', 'HEISENBERG_UNCERTAINTY', 179),
    test_file('../prolog/testsets/helsinki_bus_theory.pl', 'helsinki_bus_theory', 'HELSINKI_BUS_THEORY', 180),
    test_file('../prolog/testsets/heuristic_optimization.pl', 'heuristic_optimization', 'HEURISTIC_OPTIMIZATION', 181),
    test_file('../prolog/testsets/hilberts_hotel_infinity.pl', 'hilberts_hotel_infinity', 'HILBERTS_HOTEL_INFINITY', 182),
    test_file('../prolog/testsets/hiv_prep_prevention_2026.pl', 'hiv_prep_prevention_2026', 'HIV_PREP_PREVENTION_2026', 183),
    test_file('../prolog/testsets/hoa_covenants.pl', 'hoa_interval', 'HOA_COVENANTS', 184),
    test_file('../prolog/testsets/hominin_evolutionary_bottleneck.pl', 'hominin_evolutionary_bottleneck', 'HOMININ_EVOLUTIONARY_BOTTLENECK', 185),
    test_file('../prolog/testsets/hydra_game.pl', 'hydra_interval', 'HYDRA_GAME', 186),
    test_file('../prolog/testsets/indexical_relativity_core.pl', 'meta_logic_01', 'INDEXICAL_RELATIVITY_CORE', 187),
    test_file('../prolog/testsets/individual_revolution_autonomy.pl', 'individual_revolution_autonomy', 'INDIVIDUAL_REVOLUTION_AUTONOMY', 188),
    test_file('../prolog/testsets/information_foraging_theory.pl', 'information_foraging_theory', 'INFORMATION_FORAGING_THEORY', 189),
    test_file('../prolog/testsets/inner_model_theory_constraints.pl', 'inner_model_era', 'INNER_MODEL_THEORY_CONSTRAINTS', 190),
    test_file('../prolog/testsets/innovators_dilemma.pl', 'innovators_dilemma_interval', 'INNOVATORS_DILEMMA', 191),
    test_file('../prolog/testsets/institutional_mutation_domestication.pl', 'institutional_mutation_domestication', 'INSTITUTIONAL_MUTATION_DOMESTICATION', 192),
    test_file('../prolog/testsets/insult_wisdom_training.pl', 'insult_wisdom_interval', 'INSULT_WISDOM_TRAINING', 193),
    test_file('../prolog/testsets/integrated_digital_governance_stack.pl', 'meta_stack_convergence', 'INTEGRATED_DIGITAL_GOVERNANCE_STACK', 194),
    test_file('../prolog/testsets/iran_mandatrophic_collapse.pl', 'iran_unrest_2025', 'IRAN_MANDATROPHIC_COLLAPSE', 195),
    test_file('../prolog/testsets/iron_law_of_oligarchy.pl', 'oligarchy_interval', 'IRON_LAW_OF_OLIGARCHY', 196),
    test_file('../prolog/testsets/japanese_energy_scaffold_2025.pl', 'japan_gx_transition', 'JAPANESE_ENERGY_SCAFFOLD_2025', 197),
    test_file('../prolog/testsets/jevons_paradox.pl', 'jevons_interval', 'JEVONS_PARADOX', 198),
    test_file('../prolog/testsets/job_hunt_volume_system_2026.pl', 'job_hunt_volume_system_2026', 'JOB_HUNT_VOLUME_SYSTEM_2026', 199),
    test_file('../prolog/testsets/keltner_relationship_evaluation.pl', 'keltner_relationship_evaluation', 'KELTNER_RELATIONSHIP_EVALUATION', 200),
    test_file('../prolog/testsets/khantivadin_radical_patience.pl', 'khantivadin_patience_interval', 'KHANTIVADIN_RADICAL_PATIENCE', 201),
    test_file('../prolog/testsets/kidney_exchange_market.pl', 'kidney_exchange_market', 'KIDNEY_EXCHANGE_MARKET', 202),
    test_file('../prolog/testsets/kirby_paris_theorem.pl', 'kirby_paris_interval', 'KIRBY_PARIS_THEOREM', 203),
    test_file('../prolog/testsets/kjv_great_awakening.pl', 'kjv_great_awakening', 'KJV_GREAT_AWAKENING', 204),
    test_file('../prolog/testsets/kjv_linguistic_residue.pl', 'kjv_linguistic_residue', 'KJV_LINGUISTIC_RESIDUE', 205),
    test_file('../prolog/testsets/kjv_puritan_new_world_exit.pl', 'kjv_puritan_new_world_exit', 'KJV_PURITAN_NEW_WORLD_EXIT', 206),
    test_file('../prolog/testsets/kjv_textual_authority.pl', 'kjv_textual_authority', 'KJV_TEXTUAL_AUTHORITY', 207),
    test_file('../prolog/testsets/kleene_recursion_theorem.pl', 'kleene_era', 'KLEENE_RECURSION_THEOREM', 208),
    test_file('../prolog/testsets/landscape_of_fear_2026.pl', 'landscape_of_fear_2026', 'LANDSCAPE_OF_FEAR_2026', 209),
    test_file('../prolog/testsets/large_cardinals_foundations.pl', 'large_cardinal_era', 'LARGE_CARDINALS_FOUNDATIONS', 210),
    test_file('../prolog/testsets/law_of_diminishing_returns.pl', 'diminishing_returns_interval', 'LAW_OF_DIMINISHING_RETURNS', 211),
    test_file('../prolog/testsets/layered_brain_processing.pl', 'layered_brain_processing', 'LAYERED_BRAIN_PROCESSING', 212),
    test_file('../prolog/testsets/legacy_system_technical_debt.pl', 'software_lifecycle_r7', 'LEGACY_SYSTEM_TECHNICAL_DEBT', 213),
    test_file('../prolog/testsets/lehman_repo_105.pl', 'lehman_repo_105', 'LEHMAN_REPO_105', 214),
    test_file('../prolog/testsets/liar_paradox.pl', 'liar_paradox_interval', 'LIAR_PARADOX', 215),
    test_file('../prolog/testsets/lindy_effect.pl', 'lindy_effect', 'LINDY_EFFECT', 216),
    test_file('../prolog/testsets/litany_of_the_real.pl', 'litany_of_the_real', 'LITANY_OF_THE_REAL', 217),
    test_file('../prolog/testsets/lln_convergence.pl', 'lln_era', 'LLN_CONVERGENCE', 218),
    test_file('../prolog/testsets/lobs_theorem.pl', 'lobs_theorem_interval', 'LOBS_THEOREM', 219),
    test_file('../prolog/testsets/local_vs_global_optima.pl', 'local_vs_global_optima', 'LOCAL_VS_GLOBAL_OPTIMA', 220),
    test_file('../prolog/testsets/logistic_map_dynamics.pl', 'logistic_map_era', 'LOGISTIC_MAP_DYNAMICS', 221),
    test_file('../prolog/testsets/lorenz_attractor_dynamics.pl', 'lorenz_era', 'LORENZ_ATTRACTOR_DYNAMICS', 222),
    test_file('../prolog/testsets/lowenheim_skolem_theorem.pl', 'lowenheim_skolem_interval', 'LOWENHEIM_SKOLEM_THEOREM', 223),
    test_file('../prolog/testsets/lsd_microdosing_professional_openness.pl', 'lsd_microdosing_professional_openness', 'LSD_MICRODOSING_PROFESSIONAL_OPENNESS', 224),
    test_file('../prolog/testsets/lula_hemisphere_2026.pl', 'lula_hemisphere_2026', 'LULA_HEMISPHERE_2026', 225),
    test_file('../prolog/testsets/magna_carta_liberties.pl', 'magna_carta_liberties', 'MAGNA_CARTA_LIBERTIES', 226),
    test_file('../prolog/testsets/mandatrophic_margin_collapse.pl', 'mandatrophy_cycle', 'MANDATROPHIC_MARGIN_COLLAPSE', 227),
    test_file('../prolog/testsets/mandatrophic_margin_collapse_diagnostic.pl', 'mandatrophy_lifecycle', 'MANDATROPHIC_MARGIN_COLLAPSE_DIAGNOSTIC', 228),
    test_file('../prolog/testsets/marriage_problem.pl', 'optimal_stopping_marriage', 'MARRIAGE_PROBLEM', 229),
    test_file('../prolog/testsets/mars_rovers_navigational_autonomy.pl', 'mars_autonomy_evolution', 'MARS_ROVERS_NAVIGATIONAL_AUTONOMY', 230),
    test_file('../prolog/testsets/martian_signal_latency.pl', 'mariner_to_msl_era', 'MARTIAN_SIGNAL_LATENCY', 231),
    test_file('../prolog/testsets/matching_markets_general.pl', 'matching_markets_general', 'MATCHING_MARKETS_GENERAL', 232),
    test_file('../prolog/testsets/material_tensile_strength.pl', 'tensile_strength_interval', 'MATERIAL_TENSILE_STRENGTH', 233),
    test_file('../prolog/testsets/max_flow.pl', 'max_flow_min_cut', 'MAX_FLOW', 234),
    test_file('../prolog/testsets/mco_unit_system_discontinuity.pl', 'mco_failure_trajectory', 'MCO_UNIT_SYSTEM_DISCONTINUITY', 235),
    test_file('../prolog/testsets/med_diet_consensus_2026.pl', 'med_diet_consensus_2026', 'MED_DIET_CONSENSUS_2026', 236),
    test_file('../prolog/testsets/medical_residency_match.pl', 'medical_residency_match', 'MEDICAL_RESIDENCY_MATCH', 237),
    test_file('../prolog/testsets/medieval_church_hegomony.pl', 'medieval_church_hegemony', 'MEDIEVAL_CHURCH_HEGOMONY', 238),
    test_file('../prolog/testsets/metamorphosis_samsa.pl', 'samsa_transformation_period', 'METAMORPHOSIS_SAMSA', 239),
    test_file('../prolog/testsets/micro_robot_electronics_integration.pl', 'ek_robot_integration_cycle', 'MICRO_ROBOT_ELECTRONICS_INTEGRATION', 240),
    test_file('../prolog/testsets/microbiome_symbiosis.pl', 'microbiome_symbiosis', 'MICROBIOME_SYMBIOSIS', 241),
    test_file('../prolog/testsets/mil_std_461g_emi_control.pl', 'mil_std_461g_era', 'MIL_STD_461G_EMI_CONTROL', 242),
    test_file('../prolog/testsets/mil_std_810f_tailoring.pl', 'mil_std_810f_era', 'MIL_STD_810F_TAILORING', 243),
    test_file('../prolog/testsets/minimax_decision_rule.pl', 'minimax_era', 'MINIMAX_DECISION_RULE', 244),
    test_file('../prolog/testsets/misunderstanding_as_mismatch.pl', 'misunderstanding_as_mismatch', 'MISUNDERSTANDING_AS_MISMATCH', 245),
    test_file('../prolog/testsets/monetary_regime_transition.pl', 'nixon_shock_1971', 'MONETARY_REGIME_TRANSITION', 246),
    test_file('../prolog/testsets/monty_hall_conditional_probability.pl', 'probability_paradox_era', 'MONTY_HALL_CONDITIONAL_PROBABILITY', 247),
    test_file('../prolog/testsets/moores_law.pl', 'moores_law_interval', 'MOORES_LAW', 248),
    test_file('../prolog/testsets/nasa_faster_better_cheaper.pl', 'fbc_era_operations', 'NASA_FASTER_BETTER_CHEAPER', 249),
    test_file('../prolog/testsets/nash_equilibrium_coordination.pl', 'nash_era', 'NASH_EQUILIBRIUM_COORDINATION', 250),
    test_file('../prolog/testsets/necessary_day_job.pl', 'necessary_day_job', 'NECESSARY_DAY_JOB', 251),
    test_file('../prolog/testsets/negative_emissions_arbitrage.pl', 'negative_emissions_arbitrage', 'NEGATIVE_EMISSIONS_ARBITRAGE', 252),
    test_file('../prolog/testsets/net_zero_stabilization.pl', 'net_zero_stabilization', 'NET_ZERO_STABILIZATION', 253),
    test_file('../prolog/testsets/network_effects.pl', 'network_effects', 'NETWORK_EFFECTS', 254),
    test_file('../prolog/testsets/neural_interoperability.pl', 'neural_interoperability', 'NEURAL_INTEROPERABILITY', 255),
    test_file('../prolog/testsets/neurodiversity_spectrum.pl', 'neurodiversity_spectrum', 'NEURODIVERSITY_SPECTRUM', 256),
    test_file('../prolog/testsets/newtons_method_convergence.pl', 'newton_era', 'NEWTONS_METHOD_CONVERGENCE', 257),
    test_file('../prolog/testsets/no_cloning_theorem.pl', 'no_cloning_interval', 'NO_CLONING_THEOREM', 258),
    test_file('../prolog/testsets/noethers_theorem_symmetry.pl', 'noether_era', 'NOETHERS_THEOREM_SYMMETRY', 259),
    test_file('../prolog/testsets/non_compete_agreements.pl', 'non_compete_agreements', 'NON_COMPETE_AGREEMENTS', 260),
    test_file('../prolog/testsets/nonstandard_arithmetic_models.pl', 'skolem_era', 'NONSTANDARD_ARITHMETIC_MODELS', 261),
    test_file('../prolog/testsets/north_korea_songun_mandatrophy.pl', 'dprk_songun_cycle', 'NORTH_KOREA_SONGUN_MANDATROPHY', 262),
    test_file('../prolog/testsets/omelet_perfection_complexity.pl', 'omelet_perfection_interval', 'OMELET_PERFECTION_COMPLEXITY', 263),
    test_file('../prolog/testsets/openbsd_netiquette_protocol.pl', 'openbsd_netiquette_protocol', 'OPENBSD_NETIQUETTE_PROTOCOL', 264),
    test_file('../prolog/testsets/overton_window.pl', 'overton_interval', 'OVERTON_WINDOW', 265),
    test_file('../prolog/testsets/p_vs_np.pl', 'p_vs_np_interval', 'P_VS_NP', 266),
    test_file('../prolog/testsets/parable_fish_turtle.pl', 'parable_fish_turtle', 'PARABLE_FISH_TURTLE', 267),
    test_file('../prolog/testsets/pareto_principle.pl', 'pareto_principle', 'PARETO_PRINCIPLE', 268),
    test_file('../prolog/testsets/parkinsons_law.pl', 'parkinson_interval', 'PARKINSONS_LAW', 269),
    test_file('../prolog/testsets/peano_curve_mapping.pl', 'peano_era', 'PEANO_CURVE_MAPPING', 270),
    test_file('../prolog/testsets/permissive_software_licensing.pl', 'permissive_software_licensing', 'PERMISSIVE_SOFTWARE_LICENSING', 271),
    test_file('../prolog/testsets/personalized_nutritional_arbitrage.pl', 'personalized_nutritional_arbitrage', 'PERSONALIZED_NUTRITIONAL_ARBITRAGE', 272),
    test_file('../prolog/testsets/peter_principle.pl', 'peter_principle', 'PETER_PRINCIPLE', 273),
    test_file('../prolog/testsets/planetary_boundaries.pl', 'planetary_boundaries', 'PLANETARY_BOUNDARIES', 274),
    test_file('../prolog/testsets/planetary_diet_constraint_2026.pl', 'planetary_diet_constraint_2026', 'PLANETARY_DIET_CONSTRAINT_2026', 275),
    test_file('../prolog/testsets/planning_fallacy.pl', 'planning_fallacy_interval', 'PLANNING_FALLACY', 276),
    test_file('../prolog/testsets/platform_cooperativism_governance.pl', 'platform_cooperativism_governance', 'PLATFORM_COOPERATIVISM_GOVERNANCE', 277),
    test_file('../prolog/testsets/poetic_verse_and_past.pl', 'poetic_verse_and_past', 'POETIC_VERSE_AND_PAST', 278),
    test_file('../prolog/testsets/poincare_conjucture.pl', 'poincare_era', 'POINCARE_CONJUCTURE', 279),
    test_file('../prolog/testsets/politeness_face_negotiation.pl', 'politeness_face_negotiation', 'POLITENESS_FACE_NEGOTIATION', 280),
    test_file('../prolog/testsets/postman_survival_protocol.pl', 'postman_survival_interval', 'POSTMAN_SURVIVAL_PROTOCOL', 281),
    test_file('../prolog/testsets/prime_number_theorem.pl', 'pnt_era', 'PRIME_NUMBER_THEOREM', 282),
    test_file('../prolog/testsets/prisoners_dilemma_equilibrium.pl', 'game_theory_era', 'PRISONERS_DILEMMA_EQUILIBRIUM', 283),
    test_file('../prolog/testsets/private_identity_integration.pl', 'private_identity_integration', 'PRIVATE_IDENTITY_INTEGRATION', 284),
    test_file('../prolog/testsets/proof_of_work_consensus.pl', 'proof_of_work_consensus', 'PROOF_OF_WORK_CONSENSUS', 285),
    test_file('../prolog/testsets/public_domain_commons.pl', 'public_domain_commons', 'PUBLIC_DOMAIN_COMMONS', 286),
    test_file('../prolog/testsets/pythagorean_theorem_geometric_constancy.pl', 'pythagorean_era', 'PYTHAGOREAN_THEOREM_GEOMETRIC_CONSTANCY', 287),
    test_file('../prolog/testsets/qualified_immunity.pl', 'qi_interval', 'QUALIFIED_IMMUNITY', 288),
    test_file('../prolog/testsets/quantam_decryption_risk_2026.pl', 'quantum_decryption_risk_2026', 'QUANTAM_DECRYPTION_RISK_2026', 289),
    test_file('../prolog/testsets/quantum_entanglement_protocol.pl', 'interstellar_quantum_link', 'QUANTUM_ENTANGLEMENT_PROTOCOL', 290),
    test_file('../prolog/testsets/quantum_nonlocality_2026.pl', 'quantum_nonlocality_2026', 'QUANTUM_NONLOCALITY_2026', 291),
    test_file('../prolog/testsets/quellcrist_falconer_justice.pl', 'quellcrist_falconer_justice', 'QUELLCRIST_FALCONER_JUSTICE', 292),
    test_file('../prolog/testsets/quine_self_replication.pl', 'quine_era', 'QUINE_SELF_REPLICATION', 293),
    test_file('../prolog/testsets/qwerty_vs_dvorak.pl', 'qwerty_lockin_interval', 'QWERTY_VS_DVORAK', 294),
    test_file('../prolog/testsets/radiologic_diagnostic_threshold.pl', 'radiology_r7', 'RADIOLOGIC_DIAGNOSTIC_THRESHOLD', 295),
    test_file('../prolog/testsets/railway_gauge_standard.pl', 'railway_gauge_standard', 'RAILWAY_GAUGE_STANDARD', 296),
    test_file('../prolog/testsets/reciprocity_laws_math.pl', 'reciprocity_laws_math', 'RECIPROCITY_LAWS_MATH', 297),
    test_file('../prolog/testsets/regulatory_capture.pl', 'capture_interval', 'REGULATORY_CAPTURE', 298),
    test_file('../prolog/testsets/relativity_of_simultaneity.pl', 'relativity_of_simultaneity', 'RELATIVITY_OF_SIMULTANEITY', 299),
    test_file('../prolog/testsets/relativity_physical_invariance.pl', 'relativity_physical_invariance', 'RELATIVITY_PHYSICAL_INVARIANCE', 300),
    test_file('../prolog/testsets/rfc9293_interoperability.pl', 'tcp_rfc9293_interoperability', 'RFC9293_INTEROPERABILITY', 301),
    test_file('../prolog/testsets/rfc9293_state_machine.pl', 'rfc9293_state_machine', 'RFC9293_STATE_MACHINE', 302),
    test_file('../prolog/testsets/rices_theorem_undecidability.pl', 'rices_era', 'RICES_THEOREM_UNDECIDABILITY', 303),
    test_file('../prolog/testsets/rogers_commission_institutional_analysis.pl', 'challenger_post_mortem', 'ROGERS_COMMISSION_INSTITUTIONAL_ANALYSIS', 304),
    test_file('../prolog/testsets/rotation_seven_black_soil.pl', 'rotation_seven_black_soil', 'ROTATION_SEVEN_BLACK_SOIL', 305),
    test_file('../prolog/testsets/rotation_seven_isolation.pl', 'rotation_seven_isolation', 'ROTATION_SEVEN_ISOLATION', 306),
    test_file('../prolog/testsets/rotation_seven_kubo_ranking.pl', 'rotation_seven_kubo_ranking', 'ROTATION_SEVEN_KUBO_RANKING', 307),
    test_file('../prolog/testsets/rotmigration_decision_threshold.pl', 'migration_theory_review', 'ROTMIGRATION_DECISION_THRESHOLD', 308),
    test_file('../prolog/testsets/royal_navy_middle_east_withdrawal.pl', 'rn_withdrawal_cycle', 'ROYAL_NAVY_MIDDLE_EAST_WITHDRAWAL', 309),
    test_file('../prolog/testsets/rules_based_international_order.pl', 'rules_based_international_order', 'RULES_BASED_INTERNATIONAL_ORDER', 310),
    test_file('../prolog/testsets/russells_paradox_self_reference.pl', 'russell_era', 'RUSSELLS_PARADOX_SELF_REFERENCE', 311),
    test_file('../prolog/testsets/russian_war_cannibalization.pl', 'russia_cannibalization_cycle', 'RUSSIAN_WAR_CANNIBALIZATION', 312),
    test_file('../prolog/testsets/s1_airbnb.pl', 'airbnb_ipo_era', 'S1_AIRBNB', 313),
    test_file('../prolog/testsets/s1_visa.pl', 'visa_ipo_window', 'S1_VISA', 314),
    test_file('../prolog/testsets/s1_visa_judgment_sharing_agreement.pl', 'visa_litigation_ringfencing', 'S1_VISA_JUDGMENT_SHARING_AGREEMENT', 315),
    test_file('../prolog/testsets/sadhu_integrity_protocol.pl', 'sadhu_integrity_protocol', 'SADHU_INTEGRITY_PROTOCOL', 316),
    test_file('../prolog/testsets/sapir_whorf_hypothesis.pl', 'sapir_whorf_interval', 'SAPIR_WHORF_HYPOTHESIS', 317),
    test_file('../prolog/testsets/sat_csp_complexity.pl', 'sat_csp_interval', 'SAT_CSP_COMPLEXITY', 318),
    test_file('../prolog/testsets/scurvy_maritime_extraction.pl', 'scurvy_maritime_interval', 'SCURVY_MARITIME_EXTRACTION', 319),
    test_file('../prolog/testsets/self_surpassing_superman.pl', 'zarathustra_hazar', 'SELF_SURPASSING_SUPERMAN', 320),
    test_file('../prolog/testsets/shannon_entropy_limit.pl', 'shannon_entropy_limit', 'SHANNON_ENTROPY_LIMIT', 321),
    test_file('../prolog/testsets/shitty_feedback_handling.pl', 'shitty_feedback_handling', 'SHITTY_FEEDBACK_HANDLING', 322),
    test_file('../prolog/testsets/shobies_existential_commitment.pl', 'shobies_existential_commitment', 'SHOBIES_EXISTENTIAL_COMMITMENT', 323),
    test_file('../prolog/testsets/silicon_lexicon_overload.pl', 'silicon_lexicon_overload', 'SILICON_LEXICON_OVERLOAD', 324),
    test_file('../prolog/testsets/skills_based_hiring.pl', 'skills_based_hiring', 'SKILLS_BASED_HIRING', 325),
    test_file('../prolog/testsets/skolems_paradox.pl', 'skolems_paradox_interval', 'SKOLEMS_PARADOX', 326),
    test_file('../prolog/testsets/sludge_bureaucratic_friction.pl', 'sludge_bureaucratic_friction', 'SLUDGE_BUREAUCRATIC_FRICTION', 327),
    test_file('../prolog/testsets/smartphone_ubiquity.pl', 'smartphone_ubiquity', 'SMARTPHONE_UBIQUITY', 328),
    test_file('../prolog/testsets/social_credit_architecture.pl', 'scs_operational_2026', 'SOCIAL_CREDIT_ARCHITECTURE', 329),
    test_file('../prolog/testsets/social_loafing.pl', 'social_loafing_interval', 'SOCIAL_LOAFING', 330),
    test_file('../prolog/testsets/social_media_participation_threshold.pl', 'social_media_2025_cycle', 'SOCIAL_MEDIA_PARTICIPATION_THRESHOLD', 331),
    test_file('../prolog/testsets/social_narrative_casting.pl', 'social_narrative_casting', 'SOCIAL_NARRATIVE_CASTING', 332),
    test_file('../prolog/testsets/solar_system_weirdness.pl', 'solar_system_weirdness', 'SOLAR_SYSTEM_WEIRDNESS', 333),
    test_file('../prolog/testsets/somatic_focusing_awareness.pl', 'somatic_focusing_awareness', 'SOMATIC_FOCUSING_AWARENESS', 334),
    test_file('../prolog/testsets/sorites_paradox.pl', 'sorites_interval', 'SORITES_PARADOX', 335),
    test_file('../prolog/testsets/south_china_sea_arbitration_2016_2026.pl', 'scs_legal_era', 'SOUTH_CHINA_SEA_ARBITRATION_2016_2026', 336),
    test_file('../prolog/testsets/square_cube_law.pl', 'square_cube_interval', 'SQUARE_CUBE_LAW', 337),
    test_file('../prolog/testsets/st_petersburg_paradox.pl', 'st_petersburg_era', 'ST_PETERSBURG_PARADOX', 338),
    test_file('../prolog/testsets/stable_marriage_coordination.pl', 'matching_theory_era', 'STABLE_MARRIAGE_COORDINATION', 339),
    test_file('../prolog/testsets/starwars_evolutionary_mutation.pl', 'galactic_selection_event', 'STARWARS_EVOLUTIONARY_MUTATION', 340),
    test_file('../prolog/testsets/statecraft_virtu.pl', 'statecraft_virtu_analysis', 'STATECRAFT_VIRTU', 341),
    test_file('../prolog/testsets/steinmetz_valuation_asymmetry.pl', 'steinmetz_valuation_asymmetry', 'STEINMETZ_VALUATION_ASYMMETRY', 342),
    test_file('../prolog/testsets/stoic_logos_governance.pl', 'stoic_logos_governance', 'STOIC_LOGOS_GOVERNANCE', 343),
    test_file('../prolog/testsets/strange_attractor_dynamics.pl', 'strange_attractor_dynamics', 'STRANGE_ATTRACTOR_DYNAMICS', 344),
    test_file('../prolog/testsets/sts86_ascent_checklist.pl', 'sts86_ascent_checklist', 'STS86_ASCENT_CHECKLIST', 345),
    test_file('../prolog/testsets/sturgeons_law.pl', 'sturgeon_interval', 'STURGEONS_LAW', 346),
    test_file('../prolog/testsets/suanne_coup_of_peace.pl', 'suanne_coup_of_peace', 'SUANNE_COUP_OF_PEACE', 347),
    test_file('../prolog/testsets/suanne_face_restoration.pl', 'suanne_face_restoration', 'SUANNE_FACE_RESTORATION', 348),
    test_file('../prolog/testsets/sunk_cost_fallacy.pl', 'sunk_cost_interval', 'SUNK_COST_FALLACY', 349),
    test_file('../prolog/testsets/suslin_hypothesis_undecidability.pl', 'suslin_era', 'SUSLIN_HYPOTHESIS_UNDECIDABILITY', 350),
    test_file('../prolog/testsets/sylow_theorems_group_theory.pl', 'sylow_era', 'SYLOW_THEOREMS_GROUP_THEORY', 351),
    test_file('../prolog/testsets/taiwan_existential_sovereignty.pl', 'taiwan_status_quo_cycle', 'TAIWAN_EXISTENTIAL_SOVEREIGNTY', 352),
    test_file('../prolog/testsets/taiwan_strait_hegemony_shift.pl', 'hegemony_transition_window', 'TAIWAN_STRAIT_HEGEMONY_SHIFT', 353),
    test_file('../prolog/testsets/tarski_undefinability.pl', 'tarski_interval', 'TARSKI_UNDEFINABILITY', 354),
    test_file('../prolog/testsets/teaching_horses_to_sing.pl', 'teaching_horses_to_sing_interval', 'TEACHING_HORSES_TO_SING', 355),
    test_file('../prolog/testsets/technological_provenance_arbitrage.pl', 'technological_provenance_arbitrage', 'TECHNOLOGICAL_PROVENANCE_ARBITRAGE', 356),
    test_file('../prolog/testsets/temporal_scale_arbitrage.pl', 'temporal_scale_arbitrage', 'TEMPORAL_SCALE_ARBITRAGE', 357),
    test_file('../prolog/testsets/texas_hispanic_political_pivot.pl', 'tx_pivot_window_2026', 'TEXAS_HISPANIC_POLITICAL_PIVOT', 358),
    test_file('../prolog/testsets/the_bacchae_madness_protocol.pl', 'theban_dionysian_conflict', 'THE_BACCHAE_MADNESS_PROTOCOL', 359),
    test_file('../prolog/testsets/the_calm_protocol_suppression.pl', 'the_calm_expedition_window', 'THE_CALM_PROTOCOL_SUPPRESSION', 360),
    test_file('../prolog/testsets/the_churn_systemic_upheaval.pl', 'the_churn_systemic_upheaval', 'THE_CHURN_SYSTEMIC_UPHEAVAL', 361),
    test_file('../prolog/testsets/the_wall_procedural_barrier.pl', 'the_wall_procedural_barrier', 'THE_WALL_PROCEDURAL_BARRIER', 362),
    test_file('../prolog/testsets/theory_of_visitors.pl', 'theory_of_visitors', 'THEORY_OF_VISITORS', 363),
    test_file('../prolog/testsets/thermodynamics_entropy.pl', 'thermodynamics_entropy_interval', 'THERMODYNAMICS_ENTROPY', 364),
    test_file('../prolog/testsets/three_body_unpredicability.pl', 'celestial_mechanics_era', 'THREE_BODY_UNPREDICABILITY', 365),
    test_file('../prolog/testsets/toxic_social_infection.pl', 'toxic_social_infection_interval', 'TOXIC_SOCIAL_INFECTION', 366),
    test_file('../prolog/testsets/tractarian_logic_limit.pl', 'tractarian_logic_limit', 'TRACTARIAN_LOGIC_LIMIT', 367),
    test_file('../prolog/testsets/trade_secret_law.pl', 'trade_secret_law', 'TRADE_SECRET_LAW', 368),
    test_file('../prolog/testsets/tragedy_of_the_commons.pl', 'tragedy_of_the_commons', 'TRAGEDY_OF_THE_COMMONS', 369),
    test_file('../prolog/testsets/transformer_self_attention.pl', 'transformer_self_attention', 'TRANSFORMER_SELF_ATTENTION', 370),
    test_file('../prolog/testsets/transient_event_detection.pl', 'transient_event_detection', 'TRANSIENT_EVENT_DETECTION', 371),
    test_file('../prolog/testsets/traveling_salesperson_problem.pl', 'traveling_salesperson_problem', 'TRAVELING_SALESPERSON_PROBLEM', 372),
    test_file('../prolog/testsets/trojan_war_spoils.pl', 'trojan_collapse_interval', 'TROJAN_WAR_SPOILS', 373),
    test_file('../prolog/testsets/trump_making_china_great_2026.pl', 'post_trump_return', 'TRUMP_MAKING_CHINA_GREAT_2026', 374),
    test_file('../prolog/testsets/trumps_second_term_authoritarianism_2026.pl', 'trump_ii_year_one', 'TRUMPS_SECOND_TERM_AUTHORITARIANISM_2026', 375),
    test_file('../prolog/testsets/udhr_1946.pl', 'un_era', 'UDHR_1946', 376),
    test_file('../prolog/testsets/ulysses_chp01.pl', 'telemachus_morning', 'ULYSSES_CHP01', 377),
    test_file('../prolog/testsets/ulysses_chp02.pl', 'nestor_afternoon', 'ULYSSES_CHP02', 378),
    test_file('../prolog/testsets/ulysses_chp03.pl', 'proteus_strand_walk', 'ULYSSES_CHP03', 379),
    test_file('../prolog/testsets/ulysses_chp04.pl', 'bloom_kosher_transgression', 'ULYSSES_CHP04', 380),
    test_file('../prolog/testsets/ulysses_chp05.pl', 'bloom_secret_correspondence', 'ULYSSES_CHP05', 381),
    test_file('../prolog/testsets/ulysses_chp06.pl', 'bloom_exclusion_interval', 'ULYSSES_CHP06', 382),
    test_file('../prolog/testsets/ulysses_chp07.pl', 'bloom_aeolus_interval', 'ULYSSES_CHP07', 383),
    test_file('../prolog/testsets/ulysses_chp08.pl', 'lestrygonian_metabolism_chp8_interval', 'ULYSSES_CHP08', 384),
    test_file('../prolog/testsets/ulysses_chp09.pl', 'stephen_shakespeare_ghost', 'ULYSSES_CHP09', 385),
    test_file('../prolog/testsets/ulysses_chp10.pl', 'the_viceregal_cavalcade', 'ULYSSES_CHP10', 386),
    test_file('../prolog/testsets/ulysses_chp11.pl', 'bloom_sirens_interval', 'ULYSSES_CHP11', 387),
    test_file('../prolog/testsets/ulysses_chp12.pl', 'bloom_exclusion_id', 'ULYSSES_CHP12', 388),
    test_file('../prolog/testsets/ulysses_chp13.pl', 'gerty_bloom_interval', 'ULYSSES_CHP13', 389),
    test_file('../prolog/testsets/ulysses_chp14.pl', 'gestation_wombfruit_id', 'ULYSSES_CHP14', 390),
    test_file('../prolog/testsets/ulysses_chp15.pl', 'nighttown_vigil_id', 'ULYSSES_CHP15', 391),
    test_file('../prolog/testsets/ulysses_chp16.pl', 'bloom_samaritan_id', 'ULYSSES_CHP16', 392),
    test_file('../prolog/testsets/ulysses_chp17.pl', 'bloom_ithaca_interval', 'ULYSSES_CHP17', 393),
    test_file('../prolog/testsets/ulysses_chp18.pl', 'molly_affirmation_id', 'ULYSSES_CHP18', 394),
    test_file('../prolog/testsets/unclos_2026.pl', 'unclos_era', 'UNCLOS_2026', 395),
    test_file('../prolog/testsets/union_protection_underperformance.pl', 'labor_management_conflict_r1', 'UNION_PROTECTION_UNDERPERFORMANCE', 396),
    test_file('../prolog/testsets/universal_mathematics_communication.pl', 'scientific_consensus_period', 'UNIVERSAL_MATHEMATICS_COMMUNICATION', 397),
    test_file('../prolog/testsets/us_suburban_zoning_2025.pl', 'us_suburban_zoning_2025', 'US_SUBURBAN_ZONING_2025', 398),
    test_file('../prolog/testsets/us_two_party_duopoly.pl', 'us_two_party_duopoly', 'US_TWO_PARTY_DUOPOLY', 399),
    test_file('../prolog/testsets/utopia_apocalypse_fragility.pl', 'utopia_apocalypse_fragility', 'UTOPIA_APOCALYPSE_FRAGILITY', 400),
    test_file('../prolog/testsets/van_der_waerden_theorem.pl', 'van_der_waerden_interval', 'VAN_DER_WAERDEN_THEOREM', 401),
    test_file('../prolog/testsets/viral_transmission_rates.pl', 'viral_transmission_rates', 'VIRAL_TRANSMISSION_RATES', 402),
    test_file('../prolog/testsets/weber_fechner_law.pl', 'weber_fechner_law', 'WEBER_FECHNER_LAW', 403),
    test_file('../prolog/testsets/whitehead_problem_undecidability.pl', 'whitehead_era', 'WHITEHEAD_PROBLEM_UNDECIDABILITY', 404),
    test_file('../prolog/testsets/wikipedia_crowdsourcing_2026.pl', 'wikipedia_crowdsourcing_2026', 'WIKIPEDIA_CROWDSOURCING_2026', 405),
    test_file('../prolog/testsets/wikipedia_notability_requirement_2026.pl', 'wikipedia_notability_requirement_2026', 'WIKIPEDIA_NOTABILITY_REQUIREMENT_2026', 406),
    test_file('../prolog/testsets/winners_curse.pl', 'winners_curse', 'WINNERS_CURSE', 407),
    test_file('../prolog/testsets/xi_mao_ideological_centralization.pl', 'xi_mao_ideological_centralization', 'XI_MAO_IDEOLOGICAL_CENTRALIZATION', 408),
    test_file('../prolog/testsets/zipfs_law.pl', 'zipfs_law', 'ZIPFS_LAW', 409),
    count_and_report,
    run_data_validation.

run_data_validation :-
    writeln(''),
    writeln('--- RUNNING DATA QUALITY VALIDATION ---'),
    data_validation:validate_all.

test_file(Path, ID, Label, N) :-
    format('~n[~w] DOMAIN: ~w (~w)~n', [N, Label, Path]),
    (   catch(load_and_run(Path, ID), E, (assertz(test_failed(Path, E)), format('[FAIL] Exception: ~w~n', [E]), fail))
    ->  assertz(test_passed(Path)),
        report_generator:generate_llm_feedback(ID)
    ;   assertz(test_failed(Path, audit_failed)),
        report_generator:generate_llm_feedback(ID)
    ),
    !. 

count_and_report :-
    findall(P, test_passed(P), Ps), length(Ps, PC), findall(F, test_failed(F,_), Fs), length(Fs, FC),
    format('~nDONE: ~w Passed, ~w Failed~n', [PC, FC]).
% ============================================================================
% CONSTRAINT STORY: zipfs_law
% Status: [RESOLVED MANDATROPHY]
% ============================================================================
% Generated: 2026-01-22
% Model: Gemini 2.0 Flash
% Source: George Kingsley Zipf (1949) / Quantitative Linguistics
% ============================================================================

:- module(constraint_zipfs_law, []).

:- use_module(constraint_indexing).
:- use_module(domain_priors).
:- use_module(narrative_ontology).

% --- Namespace Hooks (Required for 2026 DR-Audit Suite) ---
:- multifile 
    domain_priors:base_extractiveness/2,
    domain_priors:suppression_score/2,
    domain_priors:category_of/2,
    domain_priors:requires_active_enforcement/1,
    constraint_indexing:constraint_classification/3,
    constraint_beneficiary/2,
    constraint_victim/2.

/* ==========================================================================
   1. NARRATIVE CONTEXT
   ========================================================================== */

/**
 * CONSTRAINT IDENTIFICATION
 * * constraint_id: zipfs_law
 * human_readable: Zipf's Law (The Power Law of Information)
 * domain: technological/social
 * temporal_scope: Permanent (Universal Law of Information)
 * spatial_scope: Global (Natural Language and Large Data)
 * * SUMMARY:
 * Zipf's Law states that word frequency is inversely proportional to rank. 
 * While it provides a "Rope" for algorithmic efficiency (indexing/compression), 
 * it asymmetrically extracts attention from the "Long Tail" of minority 
 * content, creating a "Snare" of obscurity for niche participants.
 */

/* ==========================================================================
   2. CORE SYSTEM INTEGRATION (The "Reality" Layer)
   ========================================================================== */

% ID Binding - Mandatory for 2026 DR-Audit Suite
narrative_ontology:interval(zipfs_law, 0, 10).
narrative_ontology:constraint_claim(zipfs_law, tangled_rope).

% Base extractiveness (0.65): Zipf's Law extracts visibility from the tail 
% and concentrates it in the "Head".
domain_priors:base_extractiveness(zipfs_law, 0.65).

% Suppression (0.70): The power-law suppresses "Equal Distribution" alternatives 
% in complex communicative systems.
domain_priors:suppression_score(zipfs_law, 0.70).
domain_priors:requires_active_enforcement(zipfs_law).

% Mandatory Asymmetry Hooks
constraint_beneficiary(zipfs_law, search_platform_monopolies).
constraint_victim(zipfs_law, niche_linguistic_groups).

/* ==========================================================================
   3. INDEXED CLASSIFICATIONS (Perspectival Truth)
   ========================================================================== */

% INDIVIDUAL: Experiences the 'Long Tail' as a Snare of obscurity.
constraint_indexing:constraint_classification(zipfs_law, snare, 
    context(agent_power(individual_powerless), time_horizon(immediate), exit_options(trapped), spatial_scope(local))).

% INSTITUTIONAL: Uses the distribution as a Rope for computational efficiency.
constraint_indexing:constraint_classification(zipfs_law, rope, 
    context(agent_power(institutional), time_horizon(generational), exit_options(mobile), spatial_scope(global))).

% ANALYTICAL: Recognizes the Tangled Rope nature of the power law.
constraint_indexing:constraint_classification(zipfs_law, tangled_rope, 
    context(agent_power(analytical), time_horizon(historical), exit_options(analytical), spatial_scope(global))).

/* ==========================================================================
   4. TESTS (What We Learn About Constraints)
   ========================================================================== */

:- begin_tests(zipfs_law_tests).

test(multi_perspective_variance) :-
    % Creator (Snare) vs Engineer (Rope) vs Analyst (Tangled Rope)
    constraint_indexing:constraint_classification(zipfs_law, T1, context(individual_powerless, immediate, constrained, local)),
    constraint_indexing:constraint_classification(zipfs_law, T2, context(institutional, biographical, mobile, global)),
    constraint_indexing:constraint_classification(zipfs_law, T3, context(analytical, historical, analytical, global)),
    T1 \= T2, T2 \= T3, T1 \= T3.

test(power_extractiveness_variance) :-
    ContextPowerless = context(individual_powerless, immediate, constrained, local),
    ContextInstitutional = context(institutional, biographical, mobile, global),
    constraint_indexing:extractiveness_for_agent(zipfs_law, ContextPowerless, Score1),
    constraint_indexing:extractiveness_for_agent(zipfs_law, ContextInstitutional, Score2),
    Score1 > Score2.

:- end_tests(zipfs_law_tests).

/* ==========================================================================
   5. MODEL INTERPRETATION (Commentary)
   ========================================================================== */

/**
 * LLM GENERATION NOTES
 * 1. TANGLED ROPE RATIONALE: Zipf's Law is the ultimate structural hybrid. 
 * It enables the coordination of large-scale information (Rope) but extracts 
 * the visibility of the majority to subsidize the elite few (Snare).
 * 2. MANDATROPHY RESOLUTION: The extraction score (0.50) isn't "predatory" by 
 * intent but functions as a Snare for niche subjects because of the 
 * mathematical inevitability of the attention bottleneck.
 * 3. OMEGA:
 * omega_variable(algorithmic_intervention,
 * "Can algorithmic reranking untangle the extraction of Zipf's Law?",
 * resolution_mechanism("Long-term audit of recommendation engine diversity vs. power-law decay"),
 * impact("If yes: Tangled Rope becomes Rope. If no: It remains a Snare for the tail."),
 * confidence_without_resolution(medium)).
 */

/* ==========================================================================
   6. OMEGA VARIABLES (Ω) - IRREDUCIBLE UNCERTAINTIES
   ========================================================================== */
/**
 * OMEGA IDENTIFICATION
 *
 * Mandatory Omega for high-extraction constraints.
 */
% Resolving the Perspectival Gap identified in Audit 410
omega_variable(
    omega_extraction_blindness_zipfs_law,
    'Is the attention concentration a byproduct of information physics (Mountain) or algorithmic reinforcement (Snare)?',
    resolution_mechanism('Audit of ranking variance across diverse platform architectures'),
    impact('If physics: Mountain. If reinforcement: Snare/Tangled Rope.'),
    confidence_without_resolution(medium)
).

/* ==========================================================================
   END OF CONSTRAINT STORY
   ========================================================================== */
