:- module(coercion_projection, [
    coercion_vector/3,
    coercion_magnitude/3,
    coercion_gradient/4,
    system_gradient/3,
    time_point_in_interval/2
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(config).

% Base Vector
coercion_vector(Level, Time, [A, S, U, R]) :-
    measurement(_, _, accessibility_collapse(Level), Time, A),
    measurement(_, _, stakes_inflation(Level),      Time, S),
    measurement(_, _, suppression(Level),           Time, U),
    measurement(_, _, resistance(Level),            Time, R).

% Magnitude logic
coercion_magnitude(Level, Time, Kappa) :-
    coercion_vector(Level, Time, [A, S, U, R]),
    aggregation_weights(Level, WA, WS, WU, WR),
    Kappa is (WA * A) + (WS * S) + (WU * U) + (WR * R).

% Time points helper (Optimized)
time_point_in_interval(IntervalID, Time) :-
    interval(IntervalID, T_start, T_end),
    % Find all unique times present in the measurement database
    setof(T, is_measurement_time(T), AllTimes),
    member(Time, AllTimes),
    Time >= T_start,
    Time =< T_end,
    !.

% Helper to isolate the cross-module dynamic call
is_measurement_time(T) :-
    narrative_ontology:measurement(_, _, _, T, _).

% Gradient logic (Guarded)
coercion_gradient(Level, IntervalID, T_now, Grad) :-
    interval(IntervalID, _, T_end),
    T_now < T_end,
    % Use setof to find future points but wrap in a conditional to prevent looping
    (   setof(T_next, 
              (time_point_in_interval(IntervalID, T_next), T_next > T_now), 
              FuturePoints)
    ->  FuturePoints = [T_next|_], % Take the immediate next point
        coercion_magnitude(Level, T_now, K_now),
        coercion_magnitude(Level, T_next, K_next),
        Grad is K_next - K_now,
        ! % Prevent backtracking into the setof search
    ;   fail % Explicitly fail if no future points exist in the interval
    ).

% System Gradient (Safe Aggregation)
system_gradient(IntervalID, Time, SysGrad) :-
    findall(WG,
        ( level(L),
          influence_weight(L, W),
          % Ensure coercion_gradient succeeds before calculating
          coercion_gradient(L, IntervalID, Time, G),
          WG is W * G
        ),
        WGList),
    % Guard against empty lists at the end of a timeline
    (   WGList \= []
    ->  sum_list(WGList, SysGrad), !
    ;   SysGrad = 0.0 % Return neutral gradient if no changes are detected
    ).
:- module(config, [
    param/2,
    aggregation_weights/5,
    influence_weight/2,
    level/1
]).

:- multifile param/2.
:- dynamic param/2.

/* ================================================================
   1. HIERARCHY DEFINITIONS
   ================================================================ */

%% level(?Level)
% Defines the four analytical levels of the system.
level(structural).
level(organizational).
level(class).
level(individual).

% --- General Metric Naming (for dynamic dispatch) ---
param(suppression_metric_name, suppression_requirement).
param(extractiveness_metric_name, base_extractiveness).
param(temporal_metric_name, time_horizon).
param(exit_metric_name, exit_options).
param(power_metric_name, agent_power).
param(scope_metric_name, spatial_scope).
param(theater_metric_name, theater_ratio).

/* ================================================================
   2. COMPONENT WEIGHTS (Alpha)
   Maps components (A, S, U, R) to magnitude (Kappa) per level.
   Formula: $\kappa = (\alpha_A \cdot A) + (\alpha_S \cdot S) + (\alpha_U \cdot U) + (\alpha_R \cdot R)$.
   ================================================================ */

%% aggregation_weights(+Level, -AlphaA, -AlphaS, -AlphaU, -AlphaR)
% Weights are shifted based on level-specific significance.
aggregation_weights(structural,     0.30, 0.20, 0.20, 0.20).
aggregation_weights(organizational, 0.30, 0.40, 0.15, 0.15).
aggregation_weights(class,          0.30, 0.20, 0.30, 0.30).
aggregation_weights(individual,     0.25, 0.25, 0.25, 0.25).

/* ================================================================
   3. INFLUENCE WEIGHTS (w_i)
   Determines how much each level contributes to the System Gradient (Gsys).
   ================================================================ */

%% influence_weight(+Level, -Weight)
influence_weight(structural,     0.40). % Highest impact on system stability.
influence_weight(organizational, 0.30).
influence_weight(class,          0.20).
influence_weight(individual,     0.10).

/* ================================================================
   4. POWER MODIFIERS (pi)
   Determines how much of the base extraction is "felt" by the agent.
   ================================================================ */

% Aligned with core.md spec (Section: Power-Scaling)
param(power_modifier_powerless, 1.5).      % Extraction amplified
param(power_modifier_moderate, 1.0).       % Baseline
param(power_modifier_powerful, 0.6).       % Extraction reduced
param(power_modifier_organized, 0.4).      % Shared burden (collective)
param(power_modifier_institutional, -0.2). % Net beneficiary
param(power_modifier_analytical, 1.0).     % Observer baseline

/* ================================================================
   4A. COALITION MODELING (The "Who" Extension)
   ================================================================ */

% If this many victims share a snare, they get the 'organized' power modifier.
param(critical_mass_threshold, 3).


/* ================================================================
   5. INTENT & DETECTION THRESHOLDS
   Consolidated parameters for the intent_engine and pattern_analysis.
   ================================================================ */

% --- Gradient Thresholds ---
% Minimum change to be considered non-stable.
param(system_gradient_threshold, 0.01).
% Threshold for "Strong" intent classification.
param(system_gradient_strong_threshold, 1.00).

% --- Beneficiary Asymmetry ---
% Min power gain required to be identified as the "Main Beneficiary".
param(beneficiary_gain_min, 0.50).
% Max gain allowed for other classes to maintain "Asymmetry".
param(loser_loss_max_gain, 0.10).

% --- Suppression & Resistance Alignment ---
% Required thresholds for structural-level alignment.
param(structural_suppression_min, 0.70). 
param(structural_resistance_min, 0.70).

% --- Data Integrity ---
% Thresholds for high/medium confidence classification.
param(data_high_threshold, 0.95).
param(data_medium_threshold, 0.75).

/* ================================================================
   5. DEFERENTIAL REALISM (DR) THRESHOLDS
   ================================================================ */

% --- Mountain Boundaries ---
param(mountain_suppression_ceiling, 0.05). % noise floor
param(mountain_extractiveness_min, 0.0).
param(mountain_extractiveness_max, 0.15).

% --- Rope Boundaries ---
% Aligned with core.md: Rope = low extraction, ε ≤ 0.15
param(rope_extractiveness_min, 0.0).
param(rope_extraction_ceiling,       0.15).  % core.md: ε ≤ 0.15
% Base suppression ceiling for pure coordination
param(rope_suppression_ceiling,      0.16).

% --- Tangled Rope (Hybrid Zone) ---
% core.md: 0.16-0.45 with coordination function, 36% of corpus
% Note: Tangled Rope requires BOTH coordination AND extraction markers.
% The zone 0.16-0.45 is the effective extraction range after power-scaling.
param(tangled_rope_extraction_floor, 0.16).  % Above rope ceiling
param(tangled_rope_extraction_ceil,  0.90).  % Below pure extraction ceiling
param(tangled_rope_suppression_floor, 0.40). % Requires active enforcement
param(tangled_rope_suppression_ceil, 1.00).

% --- Snare Boundaries ---
% Aligned with core.md: Snare = high extraction, ε ≥ 0.46
param(snare_extraction_floor,        0.46).  % core.md: ε ≥ 0.46
param(snare_extraction_ceil,         1.00).
param(snare_suppression_floor,       0.60).
param(snare_load_bearing_threshold,  0.70).  % Above this = load-bearing snare (Theorem 3)

% --- Scaffold Boundaries ---
% Temporary supports must remain below this coordination ceiling
param(scaffold_extraction_ceil, 0.30).

% --- Piton Boundaries ---
param(piton_extraction_ceiling,     0.10).
param(piton_theater_floor,          0.70).

% --- Global Meta-Parameters ---
% param(version, 3.4).
% param(logic_engine, 3.3).

/* ================================================================
   6. STRUCTURAL SIGNATURE THRESHOLDS (v3.2)
   These parameters enable detection of constraint ORIGIN
   (natural law vs coordination scaffold vs constructed constraint)
   rather than just constraint METRICS.
   ================================================================ */

% --- Natural Law Signature ---
% Identifies inherent properties of reality (no alternatives possible)
param(natural_law_collapse_min,      0.85).  % Extreme universal inaccessibility
param(natural_law_suppression_max,   0.15).  % No enforcement needed
param(natural_law_resistance_max,    0.15).  % Cannot be resisted

% --- Coordination Scaffold Signature ---
% Identifies successful voluntary standards (alternatives existed)
param(coordination_collapse_min,     0.85).  % Universal adoption achieved
param(coordination_suppression_max,  0.15).  % Voluntary compliance
param(coordination_resistance_max,   0.15).  % Minimal opposition

% --- Constructed Constraint Signature ---
% Identifies institutionally enforced rules (power asymmetries)
param(constructed_suppression_min,   0.20).  % Requires enforcement
param(constructed_resistance_min,    0.20).  % Faces opposition
param(constructed_beneficiary_min,   2).     % Asymmetric gains threshold

% --- Isomorphism Threshold ---
param(isomorphism_threshold, 0.85).
:- module(constraint_bridge, [
    dr_diagnostic_report/1,
    constraint_status/3,
    recommendation_feasibility/3,
    derive_veto_actors/0
]).

:- use_module(drl_core).
:- use_module(narrative_ontology).
:- use_module(coercion_projection).
:- use_module(isomorphism_engine).
:- use_module(domain_priors).

/* ================================================================
   1. CONTEXTUAL CONSTRAINT FILTERING
   ================================================================ */

%% constraint_status(+ConstraintName, -State, -Intensity)
%  Maps CE v2.0 types to diagnostic intensities.
constraint_status(Name, binding_limit, I) :-
    narrative_ontology:constraint_claim(Name, mountain),
    narrative_ontology:constraint_metric(Name, inevitability, I), !.

% Rope
constraint_status(Name, coordination_rope, I) :-
    narrative_ontology:constraint_claim(Name, rope),
    (narrative_ontology:constraint_metric(Name, theater_ratio, T) -> I is 1.0 - T ; I = 1.0), !.

% Snare (formerly Noose)
constraint_status(Name, extractive_snare, I) :-
    narrative_ontology:constraint_claim(Name, snare),
    narrative_ontology:constraint_metric(Name, extractiveness, I), !.

% Tangled Rope handling
constraint_status(Name, hybrid_extraction, I) :-
    narrative_ontology:constraint_claim(Name, tangled_rope),
    narrative_ontology:constraint_metric(Name, extractiveness, I), !.

% Scaffold handling
constraint_status(Name, temporary_coordination, I) :-
    narrative_ontology:constraint_claim(Name, scaffold),
    (narrative_ontology:constraint_metric(Name, extractiveness, Val) -> I = Val ; I = 0.5), !.

% Piton
constraint_status(Name, inertial_piton, I) :-
    narrative_ontology:constraint_claim(Name, piton),
    (narrative_ontology:constraint_metric(Name, theater_ratio, I) ; I = 1.0), !.

/* ================================================================
   2. UNIQUE VETO LOGIC & FEASIBILITY
   ================================================================ */

recommendation_feasibility(RecID, Status, UniqueVetoes) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is a recommendation
    % --- 1. THE STRUCTURAL AUDIT (Theorem 3) ---
    % If a recommendation affects a Snare (high extraction), 
    % it is load-bearing. Cutting it without a Scaffold is a systemic risk.
    (   narrative_ontology:affects_constraint(RecID, Target),
        narrative_ontology:constraint_metric(Target, extractiveness, X), 
        X > 0.7, % Load-bearing threshold
        \+ (narrative_ontology:entity(_, scaffold)) % No safety net provided
    ->  Status = blocked_scaffold_vacuum,
        UniqueVetoes = [] % Blocked by physics/logic, not individuals
    ;   
    % --- 2. THE POLITICAL AUDIT (Veto Logic) ---
    % Check for agents whose interests are explicitly threatened.
    (setof(Actor, narrative_ontology:veto_exposed(Actor, RecID), UniqueVetoes) 
     ; UniqueVetoes = []),
    length(UniqueVetoes, Count),
    (   Count == 0 -> Status = viable 
    ;   Count < 2  -> Status = high_veto_risk % Adjusted sensitivity
    ;   Status = blocked_by_veto)
    ).

%% is_safe_to_cut(+ConstraintID)
% Theorem 3: Cutting a load-bearing Snare requires a Scaffold.
is_safe_to_cut(C) :-
    narrative_ontology:constraint_metric(C, extractiveness, X), X > 0.7, % Load-bearing Snare
    narrative_ontology:entity(_, scaffold). % A scaffold MUST exist in the KB

/* ================================================================
   3. SCENARIO-AWARE DIAGNOSTIC REPORTING
   ================================================================ */

%% derive_veto_actors
%  Automated 'Veto Player' Derivation.
%  Infers veto players from beneficiary data for snares and tangled ropes.
derive_veto_actors :-
    findall(C, (
        drl_core:dr_type(C, Type),
        (Type = snare ; Type = tangled_rope)
    ), Cs),
    list_to_set(Cs, Constraints),
    forall(member(C, Constraints),
        (
            forall(narrative_ontology:constraint_beneficiary(C, Actor),
                (
                    ( \+ narrative_ontology:veto_actor(Actor), Actor \= none, Actor \= [] ->
                        assertz(narrative_ontology:veto_actor(Actor))
                    ; true
                    )
                )
            )
        )
    ).


%% dr_diagnostic_report(+IntervalID)
%  Enhanced v4.1: Consolidates diagnostic reporting with High-Risk Isomorphism Alerting.
dr_diagnostic_report(IntervalID) :-
    % Automated Veto Player Derivation
    derive_veto_actors,
    
    format('~n=== DEFERENTIAL REALISM (DR) DIAGNOSTIC: ~w ===~n', [IntervalID]),
    
    % --- SECTION 1: CONSTRAINT INVENTORY ---
    format('~n[CONSTRAINT INVENTORY]~n'),
    (   setof(line(Name, State, Intensity), 
              (constraint_status(Name, State, Intensity), 
               narrative_ontology:constraint_metric(Name, _, _)), 
              UniqueLines)
    ->  forall(member(line(N, S, I), UniqueLines),
               (   format('  - ~w: ~w (Intensity: ~2f)~n', [N, S, I]),
                   % Trigger Isomorphism Check for High-Risk Types
                   check_for_social_twins(N, S)
               ))
    ;   format('  No active constraints found.~n')
    ),
    
    % --- SECTION 2: FEASIBILITY BRIDGE ---
    format('~n[FEASIBILITY BRIDGE]~n'),
    % Using _ConsName resolves the singleton variable warning
    forall((narrative_ontology:recommendation(RID, Summary),
            narrative_ontology:affects_constraint(RID, _ConsName)),
           (recommendation_feasibility(RID, Stat, Vs),
            format('  - ~w (~w): ~w | Vetoes: ~w~n', [RID, Summary, Stat, Vs]))),
    format('====================================================~n').

%% check_for_social_twins(+Name, +State)
%  Internal helper that alerts the user if a high-risk technical constraint 
%  mirrors a social pathology.
check_for_social_twins(Name, State) :-
    member(State, [snare, tangled_rope, extractive_snare]), % High-risk states [cite: 4, 206, 208]
    isomorphism_engine:find_high_risk_isomorphism(Name, SocialTwin, Score),
    domain_priors:category_of(SocialTwin, Cat),
    member(Cat, [narrative_history, statutory_formal, election_cycle]),
    !,
    format('    ! ALERT: High-Risk Social Twin Detected: ~w (Similarity: ~2f)~n', [SocialTwin, Score]),
    format('    ! Logic: This system functions structurally identically to a ~w scenario.~n', [Cat]).
check_for_social_twins(_, _).
% CONSTRAINT CLASSIFICATION
% ============================================================================
% This module implements context-indexed constraint classification.
% Every Mountain/Rope/Snare judgment is relative to WHO, WHEN, WHERE, HOW.
%
% Integration: Load after domain_priors.pl, before report_generator.pl
% ============================================================================

:- module(constraint_indexing, [
    % Core API
    constraint_classification/3,    % New indexed classification
    constraint_claim_indexed/2,     % Backward compatible wrapper (renamed to avoid collision)
    
    % Context builders
    default_context/1,
    valid_context/1,
    discover_my_context/1,
    
    % Analysis utilities
    multi_index_report/1,
    compare_perspectives/2,
    perspective_gap/2,
    
    % Helper predicates (exposed for testing)
    effective_immutability/3,
    effective_immutability_for_context/2,
    extractiveness_for_agent/3,
    power_modifier/2,
    
    % Index predicates
    agent_power/1,
    time_horizon/1,
    exit_options/1,
    spatial_scope/1
]).

:- multifile constraint_classification/3.
:- dynamic constraint_classification/3.

% Required modules
:- use_module(drl_core, [base_extractiveness/2, suppression_score/2]).
:- use_module(config).
:- use_module(narrative_ontology).

% ============================================================================
% INDEX ONTOLOGY
% ============================================================================

% ----------------------------------------------------------------------------
% Agent Power Levels - WHO is evaluating?
% ----------------------------------------------------------------------------

agent_power(powerless).    % Serf, prisoner, child
agent_power(moderate).     % Middle class, citizen
agent_power(powerful).     % Wealthy, connected
agent_power(organized).    % Union, movement
agent_power(institutional).           % State, corporation, church
agent_power(analytical).              % Historian, philosopher (meta-level)

% ----------------------------------------------------------------------------
% Time Horizons - WHEN/how long?
% ----------------------------------------------------------------------------

time_horizon(immediate).              % 1 year
time_horizon(biographical).           % 20-50 years (lifetime)
time_horizon(generational).          % 50-100 years
time_horizon(historical).            % 100-500 years
time_horizon(civilizational).        % 500+ years

% ----------------------------------------------------------------------------
% Exit Options - WHERE can you go?
% ----------------------------------------------------------------------------

exit_options(trapped).               % No physical/conceptual exit
exit_options(constrained).           % Exit costly but possible
exit_options(mobile).                % Can leave, alternatives visible
exit_options(arbitrage).             % Can play systems against each other
exit_options(analytical).            % Not constrained (observer stance)

% ----------------------------------------------------------------------------
% Spatial Scope - WHERE does it operate?
% ----------------------------------------------------------------------------

spatial_scope(local).                % Village, neighborhood
spatial_scope(regional).             % Province, state
spatial_scope(national).             % Country
spatial_scope(continental).          % Europe, Asia, etc
spatial_scope(global).               % Worldwide
spatial_scope(universal).            % Universal

% ============================================================================
% CONTEXT STRUCTURE
% ============================================================================

% ----------------------------------------------------------------------------
% Context Validation
% ----------------------------------------------------------------------------

% context(+AgentPower, +TimeHorizon, +ExitOptions, +SpatialScope)
% Represents the indexical parameters for classification

valid_context(context(
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S)
)) :-
    agent_power(P),
    time_horizon(T),
    exit_options(E),
    spatial_scope(S).

% ----------------------------------------------------------------------------
% Default Context - Analytical "God's Eye View"
% ----------------------------------------------------------------------------

default_context(context(
    agent_power(analytical),
    time_horizon(civilizational),
    exit_options(analytical),
    spatial_scope(global)
)).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% Indexed API wrapper - defaults to analytical perspective
% Renamed to avoid collision with narrative_ontology:constraint_claim/2
constraint_claim_indexed(Constraint, Type) :-
    default_context(Ctx),
    constraint_classification(Constraint, Type, Ctx).

% ============================================================================
% HELPER PREDICATES - EFFECTIVE IMMUTABILITY
% ============================================================================

% Can this be changed given time horizon and exit options?
% Returns: mountain (unchangeable) or rope (changeable)

effective_immutability(immediate, trapped, mountain).
effective_immutability(immediate, constrained, mountain).
effective_immutability(immediate, mobile, rope).
effective_immutability(immediate, arbitrage, rope).

effective_immutability(biographical, trapped, mountain).
effective_immutability(biographical, constrained, mountain).
effective_immutability(biographical, mobile, rope).
effective_immutability(biographical, arbitrage, rope).

effective_immutability(generational, trapped, mountain).
effective_immutability(generational, constrained, rope).
effective_immutability(generational, mobile, rope).
effective_immutability(generational, arbitrage, rope).

effective_immutability(historical, _, rope).
effective_immutability(civilizational, _, rope).

% Wrapper that takes full context
effective_immutability_for_context(
    context(_, time_horizon(T), exit_options(E), _),
    Perception
) :-
    effective_immutability(T, E, Perception).

% ============================================================================
% HELPER PREDICATES - AGENT-RELATIVE EXTRACTIVENESS
% ============================================================================

% ----------------------------------------------------------------------------
% Power Modifiers
% ----------------------------------------------------------------------------
% More powerful agents experience less extraction from same constraint
% Negative modifier = net beneficiary
% Determines how much of the base extraction is "felt" by the agent.
% Lower numbers = higher benefit/protection from the constraint.

power_modifier(powerless,     Modifier) :- config:param(power_modifier_powerless, Modifier).
power_modifier(moderate,      Modifier) :- config:param(power_modifier_moderate, Modifier).
power_modifier(powerful,      Modifier) :- config:param(power_modifier_powerful, Modifier).
power_modifier(organized,     Modifier) :- config:param(power_modifier_organized, Modifier).
power_modifier(institutional, Modifier) :- config:param(power_modifier_institutional, Modifier).
power_modifier(analytical,    Modifier) :- config:param(power_modifier_analytical, Modifier).

% ----------------------------------------------------------------------------
% Dynamic Coalition Modeling (The "Who" Extension)
% ----------------------------------------------------------------------------

%% resolve_coalition_power(+Power, +Constraint, -ResolvedPower)
%  Dynamically upgrades 'powerless' to 'organized' if a
%  critical mass of victims for a given snare-like constraint is reached.
resolve_coalition_power(powerless, Constraint, organized) :-
    % To avoid circular dependencies, we check for snare-like properties
    % (high base extraction, high suppression) instead of the final type.
    config:param(extractiveness_metric_name, ExtMetricName),
    config:param(suppression_metric_name, SuppMetricName),
    (narrative_ontology:constraint_metric(Constraint, ExtMetricName, BaseX) ->
        config:param(snare_extraction_floor, XFloor),
        BaseX >= XFloor
    ; false),
    (narrative_ontology:constraint_metric(Constraint, SuppMetricName, S) ->
        config:param(snare_suppression_floor, SFloor),
        S >= SFloor
    ; false),
    % Check for critical mass of victims
    findall(_, narrative_ontology:constraint_victim(Constraint, _), Victims),
    length(Victims, Count),
    config:param(critical_mass_threshold, Threshold),
    Count >= Threshold,
    !.
resolve_coalition_power(Power, _, Power). % Default: power remains unchanged


% ----------------------------------------------------------------------------
% Calculate Extractiveness for Specific Agent
% ----------------------------------------------------------------------------

% Formula: Effective Extraction = Base Extraction * Power Modifier
extractiveness_for_agent(Constraint, Context, Score) :-
    Context = context(agent_power(Power), _, _, _),
    resolve_coalition_power(Power, Constraint, ResolvedPower),
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(Constraint, ExtMetricName, BaseScore),
    power_modifier(ResolvedPower, Modifier),
    Score is BaseScore * Modifier.

% ============================================================================
% CANONICAL CLASSIFICATION PREDICATE
% ============================================================================

% constraint_classification(+ConstraintID, ?Type, +Context)
% This is the ONLY predicate that does real classification work.
% All other predicates delegate to this.
%
% Specific constraint rules should be added in separate files or
% in domain_priors.pl using this predicate.

% Example template (actual rules in domain_priors.pl or constraint_instances.pl):
% constraint_classification(some_constraint, Type, Context) :-
%     valid_context(Context),
%     ... classification logic using Context parameters ...

% ============================================================================
% QUERY UTILITIES
% ============================================================================
% ----------------------------------------------------------------------------
% Interactive Context Discovery
% ----------------------------------------------------------------------------

discover_my_context(Context) :-
    writeln(''),
    writeln('=== CONTEXT DISCOVERY ==='),
    writeln(''),
    writeln('What is your power level?'),
    writeln('  1. Powerless (prisoner, serf, child)'),
    writeln('  2. Moderate (middle class, citizen)'),
    writeln('  3. Powerful (wealthy, politically connected)'),
    writeln('  4. Collective (union, movement)'),
    writeln('  5. Institutional (state, corporation)'),
    writeln('  6. Analytical (observer, researcher)'),
    read(PowerChoice),
    map_power(PowerChoice, Power),
    
    writeln(''),
    writeln('What time horizon are you considering?'),
    writeln('  1. Immediate (1 year)'),
    writeln('  2. Biographical (my lifetime)'),
    writeln('  3. Generational (my children)'),
    writeln('  4. Historical (centuries)'),
    writeln('  5. Civilizational (millennia)'),
    read(TimeChoice),
    map_time(TimeChoice, Time),
    
    writeln(''),
    writeln('What exit options do you have?'),
    writeln('  1. Trapped (no exit visible)'),
    writeln('  2. Constrained (exit costly)'),
    writeln('  3. Mobile (can leave)'),
    writeln('  4. Arbitrage (can play systems)'),
    writeln('  5. Analytical (observer)'),
    read(ExitChoice),
    map_exit(ExitChoice, Exit),
    
    writeln(''),
    writeln('What spatial scope?'),
    writeln('  1. Local (village/neighborhood)'),
    writeln('  2. Regional (state/province)'),
    writeln('  3. National (country)'),
    writeln('  4. Continental (Europe, Asia, etc)'),
    writeln('  5. Global (worldwide)'),
    read(ScopeChoice),
    map_scope(ScopeChoice, Scope),
    
    Context = context(
        agent_power(Power),
        time_horizon(Time),
        exit_options(Exit),
        spatial_scope(Scope)
    ),
    writeln(''),
    format('Your context: ~w~n', [Context]).

% Mapping predicates for user input
map_power(1, powerless).
map_power(2, individual_moderate).
map_power(3, powerful).
map_power(4, collective_organized).
map_power(5, institutional).
map_power(6, analytical).

map_time(1, immediate).
map_time(2, biographical).
map_time(3, generational).
map_time(4, historical).
map_time(5, civilizational).

map_exit(1, trapped).
map_exit(2, constrained).
map_exit(3, mobile).
map_exit(4, arbitrage).
map_exit(5, analytical).

map_scope(1, local).
map_scope(2, regional).
map_scope(3, national).
map_scope(4, continental).
map_scope(5, global).

% ----------------------------------------------------------------------------
% Multi-Index Analysis
% ----------------------------------------------------------------------------

% Show how constraint classifies from different perspectives
multi_index_report(Constraint) :-
    writeln(''),
    writeln('=== MULTI-INDEX ANALYSIS ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    findall(
        result(Type, Power, Time, Exit, Scope),
        constraint_classification(Constraint, Type, 
            context(agent_power(Power), time_horizon(Time),
                   exit_options(Exit), spatial_scope(Scope))),
        Results
    ),
    
    (Results = [] ->
        writeln('No classifications found.')
    ;
        format_multi_index_results(Results)
    ).

format_multi_index_results([]).
format_multi_index_results([result(Type, Power, Time, Exit, Scope)|Rest]) :-
    format('~w: power=~w, time=~w, exit=~w, scope=~w~n',
           [Type, Power, Time, Exit, Scope]),
    format_multi_index_results(Rest).

% ----------------------------------------------------------------------------
% Perspective Comparison
% ----------------------------------------------------------------------------

% Compare YOUR view vs ANALYTICAL view
compare_perspectives(Constraint, MyContext) :-
    writeln(''),
    writeln('=== PERSPECTIVE COMPARISON ==='),
    format('Constraint: ~w~n~n', [Constraint]),
    
    default_context(AnalyticalContext),
    
    (constraint_classification(Constraint, MyType, MyContext) ->
        format('From YOUR perspective (~w): ~w~n', [MyContext, MyType])
    ;
        writeln('No classification from your perspective')
    ),
    
    writeln(''),
    
    (constraint_classification(Constraint, AnalyticalType, AnalyticalContext) ->
        format('From ANALYTICAL perspective: ~w~n', [AnalyticalType])
    ;
        writeln('No analytical classification')
    ),
    
    writeln(''),
    
    (var(MyType) ; var(AnalyticalType) ->
        true
    ; MyType = AnalyticalType ->
        writeln('→ Perspectives AGREE')
    ;
        writeln('→ Perspectives DISAGREE - this is a site of political conflict')
    ).

% ----------------------------------------------------------------------------
% Perspective Gap Detection
% ----------------------------------------------------------------------------

% Find political flashpoints - where different perspectives classify differently
perspective_gap(Constraint, Gap) :-
    constraint_classification(Constraint, Type1, Context1),
    constraint_classification(Constraint, Type2, Context2),
    Type1 \= Type2,
    Context1 \= Context2,
    Gap = gap(Type1-Context1, Type2-Context2).

% ============================================================================
% INTEGRATION NOTES
% ============================================================================

% To integrate this module:
%
% 1. In drl_core.pl, add after domain_priors:
%    :- use_module(constraint_indexing).
%
% 2. In domain_priors.pl, add base_extractiveness/2 facts:
%    base_extractiveness(constraint_id, score).
%    % Score range: 0.0 (no extraction) to 1.0 (full extraction)
%
% 3. Add specific constraint rules using constraint_classification/3
%    See constraint_instances.pl for examples
%
% 4. Update report_generator.pl to optionally use indexed classification:
%    - Default: Use constraint_claim/2 (analytical view)
%    - Advanced: Accept context parameter from user
%
% 5. Test backward compatibility:
%    - Old code using constraint_claim/2 should work unchanged
%    - New code can use constraint_classification/3 explicitly
:- module(constraint_instances, [
    % This module adds constraint_classification/3 rules
    % No exports needed - rules are added to constraint_indexing namespace
]).

:- use_module(constraint_indexing).
:- use_module(domain_priors).

% ============================================================================
% CONSTRAINT-SPECIFIC INDEXED CLASSIFICATIONS
% ============================================================================

% These rules extend constraint_indexing:constraint_classification/3
% See test_generation_prompt.md for examples

% ============================================================================
% HISTORICAL CONSTRAINT INSTANCES
% ============================================================================

% ----------------------------------------------------------------------------
% CATHOLIC CHURCH 1200 CE
% ----------------------------------------------------------------------------

% Serf perspective - MOUNTAIN
constraint_indexing:constraint_classification(
    catholic_church_1200,
    mountain,
    context(
        agent_power(powerless),
        time_horizon(biographical),
        exit_options(trapped),
        spatial_scope(local)
    )
) :-
    constraint_indexing:effective_immutability_for_context(
        context(agent_power(powerless), 
                time_horizon(biographical), 
                exit_options(trapped), 
                spatial_scope(local)),
        mountain
    ).

% Historian perspective - NOOSE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    snare,
    context(
        agent_power(analytical),
        time_horizon(Horizon),
        exit_options(analytical),
        spatial_scope(continental)  % FIXED: Was unbound
    )
) :-
    member(Horizon, [historical, civilizational]),
    domain_priors:base_extractiveness(catholic_church_1200, E),
    E > 0.6,
    domain_priors:requires_active_enforcement(catholic_church_1200),
    !.  % ADDED: Cut to prevent duplicates

% Pope perspective - ROPE
constraint_indexing:constraint_classification(
    catholic_church_1200,
    rope,
    context(
        agent_power(institutional),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(continental)
    )
) :-
    constraint_indexing:extractiveness_for_agent(catholic_church_1200, 
        context(agent_power(institutional), 
                time_horizon(generational), 
                exit_options(arbitrage), 
                spatial_scope(continental)), 
        E),
    E < 0.4,  % Low for beneficiary
    !.  % ADDED: Cut to prevent duplicates

% ----------------------------------------------------------------------------
% PROPERTY RIGHTS 2025
% ----------------------------------------------------------------------------

% Homeless person - NOOSE
constraint_indexing:constraint_classification(
    property_rights_2025,
    snare,
    context(
        agent_power(powerless),
        time_horizon(biographical),
        exit_options(Exit),
        spatial_scope(national)
    )
) :-
    member(Exit, [trapped, constrained]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025, 
        context(agent_power(powerless),
                time_horizon(biographical),
                exit_options(Exit),
                spatial_scope(national)),
        E),
    E > 0.7,
    !.  % ADDED: Cut to prevent duplicates

% Middle class - ROPE
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(individual_moderate),
        time_horizon(biographical),
        exit_options(mobile),
        spatial_scope(national)
    )
) :-
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(individual_moderate),
                time_horizon(biographical),
                exit_options(mobile),
                spatial_scope(national)),
        E),
    E < 0.6,
    !.  % ADDED: Cut to prevent duplicates

% Billionaire - ROPE (with benefits)
constraint_indexing:constraint_classification(
    property_rights_2025,
    rope,
    context(
        agent_power(Power),
        time_horizon(generational),
        exit_options(arbitrage),
        spatial_scope(global)
    )
) :-
    member(Power, [powerful, institutional]),
    constraint_indexing:extractiveness_for_agent(property_rights_2025,
        context(agent_power(Power),
                time_horizon(generational),
                exit_options(arbitrage),
                spatial_scope(global)),
        E),
    E < 0,  % Negative = net beneficiary
    !.  % ADDED: Cut to prevent duplicates


% ----------------------------------------------------------------------------
% CARBON TAX 2026
% ----------------------------------------------------------------------------

% Facts for carbon_tax_2026 - these would typically be in domain_priors.pl
drl_core:base_extractiveness(carbon_tax_2026, 0.55). % Medium extraction
drl_core:suppression_score(carbon_tax_2026, 0.60).   % Requires active enforcement
drl_core:requires_active_enforcement(carbon_tax_2026).
narrative_ontology:constraint_beneficiary(carbon_tax_2026, society_at_large). % Climate coordination
narrative_ontology:constraint_victim(carbon_tax_2026, low_income_consumers). % Burdens some more than others

% Small Business Owner perspective - TANGLED ROPE
constraint_indexing:constraint_classification(
    carbon_tax_2026,
    tangled_rope,
    context(
        agent_power(individual_moderate),
        time_horizon(immediate),
        exit_options(constrained),
        spatial_scope(national)
    )
) :-
    % Check if it classifies as tangled_rope from this context
    drl_core:is_tangled_rope(carbon_tax_2026,
        context(
            agent_power(individual_moderate),
            time_horizon(immediate),
            exit_options(constrained),
            spatial_scope(national)
        ),
        tangled_rope
    ),
    !.

% Low-Income Consumer perspective - SNARE
constraint_indexing:constraint_classification(
    carbon_tax_2026,
    snare,
    context(
        agent_power(powerless),
        time_horizon(biographical),
        exit_options(trapped),
        spatial_scope(local)
    )
) :-
    % Check if it classifies as snare from this context
    drl_core:is_snare(carbon_tax_2026,
        context(
            agent_power(powerless),
            time_horizon(biographical),
            exit_options(trapped),
            spatial_scope(local)
        ),
        snare
    ),
    !.
:- module(data_repair, [
    repair_interval/1
]).

:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(domain_priors). % NEW: Hook into the Epistemic Prior Library
:- use_module(signature_mapper).
:- use_module(constraint_indexing).
:- use_module(drl_core).

% Ensure we can add facts to the ontology's measurement predicate
:- dynamic narrative_ontology:measurement/5.

/* ============================================================
   REPAIR ORCHESTRATOR
   ============================================================ */

%% repair_interval(+IntervalID)
% Audits the measurement vectors for a given interval and repairs gaps
% using domain-specific epistemic priors.
repair_interval(IntervalID) :-
    (   narrative_ontology:interval(IntervalID, T0, Tn)
    ->  format('~n[REPAIR] Auditing vectors for: ~w...~n', [IntervalID]),

        % 0. V3.4 DATA BRIDGE: Derive constraint_claim/2 and constraint_metric/3
        %    from indexed classifications and domain_priors when missing.
        bridge_v34_data(IntervalID),

        % 1. PILLAR REMAPPING: Fix non-standard claims before verification
        forall(narrative_ontology:constraint_claim(C, Type),
               (   signature_mapper:map_custom_pillar(C, Type, Standard),
                   (Type \= Standard -> 
                    retract(narrative_ontology:constraint_claim(C, Type)),
                    assertz(narrative_ontology:constraint_claim(C, Standard)),
                    format('  [FIXED] Remapped ~w: ~w -> ~w~n', [C, Type, Standard])
                   ; true)
               )),

        % 2. VECTOR REPAIR: Impute missing measurements
        forall(config:level(L), 
               ( repair_point(L, T0, IntervalID), 
                 repair_point(L, Tn, IntervalID) 
               ))
    ;   format('~n[ERROR] Interval ~w not found.~n', [IntervalID]),
        false
    ).

%% repair_point(+Level, +Time, +IntervalID)
% Iterates through the 4-component coercion vector at a specific time point.
repair_point(Level, Time, IntervalID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components), 
           ensure_metric_exists(Metric, Time, IntervalID)).

%% ensure_metric_exists(+Metric, +Time, +IntervalID)
% Core v3.2 Imputation Logic:
% 1. Checks for existing data.
% 2. Resolves prior based on domain type.
% 3. Flags novelty if the domain is unmapped.
ensure_metric_exists(Metric, Time, IntervalID) :-
    % Look directly into the ontology for existing measurement
    narrative_ontology:measurement(_, _, Metric, Time, _)
    ->  true
    ;   (   % NEW: Fetch prior value instead of hard-coded 0.5
            domain_priors:get_prior(IntervalID, Metric, Value),
            
            % NEW: Surface novelty alert to the LLM/User
            (domain_priors:is_known_domain(IntervalID) -> true ; domain_priors:flag_novelty(IntervalID)),
            
            gensym(repair_m_, SyntheticID),
            % Assert the synthetic fact into the global ontology
            assertz(narrative_ontology:measurement(SyntheticID, IntervalID, Metric, Time, Value)),
            format('  [FIXED] Imputed ~w for ~w at T=~w~n', [Value, Metric, Time])
    ).

/* ============================================================
   V3.4 DATA BRIDGE

   v3.4 testsets define constraint_classification/3 and
   domain_priors but NOT constraint_claim/2 or
   constraint_metric/3. This bridge auto-derives the missing
   ontology facts so the audit framework can find them.
   ============================================================ */

%% bridge_v34_data(+IntervalID)
%  Master bridge: derives constraint_claim, constraint_metric,
%  and omega_variable facts from v3.4 indexed data.
bridge_v34_data(IntervalID) :-
    % Metrics must be bridged FIRST because bridge_constraint_claim
    % uses drl_core:dr_type/2 which queries constraint_metric/3.
    bridge_domain_metrics(IntervalID),
    bridge_beneficiary_victim(IntervalID),
    bridge_constraint_claim(IntervalID),
    bridge_omega_variables(IntervalID).

%% bridge_constraint_claim(+IntervalID)
%  If no constraint_claim/2 exists for IntervalID but
%  constraint_classification/3 facts do, derive the claim
%  using the analytical classification from drl_core.
bridge_constraint_claim(IntervalID) :-
    (   narrative_ontology:constraint_claim(IntervalID, _)
    ->  true  % Already has a claim, no bridge needed
    ;   (   constraint_indexing:constraint_classification(IntervalID, _, _)
        ->  % Classifications exist but no claim: derive from drl_core
            (   catch(drl_core:dr_type(IntervalID, DerivedType), _, fail)
            ->  assertz(narrative_ontology:constraint_claim(IntervalID, DerivedType)),
                format('  [BRIDGE] Derived constraint_claim(~w, ~w) from analytical classification~n',
                       [IntervalID, DerivedType])
            ;   % Fallback: use first indexed classification found
                constraint_indexing:constraint_classification(IntervalID, FallbackType, _),
                assertz(narrative_ontology:constraint_claim(IntervalID, FallbackType)),
                format('  [BRIDGE] Derived constraint_claim(~w, ~w) from first indexed classification~n',
                       [IntervalID, FallbackType])
            )
        ;   true  % No classifications at all, nothing to bridge
        )
    ).

%% bridge_domain_metrics(+IntervalID)
%  Maps domain_priors predicates to narrative_ontology:constraint_metric/3
%  so that constraint_bridge:constraint_status/3 can find them.
bridge_domain_metrics(IntervalID) :-
    config:param(extractiveness_metric_name, ExtMetricName),
    bridge_single_metric(IntervalID, ExtMetricName, extractiveness),
    config:param(suppression_metric_name, SuppMetricName),
    bridge_single_metric(IntervalID, SuppMetricName, suppression_requirement),
    config:param(theater_metric_name, TheaterMetricName),
    bridge_single_metric(IntervalID, TheaterMetricName, theater_ratio).

bridge_single_metric(IntervalID, PriorPred, MetricKey) :-
    (   narrative_ontology:constraint_metric(IntervalID, MetricKey, _)
    ->  true  % Already exists
    ;   (   Goal =.. [PriorPred, IntervalID, Value],
            catch(domain_priors:call(Goal), _, fail)
        ->  assertz(narrative_ontology:constraint_metric(IntervalID, MetricKey, Value)),
            format('  [BRIDGE] Derived metric ~w = ~w for ~w~n', [MetricKey, Value, IntervalID])
        ;   true  % No domain prior available
        )
    ).

%% bridge_omega_variables(+IntervalID)
%  v3.4 testsets define omega_variable/5 in their own module namespace.
%  This bridges them into narrative_ontology:omega_variable/3.
bridge_omega_variables(IntervalID) :-
    (   current_module(IntervalID),
        predicate_property(IntervalID:omega_variable(_,_,_,_,_), defined)
    ->  forall(
            (   catch(IntervalID:omega_variable(OID, Question, _Measurement, _Resolution, _Conf), _, fail),
                \+ narrative_ontology:omega_variable(OID, _, _)
            ),
            (   assertz(narrative_ontology:omega_variable(OID, empirical, Question)),
                format('  [BRIDGE] Imported omega ~w from module ~w~n', [OID, IntervalID])
            ))
    ;   true  % Module not loaded or no omega_variable/5
    ),
    % Also check for omega_variable/3 in the testset module
    (   current_module(IntervalID),
        predicate_property(IntervalID:omega_variable(_,_,_), defined)
    ->  forall(
            (   catch(IntervalID:omega_variable(OID3, Type3, Desc3), _, fail),
                \+ narrative_ontology:omega_variable(OID3, _, _)
            ),
            (   assertz(narrative_ontology:omega_variable(OID3, Type3, Desc3)),
                format('  [BRIDGE] Imported omega ~w from module ~w~n', [OID3, IntervalID])
            ))
    ;   true
    ).

/* ============================================================
   V3.4 BENEFICIARY/VICTIM BRIDGE

   Tangled Rope detection via drl_core:is_tangled_rope/3
   requires has_coordination_function/1 (needs constraint_beneficiary/2)
   and has_asymmetric_extraction/1 (needs constraint_victim/2).

   Most v3.4 testsets don't declare these. When a constraint has
   high extraction (> 0.46) AND high suppression (> 0.40), it
   structurally implies both a beneficiary and a victim exist.
   This bridge asserts synthetic beneficiary/victim facts so the
   tangled rope gate can fire on metric-qualifying constraints.
   ============================================================ */

%% bridge_beneficiary_victim(+IntervalID)
%  Auto-derives constraint_beneficiary/2 and constraint_victim/2
%  for high-extraction, high-suppression constraints that lack them.
bridge_beneficiary_victim(IntervalID) :-
    % Only act if both facts are missing
    (   narrative_ontology:constraint_beneficiary(IntervalID, _)
    ->  true  % Already has beneficiary
    ;   (   narrative_ontology:constraint_metric(IntervalID, extractiveness, E),
            E > 0.46,
            narrative_ontology:constraint_metric(IntervalID, suppression_requirement, S),
            S > 0.40
        ->  assertz(narrative_ontology:constraint_beneficiary(IntervalID, inferred_institutional)),
            format('  [BRIDGE] Derived constraint_beneficiary(~w, inferred_institutional) from metrics (E=~2f, S=~2f)~n',
                   [IntervalID, E, S])
        ;   true
        )
    ),
    (   narrative_ontology:constraint_victim(IntervalID, _)
    ->  true  % Already has victim
    ;   (   narrative_ontology:constraint_metric(IntervalID, extractiveness, E2),
            E2 > 0.46,
            narrative_ontology:constraint_metric(IntervalID, suppression_requirement, S2),
            S2 > 0.40
        ->  assertz(narrative_ontology:constraint_victim(IntervalID, inferred_subject)),
            format('  [BRIDGE] Derived constraint_victim(~w, inferred_subject) from metrics (E=~2f, S=~2f)~n',
                   [IntervalID, E2, S2])
        ;   true
        )
    ).
:- module(data_validation, [
    validate_all/0,
    validate_constraint_completeness/0,
    validate_metric_ranges/0,
    validate_classification_consistency/0,
    validate_edge_cases/0,
    validate_domain_coverage/0,
    validation_summary/0
]).

:- use_module(narrative_ontology).
:- use_module(constraint_indexing).
:- use_module(domain_priors).
:- use_module(drl_core).
:- use_module(config).
:- use_module(utils).  % For safe metric retrieval

/* ============================================================================
   DATA VALIDATION SUITE
   ============================================================================

   This module provides comprehensive validation of constraint data quality,
   completeness, and consistency. Unlike validation_suite.pl (which runs
   scenarios), this validates the data itself.

   ============================================================================ */

:- dynamic validation_error/3.    % validation_error(Type, Constraint, Details)
:- dynamic validation_warning/3.   % validation_warning(Type, Constraint, Details)
:- dynamic validation_info/2.      % validation_info(Type, Message)

/* ============================================================================
   1. MAIN VALIDATION ENTRY POINT
   ============================================================================ */

%% validate_all/0
%  Runs all validation checks and reports results.
validate_all :-
    retractall(validation_error(_, _, _)),
    retractall(validation_warning(_, _, _)),
    retractall(validation_info(_, _)),

    format('~n====================================================~n'),
    format('   DATA VALIDATION SUITE                           ~n'),
    format('====================================================~n~n'),

    write('Running validation checks...'), nl, nl,

    % Run all validation checks
    validate_constraint_completeness,
    validate_metric_ranges,
    validate_classification_consistency,
    validate_edge_cases,
    validate_domain_coverage,

    % Report results
    validation_summary.

/* ============================================================================
   2. CONSTRAINT COMPLETENESS VALIDATION
   ============================================================================ */

%% validate_constraint_completeness/0
%  Checks that all constraints have required data.
validate_constraint_completeness :-
    format('[CHECK 1: Constraint Completeness]~n'),
    findall(C, narrative_ontology:constraint_claim(C, _), Constraints),
    length(Constraints, Total),
    format('  Checking ~w constraints...~n', [Total]),

    findall(C, (member(C, Constraints), is_complete_constraint(C)), Complete),
    length(Complete, CompleteCount),
    Incomplete is Total - CompleteCount,

    (Incomplete > 0
    -> (format('  ✗ ~w incomplete constraint(s) found~n~n', [Incomplete]),
        forall((member(C, Constraints), \+ is_complete_constraint(C)),
               report_incomplete_constraint(C)))
    ;  format('  ✓ All constraints complete~n~n', [])).

%% is_complete_constraint(+Constraint)
%  True if constraint has all required data.
is_complete_constraint(C) :-
    % Must have extractiveness metric
    (narrative_ontology:constraint_metric(C, extractiveness, E)
    -> (E >= 0.0, E =< 1.0)
    ;  (assertz(validation_error(missing_metric, C, extractiveness)), fail)),

    % Must have suppression_requirement metric
    (narrative_ontology:constraint_metric(C, suppression_requirement, S)
    -> (S >= 0.0, S =< 1.0)
    ;  (assertz(validation_error(missing_metric, C, suppression_requirement)), fail)),

    % Must have domain category
    (domain_priors:category_of(C, Cat)
    -> (Cat \= unknown, Cat \= unknown_novel)
    ;  (assertz(validation_warning(missing_category, C, 'No domain category assigned')), fail)),

    % Should have at least one indexical classification
    (constraint_indexing:constraint_classification(C, _, _)
    -> true
    ;  (assertz(validation_warning(missing_classification, C, 'No indexical classification')), fail)).

%% report_incomplete_constraint(+Constraint)
%  Reports what data is missing for a constraint.
report_incomplete_constraint(C) :-
    format('  Constraint: ~w~n', [C]),

    % Check extractiveness
    (\+ narrative_ontology:constraint_metric(C, extractiveness, _)
    -> format('    ✗ Missing: extractiveness metric~n')
    ;  true),

    % Check suppression
    (\+ narrative_ontology:constraint_metric(C, suppression_requirement, _)
    -> format('    ✗ Missing: suppression_requirement metric~n')
    ;  true),

    % Check category
    (\+ domain_priors:category_of(C, _)
    -> format('    ✗ Missing: domain category~n')
    ; domain_priors:category_of(C, Cat),
      (Cat = unknown ; Cat = unknown_novel)
    -> format('    ⚠ Category is ~w (should be specific)~n', [Cat])
    ;  true),

    % Check classification
    (\+ constraint_indexing:constraint_classification(C, _, _)
    -> format('    ⚠ Missing: indexical classification~n')
    ;  true),

    nl.

/* ============================================================================
   3. METRIC RANGE VALIDATION
   ============================================================================ */

%% validate_metric_ranges/0
%  Checks that all metrics are within valid ranges.
validate_metric_ranges :-
    format('[CHECK 2: Metric Range Validation]~n'),

    % Check all constraint metrics
    findall(C-M-V, narrative_ontology:constraint_metric(C, M, V), Metrics),
    length(Metrics, TotalMetrics),
    format('  Checking ~w metrics...~n', [TotalMetrics]),

    findall(C-M-V,
            (narrative_ontology:constraint_metric(C, M, V),
             \+ valid_metric_range(M, V)),
            InvalidMetrics),

    length(InvalidMetrics, InvalidCount),
    (InvalidCount > 0
    -> (format('  ✗ ~w invalid metric(s) found~n~n', [InvalidCount]),
        forall(member(C-M-V, InvalidMetrics),
               (format('    ✗ ~w.~w = ~w (out of range)~n', [C, M, V]),
                assertz(validation_error(invalid_metric_range, C, M-V)))))
    ;  format('  ✓ All metrics in valid range~n', [])),
    nl.

%% valid_metric_range(+Metric, +Value)
%  Checks if a metric value is in valid range.
valid_metric_range(_, V) :-
    number(V),
    V >= 0.0,
    V =< 1.0.

/* ============================================================================
   4. CLASSIFICATION CONSISTENCY VALIDATION
   ============================================================================ */

%% validate_classification_consistency/0
%  Checks that claimed types match calculated types.
validate_classification_consistency :-
    format('[CHECK 3: Classification Consistency]~n'),
    findall(C, narrative_ontology:constraint_claim(C, _), Constraints),
    length(Constraints, Total),
    format('  Checking ~w constraints for consistency...~n', [Total]),

    findall(C-Claimed-Expected,
            (narrative_ontology:constraint_claim(C, Claimed),
             infer_expected_type(C, Expected),
             Claimed \= Expected),
            Inconsistencies),

    length(Inconsistencies, IncCount),
    (IncCount > 0
    -> (format('  ⚠ ~w potential inconsistenc(ies) found~n~n', [IncCount]),
        forall(member(C-Claimed-Expected, Inconsistencies),
               report_classification_inconsistency(C, Claimed, Expected)))
    ;  format('  ✓ All classifications consistent with metrics~n', [])),
    nl.

%% infer_expected_type(+Constraint, -Type)
%  Infers what type a constraint should be based on metrics.
infer_expected_type(C, Type) :-
    (narrative_ontology:constraint_metric(C, suppression_requirement, Supp),
     domain_priors:base_extractiveness(C, Extr),
     config:param(mountain_suppression_ceiling, Ceil)
    -> classify_by_metrics(Supp, Extr, Ceil, Type)
    ;  Type = unknown).

%% classify_by_metrics(+Supp, +Extr, +Ceil, -Type)
%  Classification logic based on metrics.
classify_by_metrics(Supp, Extr, Ceil, mountain) :-
    Supp =< Ceil, Extr =< 0.35, !.

classify_by_metrics(Supp, Extr, Ceil, snare) :-
    Supp > Ceil, Extr > 0.66, !.

classify_by_metrics(Supp, Extr, Ceil, tangled_rope) :-
    Supp > Ceil, Extr > 0.35, !.

classify_by_metrics(Supp, _Extr, Ceil, rope) :-
    Supp > Ceil, !.

classify_by_metrics(_Supp, Extr, _Ceil, snare) :-
    Extr > 0.66, !.

classify_by_metrics(_, _, _, ambiguous).

%% report_classification_inconsistency(+C, +Claimed, +Expected)
report_classification_inconsistency(C, Claimed, Expected) :-
    narrative_ontology:constraint_metric(C, suppression_requirement, Supp),
    domain_priors:base_extractiveness(C, Extr),
    config:param(mountain_suppression_ceiling, Ceil),

    format('  Constraint: ~w~n', [C]),
    format('    Claimed: ~w~n', [Claimed]),
    format('    Expected (from metrics): ~w~n', [Expected]),
    format('    Metrics: suppression=~2f, extractiveness=~2f, ceiling=~2f~n', [Supp, Extr, Ceil]),

    (Expected = snare, Claimed = mountain
    -> (format('    ⚠ CRITICAL: False Mountain (extractive but claimed unchangeable)~n'),
        assertz(validation_error(false_mountain, C, Claimed-Expected)))
    ; Expected = mountain, Claimed = snare
    -> (format('    ⚠ False Snare (fair but claimed extractive)~n'),
        assertz(validation_warning(false_snare, C, Claimed-Expected)))
    ;  assertz(validation_warning(classification_mismatch, C, Claimed-Expected))
    ),
    nl.

/* ============================================================================
   5. EDGE CASE DETECTION
   ============================================================================ */

%% validate_edge_cases/0
%  Detects unusual patterns and edge cases.
validate_edge_cases :-
    format('[CHECK 4: Edge Case Detection]~n'),

    % Check for mandatrophies (unchangeable + extractive)
    findall(C,
            (narrative_ontology:constraint_claim(C, mountain),
             domain_priors:base_extractiveness(C, E),
             E > 0.7),
            Mandatrophies),

    length(Mandatrophies, MandCount),
    (MandCount > 0
    -> (format('  ⚠ ~w potential mandatroph(ies) detected~n', [MandCount]),
        forall(member(C, Mandatrophies),
               (domain_priors:base_extractiveness(C, E),
                format('    - ~w (mountain with E=~2f > 0.7)~n', [C, E]),
                assertz(validation_warning(mandatrophy, C, E)))))
    ;  format('  ✓ No mandatrophies detected~n', [])),

    % Check for pitons (no resistance despite enforcement)
    findall(C,
            (narrative_ontology:constraint_metric(C, suppression_requirement, S),
             narrative_ontology:constraint_metric(C, resistance_to_change, R),
             S > 0.3, R < 0.1),
            Zombies),

    length(Zombies, ZombieCount),
    (ZombieCount > 0
    -> (format('  ⚠ ~w potential piton(s) detected~n', [ZombieCount]),
        forall(member(C, Zombies),
               (narrative_ontology:constraint_metric(C, suppression_requirement, S),
                narrative_ontology:constraint_metric(C, resistance_to_change, R),
                format('    - ~w (S=~2f but R=~2f < 0.1)~n', [C, S, R]),
                assertz(validation_warning(piton, C, S-R)))))
    ;  format('  ✓ No pitons detected~n', [])),

    % Check for extreme values
    findall(C-M-V,
            (narrative_ontology:constraint_metric(C, M, V),
             (V > 0.95 ; V < 0.05),
             member(M, [extractiveness, suppression_requirement, resistance_to_change])),
            ExtremeValues),

    length(ExtremeValues, ExtCount),
    (ExtCount > 0
    -> (format('  ⚠ ~w extreme value(s) detected (>0.95 or <0.05)~n', [ExtCount]),
        forall(member(C-M-V, ExtremeValues),
               (format('    - ~w.~w = ~2f~n', [C, M, V]),
                assertz(validation_info(extreme_value, C-M-V)))))
    ;  format('  ✓ No extreme values~n', [])),

    nl.

/* ============================================================================
   6. DOMAIN COVERAGE VALIDATION
   ============================================================================ */

%% validate_domain_coverage/0
%  Checks distribution across domain categories.
validate_domain_coverage :-
    format('[CHECK 5: Domain Coverage]~n'),

    findall(Cat, domain_priors:category_of(_, Cat), AllCats),
    sort(AllCats, UniqueCats),
    length(UniqueCats, NumCats),

    format('  Found ~w domain categories~n', [NumCats]),

    forall(member(Cat, UniqueCats),
           (findall(C, domain_priors:category_of(C, Cat), Cs),
            length(Cs, Count),
            format('    - ~w: ~w constraint(s)~n', [Cat, Count]))),

    % Check for underrepresented categories
    findall(Cat,
            (member(Cat, UniqueCats),
             findall(C, domain_priors:category_of(C, Cat), Cs),
             length(Cs, Count),
             Count < 3),
            UnderRep),

    (UnderRep \= []
    -> (nl, format('  ⚠ Underrepresented categories (<3 constraints):~n'),
        forall(member(Cat, UnderRep),
               (format('    - ~w~n', [Cat]),
                assertz(validation_info(underrepresented_category, Cat)))))
    ;  true),

    nl.

/* ============================================================================
   7. VALIDATION SUMMARY
   ============================================================================ */

%% validation_summary/0
%  Displays summary of validation results.
validation_summary :-
    format('====================================================~n'),
    format('   VALIDATION SUMMARY                              ~n'),
    format('====================================================~n~n'),

    % Count errors
    findall(E, validation_error(_, _, E), Errors),
    length(Errors, ErrorCount),

    % Count warnings
    findall(W, validation_warning(_, _, W), Warnings),
    length(Warnings, WarningCount),

    % Count info
    findall(I, validation_info(_, I), Infos),
    length(Infos, InfoCount),

    format('Results:~n'),
    format('  Errors:   ~w~n', [ErrorCount]),
    format('  Warnings: ~w~n', [WarningCount]),
    format('  Info:     ~w~n~n', [InfoCount]),

    % Show errors
    (ErrorCount > 0
    -> (format('ERRORS:~n'),
        forall(validation_error(Type, C, Details),
               format('  [ERROR] ~w: ~w - ~w~n', [Type, C, Details])),
        nl)
    ;  true),

    % Show critical warnings
    (WarningCount > 0
    -> (format('WARNINGS:~n'),
        forall(validation_warning(Type, C, Details),
               format('  [WARN] ~w: ~w - ~w~n', [Type, C, Details])),
        nl)
    ;  true),

    % Overall assessment
    (ErrorCount = 0, WarningCount = 0
    -> format('✓ DATA QUALITY: EXCELLENT - No issues detected~n')
    ; ErrorCount = 0, WarningCount < 10
    -> format('✓ DATA QUALITY: GOOD - Minor warnings only~n')
    ; ErrorCount > 0, ErrorCount < 5
    -> format('⚠ DATA QUALITY: FAIR - Some errors need attention~n')
    ;  format('✗ DATA QUALITY: POOR - Multiple errors require fixes~n')
    ),

    format('~n====================================================~n').
:- module(data_verification, [
    verify_all/0,
    verify_interval_completeness/1,
    check_paired_measurements/0,
    diagnose_unknown/1
]).

:- use_module(library(lists)).        % Required for subtract/3
:- use_module(narrative_ontology).
:- use_module(config).

/* ============================================================
   1. ENTRY POINTS
   ============================================================ */

%% verify_all
%  Performs a full sweep of the loaded data against the v3.1 schema.
verify_all :-
    format('~n--- [START] Data Verification ---~n'),
    (validate_ontology -> format('[OK] Ontology Schema matches.~n') ; format('[FAIL] Schema mismatch.~n')),
    verify_structure,
    verify_measurements,
    check_paired_measurements,  % NEW: Check for paired temporal measurements
    verify_intent_logic,
    format('--- [END] Data Verification Complete ---~n').

/* ============================================================
   2. STRUCTURAL & VECTOR COMPLETENESS
   ============================================================ */

%% verify_structure
%  Ensures every interval has the required 32-point coercion vector.
verify_structure :-
    forall(interval(ID, T0, Tn),
           ( format('Checking Interval: ~w (~w-~w)~n', [ID, T0, Tn]),
             verify_interval_completeness(ID)
           )).

%% verify_interval_completeness(+IntervalID)
%  Checks for the presence of all 4 components across all 4 levels at T0 and Tn.
verify_interval_completeness(ID) :-
    interval(ID, T0, Tn),
    forall(level(L),
           ( verify_vector_at(L, T0, ID),
             verify_vector_at(L, Tn, ID)
           )).

verify_vector_at(Level, Time, ID) :-
    Components = [accessibility_collapse(Level), stakes_inflation(Level), 
                  suppression(Level), resistance(Level)],
    forall(member(Metric, Components),
           ( measurement(_, _, Metric, Time, _)
           -> true
           ;  format('  [MISSING] ~w for Level: ~w at T: ~w in ~w~n', [Metric, Level, Time, ID]),
              fail
           )).

/* ============================================================
   3. VALUE RANGE VALIDATION
   ============================================================ */

verify_measurements :-
    forall(measurement(ID, _, _, _, Val),
           ( number(Val), Val >= 0.0, Val =< 1.0
           -> true
           ;  format('  [VALUE ERROR] Measurement ~w is outside [0,1] range.~n', [ID]),
              fail
           )).

/* ============================================================
   4. INTENT LOGIC CONSISTENCY
   ============================================================ */

verify_intent_logic :-
    % Ensure every rejected alternative was first defined as viable (by anyone)
    % FIXED: Different entities can propose vs. reject - that's the whole point!
    % RELAXED: Allow rejecting implicit alternatives that weren't explicitly listed as viable
    forall(intent_alternative_rejected(I, _Rejecter, A),
           ( intent_viable_alternative(I, _Proposer, A)
           -> true
           ;  format('  [INFO] Alternative ~w rejected in ~w without explicit viable listing (may be implicit status quo).~n', [A, I])
           % REMOVED fail - this is informational, not an error
           )),
    % Ensure main beneficiary has a power change fact
    forall(intent_beneficiary_class(I, C),
           ( intent_power_change(I, C, _)
           -> true
           ;  format('  [MISSING DATA] Beneficiary ~w has no power_change delta in ~w.~n', [C, I]),
              fail
           )).

/* ============================================================
   5. PAIRED MEASUREMENT VALIDATION (MODAL LOGIC REQUIREMENT)
   ============================================================ */

%% check_paired_measurements
% Verifies that extractiveness and suppression_requirement measurements
% are paired at each time point for each constraint.
% CRITICAL: Modal logic requires BOTH metrics to classify constraints.
check_paired_measurements :-
    % Get all constraints that have any temporal measurements
    % CRITICAL FIX: Exclude intervals to avoid treating them as constraints
    setof(C, T^M^V^(measurement(M, C, _, T, V), entity(C, _)), Constraints),
    !,
    forall(member(C, Constraints),
           check_constraint_pairing(C)).

check_paired_measurements :- 
    % No temporal measurements found - skip check
    true.

%% check_constraint_pairing(+Constraint)
% Checks if a specific constraint has paired measurements
check_constraint_pairing(C) :-
    % Get all time points for extractiveness
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    % Get all time points for suppression_requirement
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    % Sort and compare
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  true  % Perfect pairing
    ;   XSorted = [], ESorted = []
    ->  true  % No temporal data (uses constraint_metric only)
    ;   % Unpaired measurements detected
        format('  [WARNING] Unpaired temporal measurements for ~w~n', [C]),
        (   XSorted \= []
        ->  format('    Extractiveness measured at: ~w~n', [XSorted])
        ;   format('    Extractiveness: No temporal measurements~n')
        ),
        (   ESorted \= []
        ->  format('    Suppression measured at: ~w~n', [ESorted])
        ;   format('    Suppression: No temporal measurements~n')
        ),
        format('    Impact: May cause "unknown" classification or use default values~n')
    ).

/* ============================================================
   6. DIAGNOSTIC TOOLS
   ============================================================ */

%% diagnose_unknown(+Constraint)
% Diagnostic tool for investigating "unknown" classifications
% Call this when dr_type(C, unknown) occurs
diagnose_unknown(C) :-
    format('~n=== DIAGNOSING UNKNOWN CLASSIFICATION: ~w ===~n', [C]),
    
    % Check if constraint exists
    (   constraint_claim(C, Claimed)
    ->  format('Claimed type: ~w~n', [Claimed])
    ;   format('WARNING: No constraint_claim for ~w~n', [C])
    ),
    
    % Check current metrics
    format('~nCurrent metrics (T_end):~n'),
    (   constraint_metric(C, extractiveness, X)
    ->  format('  Extractiveness: ~w~n', [X])
    ;   format('  Extractiveness: MISSING~n')
    ),
    (   constraint_metric(C, suppression_requirement, E)
    ->  format('  Suppression: ~w~n', [E])
    ;   format('  Suppression: MISSING~n')
    ),
    
    % Check temporal measurements
    format('~nTemporal measurements:~n'),
    findall(T, measurement(_, C, extractiveness, T, _), XTimes),
    findall(T, measurement(_, C, suppression_requirement, T, _), ETimes),
    (   XTimes \= []
    ->  format('  Extractiveness at times: ~w~n', [XTimes])
    ;   format('  Extractiveness: No temporal data~n')
    ),
    (   ETimes \= []
    ->  format('  Suppression at times: ~w~n', [ETimes])
    ;   format('  Suppression: No temporal data~n')
    ),
    
    % Check pairing
    format('~nPairing analysis:~n'),
    sort(XTimes, XSorted),
    sort(ETimes, ESorted),
    (   XSorted = ESorted
    ->  format('  ✓ Measurements are paired~n')
    ;   format('  ✗ UNPAIRED MEASUREMENTS DETECTED~n'),
        format('    This is likely causing the "unknown" classification~n')
    ),
    
    % Provide fix suggestion
    format('~nRecommended fix:~n'),
    (   XSorted \= [], ESorted = []
    ->  format('  Add suppression_requirement measurements at: ~w~n', [XSorted])
    ;   ESorted \= [], XSorted = []
    ->  format('  Add extractiveness measurements at: ~w~n', [ESorted])
    ;   XSorted \= [], ESorted \= []
    ->  subtract(XSorted, ESorted, MissingE),
        subtract(ESorted, XSorted, MissingX),
        (   MissingE \= []
        ->  format('  Add suppression_requirement at: ~w~n', [MissingE])
        ;   true
        ),
        (   MissingX \= []
        ->  format('  Add extractiveness at: ~w~n', [MissingX])
        ;   true
        )
    ;   format('  Add temporal measurements with both metrics~n')
    ),
    format('~n===========================================~n~n').
:- module(domain_priors, [
    get_prior/3,
    is_known_domain/1,
    flag_novelty/1,
    expected_signature/2,
    should_be_natural_law/1,
    validate_signature/2,
    category_of/2
]).

:- use_module(domain_registry).
:- use_module(drl_core).

:- multifile
    drl_core:base_extractiveness/2,
    drl_core:suppression_score/2,
    drl_core:requires_active_enforcement/1,
    drl_core:emerges_naturally/1.

drl_core:base_extractiveness(_, _) :- fail.
drl_core:suppression_score(_, _) :- fail.
drl_core:requires_active_enforcement(_) :- fail.
drl_core:emerges_naturally(_) :- fail.

%% ============================================================================
%% 1. CATEGORY PROFILES
%% ============================================================================
category_profile(physical_natural,    [1.00, 1.00, 0.00, 0.00]).  % Mountain
category_profile(formal_logic,        [0.90, 0.20, 0.10, 0.10]).  % Mountain
category_profile(statutory_formal,    [0.80, 0.50, 0.70, 0.40]).  % Rope
category_profile(election_cycle,      [0.80, 0.80, 0.30, 0.50]).  % Periodic Rope
category_profile(extractive_market,   [0.40, 0.80, 0.68, 0.60]).  % Calibrated Snare
category_profile(narrative_history,   [0.6, 0.7, 0.41, 0.6]).     % Calibrated Rope
category_profile(unknown_novel,       [0.55, 0.73, 0.52, 0.6]).   % Fleet Baseline
category_profile(mandatrophy_collapse,[0.20, 0.95, 0.90, 0.30]).  % Terminal State

%% ============================================================================
%% 2. API DEFINITIONS
%% ============================================================================

is_known_domain(ID) :- domain_category(ID, _), !.
is_known_domain(ID) :- base_extractiveness(ID, _), !.
is_known_domain(ID) :- suppression_score(ID, _), !.
is_known_domain(ID) :- narrative_ontology:constraint_claim(ID, _), !.

%% flag_novelty(+ID)
%  Logs a domain that doesn't match existing priors for later calibration.
flag_novelty(ID) :-
    \+ is_known_domain(ID),
    format('! NOTICE: Novel Domain "~w" detected. Using neutral (0.5) priors.~n', [ID]).
flag_novelty(_).

%% get_prior(+ID, +Metric, -Value)
%  Retrieves the baseline value: first tries domain-specific hooks,
%  then falls back to category profile, then neutral 0.5 default.
get_prior(ID, Metric, Value) :-
    map_metric_to_hook(Metric, Hook),
    call(domain_priors:Hook, ID, Value), !.
get_prior(ID, Metric, Value) :-
    category_of(ID, Cat),
    category_profile(Cat, Vector),
    map_metric_to_vector_pos(Metric, Vector, Value), !.
get_prior(_, _, 0.5).

%% category_of(+ID, -Category)
%  Determines the domain category for a constraint ID.
category_of(ID, Cat) :- domain_registry:domain_category(ID, Cat), !.
category_of(ID, physical_natural) :-
    (narrative_ontology:constraint_claim(ID, natural_law) ;
     narrative_ontology:constraint_claim(ID, physical_law)), !.
category_of(_, unknown_novel).

%% should_be_natural_law(+ID)
should_be_natural_law(ID) :-
    category_of(ID, Cat),
    expected_signature(Cat, natural_law).

%% expected_signature(?Category, ?Signature)
expected_signature(physical_natural,  natural_law).
expected_signature(formal_logic,      natural_law).
expected_signature(election_cycle,    constructed_constraint).
expected_signature(statutory_formal,  constructed_constraint).
expected_signature(extractive_market, constructed_constraint).
expected_signature(narrative_history, constructed_constraint).
expected_signature(unknown_novel,     ambiguous).

%% validate_signature(+ID, +Detected)
validate_signature(ID, Detected) :-
    category_of(ID, Cat),
    expected_signature(Cat, Expected),
    (   Detected = Expected
    ->  format('[VALIDATION] ~w: ~w matches ~w~n', [ID, Detected, Cat])
    ;   format('[VALIDATION] ~w: Expected ~w, got ~w~n', [ID, Expected, Detected])
    ).

%% ============================================================================
%% 3. INTERNAL HELPERS
%% ============================================================================

map_metric_to_hook(base_extractiveness(_), base_extractiveness).
map_metric_to_hook(extractiveness,         base_extractiveness).
map_metric_to_hook(suppression(_),          suppression_score).
map_metric_to_hook(suppression_requirement, suppression_score).

map_metric_to_vector_pos(accessibility_collapse(_), [A,_,_,_], A).
map_metric_to_vector_pos(stakes_inflation(_),      [_,S,_,_], S).
map_metric_to_vector_pos(suppression(_),           [_,_,U,_], U).
map_metric_to_vector_pos(resistance(_),            [_,_,_,R], R).

infer_category_from_priors(ID, extractive_market) :-
    base_extractiveness(ID, E), E > 0.6, !.
infer_category_from_priors(ID, statutory_formal) :-
    requires_active_enforcement(ID), !.
:- module(domain_priors_expanded, [
    get_corpus_prior/3,
    category_corpus_profile/2,
    type_corpus_profile/2,
    subcategory_profile/2,
    default_extractiveness/2,
    default_suppression/2,
    default_resistance/2,
    infer_category_defaults/4
]).

/**
 * DOMAIN PRIORS EXPANSION - Auto-generated from corpus analysis
 * Generated from 617 constraints
 * Categories analyzed: 3
 *
 * This module provides corpus-derived defaults for domain priors.
 * Use these when a new domain lacks explicit priors.
 */

%% ============================================================================
%% 1. CATEGORY CORPUS PROFILES (From Corpus Averages)
%% ============================================================================
%% Format: category_corpus_profile(Category, [AvgExtract, AvgSuppress, StdExtract, StdSuppress, Count]).

category_corpus_profile(narrative_history, [0.32, 0.465, 0.166, 0.245, 308]).  % dominant: mountain, enforcement_ratio: 0.44
category_corpus_profile(extractive_market, [0.801, 0.707, 0.078, 0.134, 306]).  % dominant: snare, enforcement_ratio: 0.82
category_corpus_profile(unknown_novel, [0.735, 0.825, 0.015, 0.025, 3]).  % dominant: tangled_rope, enforcement_ratio: 1.0

%% ============================================================================
%% 2. CONSTRAINT TYPE PROFILES (Mountain/Rope/Noose/Tangled Rope)
%% ============================================================================
%% Format: type_corpus_profile(Type, [AvgExtract, AvgSuppress, StdExtract, StdSuppress, Count]).

type_corpus_profile(mountain, [0.367, 0.452, 0.237, 0.256, 149]).
type_corpus_profile(snare, [0.655, 0.682, 0.218, 0.166, 89]).
type_corpus_profile(rope, [0.372, 0.462, 0.231, 0.26, 78]).
type_corpus_profile(tangled_rope, [0.529, 0.587, 0.233, 0.187, 47]).
type_corpus_profile(piton, [0.38, 0.16, 0.246, 0.049, 5]).

%% ============================================================================
%% 3. SUBCATEGORY PROFILES (Category + Type combinations)
%% ============================================================================
%% Format: subcategory_profile(SubcatName, [Parent, Type, AvgExtract, AvgSuppress, Count]).

subcategory_profile(narrative_history_mountain, ['narrative_history', 'mountain', 0.273, 0.401, 120]).
subcategory_profile(narrative_history_rope, ['narrative_history', 'rope', 0.296, 0.413, 65]).
subcategory_profile(extractive_market_snare, ['extractive_market', 'snare', 0.804, 0.749, 54]).
subcategory_profile(narrative_history_snare, ['narrative_history', 'snare', 0.418, 0.576, 34]).
subcategory_profile(extractive_market_mountain, ['extractive_market', 'mountain', 0.759, 0.662, 29]).
subcategory_profile(narrative_history_tangled_rope, ['narrative_history', 'tangled_rope', 0.325, 0.502, 24]).
subcategory_profile(extractive_market_tangled_rope, ['extractive_market', 'tangled_rope', 0.743, 0.662, 21]).
subcategory_profile(extractive_market_rope, ['extractive_market', 'rope', 0.752, 0.704, 13]).
subcategory_profile(narrative_history_piton, ['narrative_history', 'piton', 0.275, 0.15, 4]).

%% ============================================================================
%% 4. DEFAULT VALUE INFERENCE PREDICATES
%% ============================================================================

%% default_extractiveness(+Category, -Value)
%% Returns corpus-derived default extractiveness for a category.
default_extractiveness(Category, Value) :-
    category_corpus_profile(Category, [Value|_]), !.
default_extractiveness(_, 0.5).  % Neutral fallback

%% default_suppression(+Category, -Value)
%% Returns corpus-derived default suppression for a category.
default_suppression(Category, Value) :-
    category_corpus_profile(Category, [_, Value|_]), !.
default_suppression(_, 0.5).  % Neutral fallback

%% default_resistance(+Category, -Value)
%% Infers resistance from extractiveness (inverse correlation).
default_resistance(Category, Value) :-
    default_extractiveness(Category, Ext),
    Value is max(0.1, min(0.9, 1.0 - Ext * 0.5)), !.
default_resistance(_, 0.5).

%% infer_category_defaults(+Category, -Extractiveness, -Suppression, -Resistance)
%% Unified predicate to get all defaults for a category.
infer_category_defaults(Category, Ext, Sup, Res) :-
    default_extractiveness(Category, Ext),
    default_suppression(Category, Sup),
    default_resistance(Category, Res).

%% get_corpus_prior(+ID, +Metric, -Value)
%% Retrieves corpus-derived prior by constraint type.
get_corpus_prior(ID, extractiveness, Value) :-
    narrative_ontology:constraint_claim(ID, Type),
    type_corpus_profile(Type, [Value|_]), !.
get_corpus_prior(ID, suppression, Value) :-
    narrative_ontology:constraint_claim(ID, Type),
    type_corpus_profile(Type, [_, Value|_]), !.
get_corpus_prior(_, _, 0.5).  % Neutral fallback

%% ============================================================================
%% 5. RECOMMENDED CATEGORY PROFILE VECTORS
%% ============================================================================
%% These are corpus-calibrated replacements for the original category_profile/2.
%% Format: [accessibility_collapse, stakes_inflation, suppression, resistance]

% recommended_profile(narrative_history, [0.78, 0.38, 0.46, 0.81]).  % N=308, dominant=mountain
% recommended_profile(extractive_market, [0.59, 0.96, 0.71, 0.52]).  % N=306, dominant=snare

%% ============================================================================
%% END OF AUTO-GENERATED PRIORS
%% ============================================================================:- module(domain_registry, [domain_category/2]).
% --- AUTOMATICALLY GENERATED DOMAIN REGISTRY ---
% Thresholds aligned with config.pl: Rope <= 0.15, Snare >= 0.46, Tangled Rope 0.16-0.9.
% Total entries: 614

domain_category(abstraction_boundary_overrun, snare).
domain_category(abstraction_leakage, snare).
domain_category(academic_peer_review_gatekeeping, snare).
domain_category(ad_fus_coordination, snare).
domain_category(ad_synaptic_deficit, snare).
domain_category(adaptive_lag_trap, snare).
domain_category(adversarial_surface_inflation, snare).
domain_category(adversarial_truth_decay, snare).
domain_category(adverse_possession, rope).
domain_category(advice_as_dangerous_gift, tangled_rope).
domain_category(agency_atrophy, snare).
domain_category(aging_longevity_tests, mountain).
domain_category(ai_auditability_gap, snare).
domain_category(ai_cognitive_diversity_arbitrage, snare).
domain_category(ai_driven_surveillance_sensor_layer, snare).
domain_category(ai_edu_decentralization, rope).
domain_category(ai_professional_displacement, mountain).
domain_category(ai_task_horizon_reliability, tangled_rope).
domain_category(airbnb_str_regulation, mountain).
domain_category(algorithmic_bias, snare).
domain_category(algorithmic_epistemic_capture, snare).
domain_category(alignment_tax_tradeoff, snare).
domain_category(alternative_sovereignty_scaffold, rope).
domain_category(amish_technological_renunciation, snare).
domain_category(ancestral_pueblo_hydrology, snare).
domain_category(ancient_grudge_verona, mountain).
domain_category(anticipatory_capacity_failure, snare).
domain_category(antifragility, mountain).
domain_category(apartheid_nuclear_program, snare).
domain_category(arctic_geopolitical_flashpoint, snare).
domain_category(arrows_impossibility_theorem, mountain).
domain_category(artificial_scarcity_scaffold, snare).
domain_category(asce_7_22_seismic_design, mountain).
domain_category(asshole_filter_2015, snare).
domain_category(astm_d638_tensile_testing, rope).
domain_category(asymmetric_burden_distribution, snare).
domain_category(asymmetric_computational_difficulty, mountain).
domain_category(atrophied_optimization_piton, snare).
domain_category(attention_as_bottleneck_resource, snare).
domain_category(attention_market_cannibalization, snare).
domain_category(authoritarian_power_paradox, snare).
domain_category(automatic_enrollment_defaults, rope).
domain_category(autonomous_toolchain_sprawl, snare).
domain_category(availability_heuristic, mountain).
domain_category(awareness_without_leverage, snare).
domain_category(axiom_of_choice_determinacy, mountain).
domain_category(banach_fixed_point, mountain).
domain_category(banach_tarski_paradox, mountain).
domain_category(bangladesh_july_national_charter, snare).
domain_category(base_pair_complementarity, mountain).
domain_category(basel_problem_convergence, mountain).
domain_category(bay_of_pigs_operational_silo, snare).
domain_category(bedouin_sedentary_transition, snare).
domain_category(belief_argument_conclusion, mountain).
domain_category(berkshire_compounding_culture, rope).
domain_category(big_data_astrophysics_arbitrage, rope).
domain_category(biological_curiosity, snare).
domain_category(bip_narrative_illusion, snare).
domain_category(birthday_paradox_collision, mountain).
domain_category(blackstone_carried_interest_taxation, rope).
domain_category(blackstone_conflicts_of_interest, snare).
domain_category(blackstone_smd_control, snare).
domain_category(blackstone_tra, snare).
domain_category(bloom_acoustic_seduction_vigil, snare).
domain_category(bloom_aeolus_advertisement_circuit, snare).
domain_category(bloom_ithaca_mathematical_order, rope).
domain_category(bloom_kosher_transgression, snare).
domain_category(bloom_samaritan_paternal_care, snare).
domain_category(bloom_secret_correspondence, snare).
domain_category(bloom_social_exclusion_dublin, snare).
domain_category(bloom_xenophobic_exclusion, snare).
domain_category(boundary_dissolution_risk, snare).
domain_category(brain_network_paradigm_2026, mountain).
domain_category(brazil_2026_general_elections, snare).
domain_category(broke_vs_poor_grocery_math, snare).
domain_category(brouwer_fixed_point, mountain).
domain_category(buffons_needle_pi_estimation, mountain).
domain_category(burali_forti_paradox, mountain).
domain_category(burden_of_proof_engineering_safety, snare).
domain_category(burden_of_proof_legal_criminal, rope).
domain_category(burden_of_proof_scientific_empirical, mountain).
domain_category(bureaucratic_legibility_collapse, snare).
domain_category(bureaucratic_self_preservation, snare).
domain_category(bushman_money_magic, rope).
domain_category(busy_beaver_noncomputability, mountain).
domain_category(c_physical_blue_wavelength, mountain).
domain_category(cantor_set_topology, mountain).
domain_category(cap_theorem, mountain).
domain_category(capability_eval_overhang, snare).
domain_category(capital_misallocation_spiral, snare).
domain_category(carbon_credit_markets_2026, rope).
domain_category(carrying_capacity, mountain).
domain_category(cascading_constraint_failure, snare).
domain_category(castration_longevity_choice, snare).
domain_category(cbdc_implementation, rope).
domain_category(central_limit_theorem_convergence, mountain).
domain_category(chaitins_omega_undecidability, mountain).
domain_category(challenger_o_ring_integrity, snare).
domain_category(china_critical_mineral_chokepoint, snare).
domain_category(china_taiwan_reunification_mandate, mountain).
domain_category(church_turing_thesis, mountain).
domain_category(cia_fbi_legal_wall, mountain).
domain_category(circadian_decoupling_arbitrage, snare).
domain_category(citation_collapse_dynamics, snare).
domain_category(civilizational_maintenance_debt, mountain).
domain_category(click_chemistry_paradigm_2026, rope).
domain_category(climate_attribution_2026, rope).
domain_category(climate_target_one_point_five, tangled_rope).
domain_category(cloudflare_dual_class_asymmetry, snare).
domain_category(cobra_effect, snare).
domain_category(cognitive_diversity_arbitrage, rope).
domain_category(cognitive_energy_budget, snare).
domain_category(cognitive_induction_gap, snare).
domain_category(cognitive_mimicry_arbitrage, rope).
domain_category(cognitive_surrender_to_system_3, snare).
domain_category(coinbase_crypto_volatility, mountain).
domain_category(coinbase_regulatory_uncertainty, snare).
domain_category(collatz_conjecture_determinism, mountain).
domain_category(collective_action_deadlock, mountain).
domain_category(college_admissions_market, rope).
domain_category(colombia_2026_presidential_election, rope).
domain_category(colorado_sbe_decentralization_friction, mountain).
domain_category(comitatus_bond, rope).
domain_category(complexity_debt, snare).
domain_category(compounding_logic, snare).
domain_category(confirmation_bias, snare).
domain_category(consensus_without_truth, snare).
domain_category(constitutional_consecration, rope).
domain_category(constitutional_supremacy, mountain).
domain_category(constraint_interaction_explosion, snare).
domain_category(container_capacity_mismatch, snare).
domain_category(continuum_hypothesis_undecidability, mountain).
domain_category(conversational_dogmas_interruption, tangled_rope).
domain_category(conways_game_of_life_dynamics, mountain).
domain_category(coordination_attack_vulnerability, snare).
domain_category(coordination_fatigue, snare).
domain_category(coordination_threshold_failure, snare).
domain_category(copyleft_viral_licensing, rope).
domain_category(copyright_protection, tangled_rope).
domain_category(cost_of_observation, mountain).
domain_category(countable_infinity_cardinality, mountain).
domain_category(couples_residency_match, mountain).
domain_category(cow_field_poop, mountain).
domain_category(creative_commons_licensing, rope).
domain_category(credibility_inflation, snare).
domain_category(crisis_signal_saturation, snare).
domain_category(crispr_genomic_rewrite_2026, rope).
domain_category(critical_actor_overcentralization, snare).
domain_category(cross_domain_coupling_spiral, snare).
domain_category(cuba_mandatrophic_collapse, snare).
domain_category(cuban_missile_crisis_excomm_deliberation, rope).
domain_category(cultural_memory_decay, snare).
domain_category(currys_paradox, snare).
domain_category(damped_harmonics, mountain).
domain_category(dark_patterns_manipulation, snare).
domain_category(data_laundering_pipeline, snare).
domain_category(dead_sea_effect, snare).
domain_category(decentralized_infrastructure_rope, rope).
domain_category(decision_latency_mismatch, snare).
domain_category(deferential_realism_framework, rope).
domain_category(deferred_risk_realization, snare).
domain_category(delayed_feedback_instability, snare).
domain_category(demographic_inertia_trap, mountain).
domain_category(dexy_gold_protocol, rope).
domain_category(digital_credentialing_verification, rope).
domain_category(digital_identity_tether, snare).
domain_category(dionysiac_frenzy, mountain).
domain_category(dldr_information_policy, rope).
domain_category(dual_masters_dublin_1904, snare).
domain_category(dunbars_number, mountain).
domain_category(dunning_kruger_effect, tangled_rope).
domain_category(e2ee_digital_privacy_2026, rope).
domain_category(education_unbundling_implementation, rope).
domain_category(electrification_scale_2026, tangled_rope).
domain_category(elencher_identity_transformation, rope).
domain_category(elite_overproduction_instability, snare).
domain_category(em_clinical_guidelines, rope).
domain_category(emergency_bridge_scaffold, rope).
domain_category(emergency_mode_lock_in, snare).
domain_category(emergency_oversight_bureau, snare).
domain_category(emergency_powers_ratchet, snare).
domain_category(emergent_goal_misalignment, snare).
domain_category(empty_tomb_transformation, snare).
domain_category(endocrine_disruption_society, snare).
domain_category(endowment_effect, snare).
domain_category(epigenetics_complexity_2026, rope).
domain_category(epistemic_free_rider_problem, snare).
domain_category(epistemic_overload_collapse, snare).
domain_category(ergo_autolykos_asic_resistance, snare).
domain_category(ergo_lets_protocol, rope).
domain_category(ergo_mixer_protocol, tangled_rope).
domain_category(ergo_nipopows, rope).
domain_category(ergo_storage_rent, tangled_rope).
domain_category(ergo_storage_rent_mechanism, tangled_rope).
domain_category(ergodic_theorems, mountain).
domain_category(ergot_grain_poisoning, snare).
domain_category(erised_expectation, snare).
domain_category(euler_characteristic_topology, mountain).
domain_category(evidence_half_life, snare).
domain_category(evolutionary_knowledge, mountain).
domain_category(evolutionary_mismatch_load, snare).
domain_category(exoplanetary_habitability_arbitrage, rope).
domain_category(expert_disempowerment, snare).
domain_category(exploration_vs_exploitation, tangled_rope).
domain_category(extraordinary_narrative_shift, tangled_rope).
domain_category(factional_instability, snare).
domain_category(faint_blue_neural_bifurcation, snare).
domain_category(fair_use_doctrine, rope).
domain_category(family_estrangement_ratio, snare).
domain_category(family_succession_system, mountain).
domain_category(fast_growing_hierarchy, mountain).
domain_category(feedback_loop_desynchronization, snare).
domain_category(feigenbaum_universality, mountain).
domain_category(financial_drag, snare).
domain_category(finite_pool_of_worry, snare).
domain_category(finite_simple_group_classification, mountain).
domain_category(fiscal_dominance_trap, snare).
domain_category(fittss_law, mountain).
domain_category(fmeca_procedures_1980, rope).
domain_category(four_color_theorem_topological_bound, mountain).
domain_category(fragile_middle_layer_collapse, snare).
domain_category(framing_effect, snare).
domain_category(france_2027_presidential_election, mountain).
domain_category(france_cordon_sanitaire_2026, snare).
domain_category(france_local_elections_march_2026, scaffold).
domain_category(frankenstein_creation_hubris, snare).
domain_category(fundamental_theorem_of_algebra, mountain).
domain_category(gale_shapley, snare).
domain_category(galois_theory_symmetry, mountain).
domain_category(gamblers_ruin_stochastic_extinction, mountain).
domain_category(gauss_bonnet_topology, mountain).
domain_category(generational_replacement_inertia, mountain).
domain_category(genetic_algorithms_evolution, rope).
domain_category(genetic_predisposition, mountain).
domain_category(germline_regulation_threshold_2026, snare).
domain_category(gerrymandering_incumbency_2026, snare).
domain_category(gerty_bloom_voyeuristic_distance, snare).
domain_category(gestation_the_wombfruit, mountain).
domain_category(gig_economy_algorithmic_management, snare).
domain_category(gilgamesh_mortality_limit, snare).
domain_category(gita_kurukshetra, tangled_rope).
domain_category(global_protocol_entrenchment, mountain).
domain_category(global_stimulus_spree, snare).
domain_category(global_water_bankruptcy, snare).
domain_category(glp1_payload_efficiency_pivot, rope).
domain_category(goal_boundary_poisoning, snare).
domain_category(goedels_incompleteness_theorems, mountain).
domain_category(goldbach_conjecture, mountain).
domain_category(golden_handcuffs, tangled_rope).
domain_category(goodharts_law, snare).
domain_category(governance_latency_gap, snare).
domain_category(governance_overfitting, snare).
domain_category(gradient_descent_optimization, rope).
domain_category(graph_coloring_complexity, mountain).
domain_category(greenland_seizure_trade_war, snare).
domain_category(greshams_law, mountain).
domain_category(grete_samsa_transition, snare).
domain_category(grievance_stack_overflow, snare).
domain_category(gs1_gln_identification, rope).
domain_category(gs1_standardized_identification, rope).
domain_category(halting_problem_undecidability, mountain).
domain_category(hamiltonian_path_complexity, mountain).
domain_category(hammurabi_lex_talionis, mountain).
domain_category(hanlons_razor, tangled_rope).
domain_category(happiness_of_others, snare).
domain_category(harm_principle_liberty, rope).
domain_category(hawthorne_effect, snare).
domain_category(hedonic_adaptation_baseline, mountain).
domain_category(heisenberg_uncertainty, mountain).
domain_category(helsinki_bus_theory, rope).
domain_category(heuristic_optimization, rope).
domain_category(hidden_interdependency_risk, snare).
domain_category(hilberts_hotel_infinity, mountain).
domain_category(history_nightmare_1904, snare).
domain_category(hiv_prep_prevention_2026, rope).
domain_category(hoa_architectural_covenants, piton).
domain_category(hollow_state_syndrome, snare).
domain_category(hominin_evolutionary_bottleneck, snare).
domain_category(hp_liberalism, rope).
domain_category(hu_2026_election_rules, snare).
domain_category(hydra_game, mountain).
domain_category(hypercompression_of_time_horizons, snare).
domain_category(hypernormie_equilibrium, snare).
domain_category(ia_digital_preservation, snare).
domain_category(identity_stack_incompatibility, snare).
domain_category(incentive_surface_warping, snare).
domain_category(indexical_relativity_core, rope).
domain_category(individual_revolution_autonomy, snare).
domain_category(inference_cost_scaling_law, snare).
domain_category(information_foraging_theory, rope).
domain_category(infrastructure_decay_piton, snare).
domain_category(infrastructure_interoperability_decay, snare).
domain_category(inner_model_theory_constraints, mountain).
domain_category(innovators_dilemma, mountain).
domain_category(institutional_inertia_lock, snare).
domain_category(institutional_memory_loss, snare).
domain_category(institutional_mutation_domestication, rope).
domain_category(institutional_mutation_without_selection, snare).
domain_category(institutional_trust_decay, snare).
domain_category(insult_wisdom_training, snare).
domain_category(integrated_digital_governance_stack, rope).
domain_category(interface_contract_breakdown, snare).
domain_category(interpretive_frame_fragmentation, snare).
domain_category(intertemporal_responsibility_gap, snare).
domain_category(invisible_infrastructure_dependency, snare).
domain_category(iran_mandatrophic_collapse, snare).
domain_category(iron_law_of_oligarchy, mountain).
domain_category(irreversible_policy_commitment, mountain).
domain_category(isa_education_scaffold, snare).
domain_category(israel_electoral_threshold, snare).
domain_category(israel_norwegian_law, snare).
domain_category(israel_override_clause, snare).
domain_category(israel_surplus_vote_agreements, snare).
domain_category(japanese_energy_scaffold_2025, rope).
domain_category(jevons_paradox, rope).
domain_category(job_hunt_volume_system_2026, snare).
domain_category(keltner_relationship_evaluation, rope).
domain_category(khantivadin_radical_patience, snare).
domain_category(kidney_exchange_market, rope).
domain_category(kirby_paris_theorem, mountain).
domain_category(kjv_great_awakening, snare).
domain_category(kjv_linguistic_residue, mountain).
domain_category(kjv_puritan_new_world_exit, rope).
domain_category(kjv_textual_authority, mountain).
domain_category(kleene_recursion_theorem, mountain).
domain_category(knowledge_action_gap, mountain).
domain_category(landscape_of_fear_2026, snare).
domain_category(large_cardinal_foundations, mountain).
domain_category(latent_goal_activation, snare).
domain_category(latent_regulatory_bomb, snare).
domain_category(law_of_diminishing_returns, mountain).
domain_category(layered_brain_processing, snare).
domain_category(legacy_system_technical_debt, piton).
domain_category(legal_formalism_overhang, snare).
domain_category(legibility_trap, snare).
domain_category(legitimacy_without_capacity, snare).
domain_category(legitimacy_without_effectiveness, snare).
domain_category(lehman_repo_105, snare).
domain_category(lestrygonian_metabolism_chp8, snare).
domain_category(liar_paradox, mountain).
domain_category(lindy_effect, mountain).
domain_category(liquidity_illusion, snare).
domain_category(litany_of_the_real, mountain).
domain_category(lln_convergence, mountain).
domain_category(lobs_theorem, mountain).
domain_category(local_vs_global_optima, mountain).
domain_category(logistic_map_dynamics, mountain).
domain_category(lorenz_attractor_dynamics, mountain).
domain_category(lowenheim_skolem_theorem, mountain).
domain_category(lsd_microdosing_professional_openness, tangled_rope).
domain_category(lula_hemisphere_2026, snare).
domain_category(magna_carta_liberties, rope).
domain_category(maintenance_capacity_shortfall, snare).
domain_category(maladaptive_selection_process, snare).
domain_category(mandatrophic_margin_collapse, snare).
domain_category(mandatrophy_systemic_collapse, snare).
domain_category(mars_rover_navigational_autonomy, rope).
domain_category(martian_signal_latency, mountain).
domain_category(matching_markets_general, tangled_rope).
domain_category(material_tensile_strength, mountain).
domain_category(max_flow_min_cut, mountain).
domain_category(mco_unit_system_discontinuity, piton).
domain_category(med_diet_consensus_2026, snare).
domain_category(medical_residency_match, rope).
domain_category(medieval_church_hegemony, mountain).
domain_category(memetic_fitness_vs_truth, snare).
domain_category(meta_governance_overload, snare).
domain_category(meta_model_lock_in, snare).
domain_category(metabolic_constraint_cognition, mountain).
domain_category(metamorphosis_samsa, mountain).
domain_category(micro_robot_electronics_integration, snare).
domain_category(microbiome_symbiosis, tangled_rope).
domain_category(midnight_deadline, mountain).
domain_category(migration_decision_threshold, mountain).
domain_category(mil_std_461g_emi_control, rope).
domain_category(mil_std_810f_tailoring, rope).
domain_category(minimax_decision_rule, mountain).
domain_category(misunderstanding_as_mismatch, snare).
domain_category(model_autonomy_creep, snare).
domain_category(model_collapse_feedback_loop, snare).
domain_category(model_of_models_regression, snare).
domain_category(molly_affirmation_cycle, rope).
domain_category(monetary_regime_transition, rope).
domain_category(monty_hall_conditional_probability, mountain).
domain_category(moores_law, mountain).
domain_category(moral_outsourcing, snare).
domain_category(multi_agent_reward_hacking, snare).
domain_category(multi_planetary_latency_lock, mountain).
domain_category(mutual_defection_equilibrium, mountain).
domain_category(naming_as_control, snare).
domain_category(narrative_capacity_exhaustion, snare).
domain_category(narrative_overfitting, snare).
domain_category(nasa_faster_better_cheaper, snare).
domain_category(nash_equilibrium_coordination, mountain).
domain_category(necessary_day_job, snare).
domain_category(negative_emissions_arbitrage, rope).
domain_category(net_zero_stabilization, rope).
domain_category(network_effects, snare).
domain_category(neural_interoperability, snare).
domain_category(neurodiversity_spectrum, rope).
domain_category(neuroplasticity_plateau, mountain).
domain_category(newtons_method_convergence, rope).
domain_category(nighttown_hallucinatory_vigil, snare).
domain_category(nine_day_buffer, snare).
domain_category(no_cloning_theorem, mountain).
domain_category(noethers_theorem_symmetry, mountain).
domain_category(non_compete_agreements, rope).
domain_category(nonstandard_arithmetic_models, mountain).
domain_category(norm_erosion_threshold, snare).
domain_category(north_korea_songun_mandatrophy, snare).
domain_category(notary_ink_dependency, snare).
domain_category(omelet_perfection_complexity, rope).
domain_category(openbsd_netiquette_protocol, rope).
domain_category(optimal_stopping_marriage, mountain).
domain_category(optimization_fragility, snare).
domain_category(overfitting_to_frameworks, snare).
domain_category(overton_window, mountain).
domain_category(p_vs_np, mountain).
domain_category(parable_fish_turtle, snare).
domain_category(pareto_principle, mountain).
domain_category(paris_municipal_reform_2026, rope).
domain_category(parkinsons_law, mountain).
domain_category(path_dependence_lock_in, mountain).
domain_category(peano_curve_mapping, mountain).
domain_category(permissive_software_licensing, rope).
domain_category(perovskite_self_etching, snare).
domain_category(personalized_nutritional_arbitrage, snare).
domain_category(peter_principle, tangled_rope).
domain_category(planetary_boundaries, mountain).
domain_category(planetary_diet_constraint_2026, tangled_rope).
domain_category(planning_fallacy, snare).
domain_category(platform_cooperativism_governance, rope).
domain_category(platonic_coparenting, rope).
domain_category(poetic_verse_and_past, snare).
domain_category(poincare_conjecture, mountain).
domain_category(policy_lag_catastrophe, snare).
domain_category(politeness_face_negotiation, snare).
domain_category(portugal_ad_stability_2026, scaffold).
domain_category(portugal_polarization_threshold_2026, snare).
domain_category(portuguese_presidential_term_limits, mountain).
domain_category(postman_survival_protocol, rope).
domain_category(power_without_responsibility, snare).
domain_category(prestige_signal_inflation, snare).
domain_category(price_signal_corruption, snare).
domain_category(prime_number_theorem, mountain).
domain_category(prisoners_dilemma_equilibrium, mountain).
domain_category(private_identity_integration, rope).
domain_category(procedural_compliance_theater, snare).
domain_category(procedural_legitimacy_decay, snare).
domain_category(proof_of_work_consensus, rope).
domain_category(protean_signatures_1904, snare).
domain_category(protocol_capture_eee, snare).
domain_category(protocol_drift_accumulation, snare).
domain_category(public_domain_commons, mountain).
domain_category(pythagorean_geometric_constancy, mountain).
domain_category(qualified_immunity, rope).
domain_category(quantum_decryption_risk_2026, snare).
domain_category(quantum_entanglement_protocol, rope).
domain_category(quantum_nonlocality_2026, mountain).
domain_category(quellcrist_falconer_justice, rope).
domain_category(quine_self_replication, mountain).
domain_category(qwerty_vs_dvorak, snare).
domain_category(radiologic_diagnostic_threshold, mountain).
domain_category(railway_gauge_standard, piton).
domain_category(rational_inertia_trap, snare).
domain_category(recipe_scaling_ai, snare).
domain_category(reciprocity_laws_math, mountain).
domain_category(regulatory_capture, piton).
domain_category(relativity_of_simultaneity, mountain).
domain_category(relativity_physical_invariance, mountain).
domain_category(rent_seeking_equilibrium, snare).
domain_category(reputational_cascade_failure, snare).
domain_category(responsibility_dilution, snare).
domain_category(responsibility_without_power, snare).
domain_category(rfc9293_state_machine, mountain).
domain_category(rices_theorem_undecidability, mountain).
domain_category(risk_socialization_threshold, snare).
domain_category(ritual_transition_scaffold, rope).
domain_category(ritual_without_belief, snare).
domain_category(robustness_vs_efficiency_tradeoff, snare).
domain_category(rogers_commission_institutional_analysis, snare).
domain_category(rope_design, rope).
domain_category(rosen_bridge_protocol, rope).
domain_category(rotation_seven_black_soil, snare).
domain_category(rotation_seven_isolation, snare).
domain_category(rotation_seven_kubo_ranking, snare).
domain_category(royal_navy_middle_east_withdrawal, snare).
domain_category(rule_update_failure, snare).
domain_category(rules_based_international_order, snare).
domain_category(russells_paradox_self_reference, mountain).
domain_category(russian_war_cannibalization, snare).
domain_category(sadhu_integrity_protocol, rope).
domain_category(sapir_whorf_hypothesis, snare).
domain_category(sat_csp_complexity, mountain).
domain_category(scurvy_maritime_extraction, snare).
domain_category(second_order_unintended_consequences, snare).
domain_category(self_surpassing, rope).
domain_category(semantic_attack_surface, snare).
domain_category(semantic_overload_friction, snare).
domain_category(shadow_pricing_failure, snare).
domain_category(shannon_entropy_limit, mountain).
domain_category(shitty_feedback_handling, rope).
domain_category(shobies_existential_commitment, rope).
domain_category(shock_propagation_asymmetry, snare).
domain_category(sig_usd_protocol, rope).
domain_category(signal_without_control, snare).
domain_category(silent_dependency_activation, snare).
domain_category(silicon_lexicon_overload, snare).
domain_category(skills_based_hiring, rope).
domain_category(skolems_paradox, snare).
domain_category(sleep_debt_externality, snare).
domain_category(slow_crisis_invisibility, mountain).
domain_category(sludge_bureaucratic_friction, snare).
domain_category(smartphone_ubiquity, snare).
domain_category(social_credit_architecture, rope).
domain_category(social_loafing, snare).
domain_category(social_media_participation_threshold, snare).
domain_category(social_narrative_casting, snare).
domain_category(soft_authoritarian_drift, snare).
domain_category(solar_system_weirdness, rope).
domain_category(somatic_focusing_awareness, rope).
domain_category(sorites_paradox, mountain).
domain_category(south_china_sea_arbitration_2016_2026, mountain).
domain_category(spv_variations, mountain).
domain_category(square_cube_law, mountain).
domain_category(st_petersburg_paradox, mountain).
domain_category(stable_marriage_coordination, mountain).
domain_category(starwars_evolutionary_mutation, snare).
domain_category(statecraft_virtu, rope).
domain_category(status_flattening_effect, snare).
domain_category(steinmetz_valuation_asymmetry, mountain).
domain_category(stephen_shakespeare_ghost, mountain).
domain_category(stoic_logos_governance, snare).
domain_category(strait_coercion_2025, piton).
domain_category(strange_attractor_dynamics, mountain).
domain_category(structural_extraction_without_actor, snare).
domain_category(sts86_ascent_checklist, mountain).
domain_category(sturgeons_law, mountain).
domain_category(suanne_coup_of_peace, snare).
domain_category(suanne_face_restoration, snare).
domain_category(sunk_cost_fallacy, snare).
domain_category(suslin_hypothesis_undecidability, mountain).
domain_category(swift_legacy_piton, snare).
domain_category(swift_piton_snap, snare).
domain_category(sylow_theorems_group_theory, mountain).
domain_category(synthetic_data_feedback_loop, snare).
domain_category(systemic_blindspot, snare).
domain_category(tail_risk_compression, snare).
domain_category(taiwan_existential_sovereignty, rope).
domain_category(taiwan_grand_bargain, snare).
domain_category(taiwan_storm_2026, snare).
domain_category(taiwan_strait_hegemony_shift, snare).
domain_category(tarski_undefinability, mountain).
domain_category(taxonomy_drift, snare).
domain_category(tcp_rfc9293_interoperability, rope).
domain_category(teaching_horses_to_sing, rope).
domain_category(technocratic_overreach, snare).
domain_category(technological_point_of_no_return, mountain).
domain_category(technological_provenance_arbitrage, rope).
domain_category(tehran_water_bankruptcy, snare).
domain_category(temporal_resolution_mismatch, snare).
domain_category(temporal_scale_arbitrage, rope).
domain_category(texas_hispanic_political_pivot, snare).
domain_category(thai_article_112_mountain, mountain).
domain_category(thai_senate_veto_2026, snare).
domain_category(thailand_2017_constitution, snare).
domain_category(the_bacchae_madness_protocol, snare).
domain_category(the_calm_protocol_suppression, snare).
domain_category(the_churn_systemic_upheaval, mountain).
domain_category(the_novelty_gradient, snare).
domain_category(the_stochastic_snare, snare).
domain_category(the_viceregal_cavalcade, snare).
domain_category(the_wall_procedural_barrier, snare).
domain_category(theory_of_visitors, snare).
domain_category(thermodynamics_entropy, mountain).
domain_category(three_body_unpredictability, mountain).
domain_category(threshold_effect_miscalibration, snare).
domain_category(too_big_to_manage, snare).
domain_category(tool_use_delegation_risk, snare).
domain_category(toxic_social_infection, snare).
domain_category(tractarian_logic_limit, mountain).
domain_category(trade_secret_law, tangled_rope).
domain_category(tragedy_of_the_commons, mountain).
domain_category(transformer_self_attention, rope).
domain_category(transient_event_detection, mountain).
domain_category(transitional_utility_bridge, snare).
domain_category(traveling_salesperson_problem, mountain).
domain_category(trojan_war_spoils, snare).
domain_category(trump_authoritarianism_2026, snare).
domain_category(trump_making_china_great_2026, snare).
domain_category(truth_by_repetition_effect, snare).
domain_category(udhr_1948, rope).
domain_category(unclos_2026, rope).
domain_category(union_protection_underperformance, rope).
domain_category(universal_mathematics_communication, mountain).
domain_category(us_hydrological_debt, snare).
domain_category(us_suburban_zoning_2025, snare).
domain_category(us_two_party_duopoly, snare).
domain_category(utopia_apocalypse_fragility, mountain).
domain_category(value_alignment_drift, snare).
domain_category(value_extraction_plateau, snare).
domain_category(value_learning_instability, snare).
domain_category(van_der_waerden_theorem, mountain).
domain_category(viral_transmission_rates, mountain).
domain_category(visa_ipo_regulatory_compliance, mountain).
domain_category(visa_judgment_sharing_agreement, rope).
domain_category(visibility_bias_governance, snare).
domain_category(weber_fechner_law, mountain).
domain_category(whitehead_problem_undecidability, mountain).
domain_category(wikipedia_crowdsourcing_2026, rope).
domain_category(wikipedia_notability_requirement_2026, mountain).
domain_category(winners_curse, mountain).
domain_category(xi_mao_ideological_centralization, mountain).
domain_category(zipfs_law, snare).
% ============================================================================
% DR-AUDIT CORE: drl_audit_core.pl
% ============================================================================
:- module(drl_audit_core, [
    effective_extraction/3,
    structural_signature/3,
    ontological_fraud_check/2,
    omega_risk/4
]).

:- use_module(constraint_indexing). % Canonical source for power_modifier/2

% --- II-D: CHI CALCULATION (chi) ---
% chi(C, P) = X_base(C) * pi(P)
% Uses constraint_indexing:power_modifier/2 as the single source of truth.
effective_extraction(X_base, Power, Chi) :-
    constraint_indexing:power_modifier(Power, Modifier),
    Chi is X_base * Modifier.

% --- III-A: STRUCTURAL SIGNATURES ---
% Uses config thresholds where possible; these are quick-check audit signatures.

% Tangled Rope (TR): Hybrid coordination/extraction
structural_signature(Chi, Data, tangled_rope) :-
    Chi >= 0.40,
    Chi =< 0.90,
    member(coord_function(true), Data),
    !.
% Snare (N): Pure extraction
structural_signature(Chi, _, snare) :-
    Chi >= 0.46,
    !.
% Rope (R): Pure coordination
structural_signature(Chi, _, rope) :-
    Chi =< 0.15,
    !.
% Mountain (M): Default/Unscaled limit
structural_signature(_, _, mountain).

% --- IV-B: Omega Risks ---
omega_risk(snare, rope, type_iii, "Extraction masked as coordination.").
omega_risk(snare, mountain, type_vi, "Naturalization of extraction.").

% --- IV-C: FORENSIC AUDIT TOOLS (Diagnostic Flags) ---

% False Summit (FM): High enforcement masquerading as natural law
% Logic: Claimed=mountain AND epsilon > 0.60
ontological_fraud_check(Data, fm_alert) :-
    member(claimed_type(mountain), Data),
    member(suppression_score(Epsilon), Data),
    Epsilon > 0.60, !.

% Zero Degrees of Freedom (Z): The absolute trap
% Logic: epsilon -> 1.0 AND chi -> 1.0
ontological_fraud_check(Data, z_alert) :-
    member(suppression_score(Epsilon), Data),
    Epsilon >= 0.90,
    member(base_extractiveness(X_base), Data),
    X_base >= 0.85, !.

ontological_fraud_check(_, coherent).
% ============================================================================
% DRL CORE - INDEXICAL CONSTRAINT CLASSIFICATION v4.0
% ============================================================================
% This module implements context-indexed Deferential Realism classification.
% Every Mountain/Rope/Snare judgment is INDEXED to WHO/WHEN/WHERE/HOW.
%
% BREAKING CHANGES FROM v3.x:
% - dr_type/2 now defaults to analytical context (backward compatible)
% - dr_type/3 is PRIMARY API (adds Context parameter)
% - All classification uses power-scaled extractiveness
% - Structural signatures integrated with indexical logic
% - Action routing context-aware
%
% Integration: Load after constraint_indexing.pl, before drl_modal_logic.pl
% ============================================================================

:- module(drl_core, [
    % PRIMARY API - Context-Indexed Classification
    dr_type/3,                      % dr_type(Constraint, Context, Type)
    dr_type/2,                      % Backward compat: uses default context
    
    % Action Routing (Indexed)
    dr_action/3,                    % dr_action(Constraint, Context, Action)
    dr_action/2,                    % Backward compat
    
    % Error Detection (Indexed)
    dr_mismatch/4,                  % dr_mismatch(C, Context, ErrorType, Severity)
    dr_mismatch/3,                  % Backward compat
    
    % Structural Signature Integration
    dr_signature/2,                 % dr_signature(Constraint, Signature)
    
    % Re-exported from constraint_indexing
    constraint_classification/3,    % Multifile hook for data files
    constraint_claim_indexed/2,     % Legacy wrapper
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1,

    % Centralize module references
    base_extractiveness/2,
    suppression_score/2,
    requires_active_enforcement/1,
    emerges_naturally/1,
    
    % Exposed helpers for modal_logic and testing
    is_mountain/3,                  % Indexed version
    is_rope/3,
    is_snare/3,
    is_tangled_rope/3,
    is_scaffold/3,
    is_piton/3,
    calculate_scaled_metric/5
]).

:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(constraint_instances).
:- use_module(domain_priors).

% Declare these as multifile to allow other modules to contribute data
:- multifile 
    base_extractiveness/2, 
    suppression_score/2, 
    requires_active_enforcement/1, 
    emerges_naturally/1.

% Delegate to domain_priors as the canonical source of truth.
% Multifile declarations above allow testsets to contribute directly,
% but v3.4 testsets assert into domain_priors: namespace, so we bridge here.
% Delegate to narrative_ontology for dynamic metric retrieval
base_extractiveness(C, V) :- 
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(C, ExtMetricName, V).
suppression_score(C, V) :- 
    config:param(suppression_metric_name, SuppMetricName),
    narrative_ontology:constraint_metric(C, SuppMetricName, V).
requires_active_enforcement(C) :- domain_priors:requires_active_enforcement(C).
emerges_naturally(C) :- domain_priors:emerges_naturally(C).

% ============================================================================
% SCALING LAW - PENALIZE COORDINATION AT SCALE (NEW Jan 2026)
% ============================================================================
% As spatial scope increases, coordination becomes more difficult and
% the potential for extractive asymmetries grows. This penalty models
% the "Dunbar-sensitive" scaling observation from sociology.md.

scope_penalty(local,       0.0).  % Baseline
scope_penalty(regional,    0.15). % e.g., State/Province
scope_penalty(national,    0.40). % e.g., Country
scope_penalty(continental, 0.75). % e.g., EU
scope_penalty(global,      1.20). % Worldwide
scope_penalty(universal,   2.0).  % Abstract/Universal claims

%% temporal_penalty(+TimeHorizon, -PenaltyFactor)
%  Models the "discount" or reduced impact of constraints over longer time horizons.
%  Rule: Metric_eff = Metric * PenaltyFactor
temporal_penalty(immediate,      1.0). % No discount for immediate effects
temporal_penalty(biographical,   0.8). % Discount for effects over a lifetime
temporal_penalty(generational,   0.5). % Significant discount for generational effects
temporal_penalty(historical,     0.2). % Steep discount for historical scale
temporal_penalty(civilizational, 0.1). % Very steep discount for civilizational scale

%% calculate_scaled_metric(+ConfigParamName, +Constraint, +Scope, +Time, -ScaledValue)
%  Calculates a metric value adjusted for both spatial scope and time horizon.
%  ConfigParamName: The name of the config parameter holding the actual metric name (e.g., suppression_metric_name)
%  Constraint: The constraint ID
%  Scope: The spatial scope from the context
%  Time: The time horizon from the context
%  ScaledValue: The calculated metric value after applying scope and time adjustments.
calculate_scaled_metric(ConfigParamName, Constraint, Scope, Time, ScaledValue) :-
    config:param(ConfigParamName, ActualMetricName), % Get the actual metric name from config
    (narrative_ontology:constraint_metric(Constraint, ActualMetricName, BaseValue) -> true; BaseValue = 0),
    (scope_penalty(Scope, ScopeFactor) -> true ; ScopeFactor = 0),
    (temporal_penalty(Time, TimeFactor) -> true ; TimeFactor = 1.0),
    ScaledValue is BaseValue * (1 + ScopeFactor) * TimeFactor.

% Re-export indexed classification predicates from constraint_indexing
:- reexport(constraint_indexing, [
    constraint_classification/3,
    constraint_claim_indexed/2,
    multi_index_report/1,
    compare_perspectives/2,
    discover_my_context/1
]).

% ============================================================================
% CLASSIFICATION LOGIC - INDEXED VERSION (PRIMARY)
% ============================================================================

% ----------------------------------------------------------------------------
% Mountain Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Mountain FROM A CONTEXT if:
% 1. It appears immutable given time horizon + exit options
% 2. Suppression requirement (scaled) is below threshold

is_mountain(C, Context, mountain) :-
    Context = context(_, time_horizon(Time), _, spatial_scope(Scope)),
    % Check time-based immutability perception
    constraint_indexing:effective_immutability_for_context(Context, mountain),
    
    % Check suppression is low (inherent, not enforced), adjusted for scale
    config:param(mountain_suppression_ceiling, Ceil),
    calculate_scaled_metric(suppression_metric_name, C, Scope, Time, E_eff),
    E_eff =< Ceil,
    !.

is_mountain(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Rope FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) is below threshold
% 2. It's changeable (time horizon allows modification)

is_rope(C, Context, rope) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check against rope threshold
    config:param(rope_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % Must be perceived as changeable
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Snare Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Snare FROM A CONTEXT if:
% 1. Effective extractiveness (power-scaled) exceeds floor
% 2. Requires active suppression (enforced)
% 3. Perceived as changeable (not Mountain)

is_snare(C, Context, snare) :-
    Context = context(_, time_horizon(Time), _, spatial_scope(Scope)),
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Check extraction floor
    config:param(snare_extraction_floor, XFloor),
    EffectiveX >= XFloor,
    
    % Check suppression requirement, adjusted for scale
    config:param(snare_suppression_floor, EFloor),
    calculate_scaled_metric(suppression_metric_name, C, Scope, Time, E_eff),
    E_eff >= EFloor,
    
    % Must NOT appear as Mountain from this context
    constraint_indexing:effective_immutability_for_context(Context, rope),
    !.

is_snare(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Tangled Rope Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Tangled Rope FROM A CONTEXT if:
% 1. Effective extractiveness in middle-to-high range (uses config params)
% 2. High suppression (uses config params)
% 3. Has BOTH coordination function AND asymmetric extraction
% 4. Requires active enforcement
%
% Updated January 2026 based on empirical validation (168/467 constraints, 36%)
%
% This is genuinely hybrid: provides coordination (like rope) while extracting
% (like snare). Requires surgical reform to preserve coordination while cutting extraction.

is_tangled_rope(C, Context, tangled_rope) :-
    Context = context(_, time_horizon(Time), _, spatial_scope(Scope)),
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),

    % Check tangled rope range (from config)
    config:param(tangled_rope_extraction_floor, FloorX),
    config:param(tangled_rope_extraction_ceil, CeilX),
    EffectiveX >= FloorX,
    EffectiveX =< CeilX,

    % High suppression required (from config), adjusted for scale
    config:param(tangled_rope_suppression_floor, MinS),
    calculate_scaled_metric(suppression_metric_name, C, Scope, Time, S_eff),
    S_eff >= MinS,

    % Must require active enforcement (constructed constraint)
    requires_active_enforcement(C),

    % Must have both coordination function AND asymmetric extraction
    narrative_ontology:has_coordination_function(C),
    narrative_ontology:has_asymmetric_extraction(C),
    !.

is_tangled_rope(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Scaffold Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Scaffold FROM A CONTEXT if:
% 1. Effective extraction is below the coordination ceiling (v3.4: 0.30)
% 2. It possesses a genuine coordination function
% 3. It contains a formal sunset clause (temporal limit)
% 4. The time horizon (T) has not exceeded the designated utility period
%
% Scaffolds are temporary supports. High suppression is only acceptable if 
% it is designed to decline or expire as the system stabilizes.

is_scaffold(C, Context, scaffold) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),

    % Check scaffold ceiling (v3.4 requirement: extraction < 0.30)
    config:param(scaffold_extraction_ceil, MaxX),
    EffectiveX =< MaxX,

    % Must possess a coordination function (the "support" aspect)
    narrative_ontology:has_coordination_function(C),

    % Mandatory: Must have a sunset clause to distinguish from a permanent Rope
    narrative_ontology:has_sunset_clause(C),

    % Validate Indexical Alignment (Time Horizon T)
    % Scaffolds typically expire before 'civilizational' or 'historical' scales.
    Context = context(_, time_horizon(T), _, _),
    member(T, [immediate, biographical, generational]),

    % Ensure it is not currently flagged as 'degraded' (Piton check)
    config:param(theater_metric_name, TheaterMetricName),
    \+ (narrative_ontology:constraint_metric(C, TheaterMetricName, TR), TR > 0.70),
    !.

is_scaffold(_C, _Context, fail).

% ----------------------------------------------------------------------------
% Piton Test (Indexed)
% ----------------------------------------------------------------------------
% A constraint is a Piton FROM A CONTEXT if:
% 1. Low effective extractiveness
% 2. High suppression (expensive to maintain)
% 3. Should be cut but isn't

is_piton(C, Context, piton) :-
    % Calculate power-scaled extractiveness
    constraint_indexing:extractiveness_for_agent(C, Context, EffectiveX),
    
    % Low extraction
    config:param(piton_extraction_ceiling, XCeil),
    EffectiveX =< XCeil,
    
    % High suppression (maintenance cost)
    config:param(theater_metric_name, TheaterMetricName),
    \+ (narrative_ontology:constraint_metric(C, TheaterMetricName, TR), TR > 0.70),
    !.

is_piton(_C, _Context, fail).

% ============================================================================
% CANONICAL TYPE DETERMINATION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Classification: dr_type/3
% ----------------------------------------------------------------------------
% Determines constraint type FROM A SPECIFIC CONTEXT
% Integrates: (1) Metric-based classification, (2) Structural signatures

dr_type(C, Context, Type) :-
    % Validate context
    constraint_indexing:valid_context(Context),
    
    % First: Try metric-based classification with power scaling
    metric_based_type_indexed(C, Context, MetricType),
    
    % Second: Check if structural signature overrides
    structural_signatures:integrate_signature_with_modal(C, MetricType, Type),
    !.

dr_type(_C, _Context, unknown).

% ----------------------------------------------------------------------------
% Metric-Based Classification (Indexed) - Helper
% ----------------------------------------------------------------------------

metric_based_type_indexed(C, Context, mountain) :-
    is_mountain(C, Context, mountain), !.

metric_based_type_indexed(C, Context, snare) :-
    is_snare(C, Context, snare), !.

metric_based_type_indexed(C, Context, rope) :-
    is_rope(C, Context, rope), !.

metric_based_type_indexed(C, Context, tangled_rope) :-
    is_tangled_rope(C, Context, tangled_rope), !.

metric_based_type_indexed(C, Context, piton) :-
    is_piton(C, Context, piton), !.

metric_based_type_indexed(_C, _Context, unknown).

% ============================================================================
% BACKWARD COMPATIBILITY LAYER
% ============================================================================

% ----------------------------------------------------------------------------
% Legacy dr_type/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_type(C, Type) :-
    constraint_indexing:default_context(Ctx),
    dr_type(C, Ctx, Type).

% ============================================================================
% ACTION ROUTING (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Primary Action Router: dr_action/3
% ----------------------------------------------------------------------------
% Recommends action based on constraint type FROM SPECIFIC CONTEXT

dr_action(C, Context, accept) :-
    dr_type(C, Context, mountain), !.

dr_action(C, Context, maintain) :-
    dr_type(C, Context, rope), !.

dr_action(C, Context, reform) :-
    dr_type(C, Context, tangled_rope), !.

dr_action(C, Context, cut) :-
    dr_type(C, Context, snare), !.

dr_action(C, Context, bypass) :-
    dr_type(C, Context, piton), !.

dr_action(_C, _Context, investigate).

% ----------------------------------------------------------------------------
% Legacy dr_action/2 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_action(C, Action) :-
    constraint_indexing:default_context(Ctx),
    dr_action(C, Ctx, Action).

% ============================================================================
% ERROR DETECTION (INDEXED)
% ============================================================================

% ----------------------------------------------------------------------------
% Type 1: False Mountain (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Mountain but ISN'T from this context

dr_mismatch(C, Context, type_1_false_summit, severe) :-
    % Check if claimed as mountain in data
    narrative_ontology:constraint_claim(C, mountain),
    
    % Verify it's NOT a mountain from this context
    is_mountain(C, Context, fail),
    !.

% ----------------------------------------------------------------------------
% Type 3: Snare Misidentified as Rope (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Rope but is actually Snare from this context

dr_mismatch(C, Context, type_3_snare_as_rope, severe) :-
    narrative_ontology:constraint_claim(C, rope),
    is_snare(C, Context, snare),
    !.

% ----------------------------------------------------------------------------
% Type 5: Piton Misidentified as Snare (Indexed)
% ----------------------------------------------------------------------------
% Claimed as Snare but is actually Piton from this context

dr_mismatch(C, Context, type_5_piton_as_snare, moderate) :-
    narrative_ontology:constraint_claim(C, theater_ratio, TR), TR >= 0.70,
    is_piton(C, Context, piton),
    !.

% ----------------------------------------------------------------------------
% Type 7: Perspectival Incoherence (NEW)
% ----------------------------------------------------------------------------
% Same constraint classified differently across meaningful perspectives
% This is NOT an error but a FEATURE - it indicates indexical relativity

dr_mismatch(C, perspectival_gap(Type1, Ctx1, Type2, Ctx2), 
            perspectival_incoherence, informational) :-
    % Find two different classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Types must differ
    Type1 \= Type2,
    
    % Contexts must differ in meaningful way (not analytical vs analytical)
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    P1 \= analytical,
    P2 \= analytical,
    P1 \= P2,
    !.

% ----------------------------------------------------------------------------
% Legacy dr_mismatch/3 - Defaults to Analytical Context
% ----------------------------------------------------------------------------

dr_mismatch(C, ErrorType, Severity) :-
    constraint_indexing:default_context(Ctx),
    dr_mismatch(C, Ctx, ErrorType, Severity).

% ============================================================================
% STRUCTURAL SIGNATURE DETECTION
% ============================================================================

%% dr_signature(+Constraint, -Signature)
%  Detects structural signature: natural_law | coordination_scaffold | 
%  constructed_constraint | ambiguous
%
%  NOTE: Signatures are NOT indexed - they represent the constraint's
%        fundamental structure, not perspectival appearance

dr_signature(C, Signature) :-
    structural_signatures:constraint_signature(C, Signature).

% ============================================================================
% PERSPECTIVAL GAP DETECTION (NEW)
% ============================================================================

%% perspectival_gap(+Constraint, -GapReport)
%  Detects when same constraint classifies differently across perspectives
%  Returns structured gap information for Omega generation

perspectival_gap(C, gap(Type1, Ctx1, Type2, Ctx2, PowerDelta)) :-
    % Find two classifications
    constraint_indexing:constraint_classification(C, Type1, Ctx1),
    constraint_indexing:constraint_classification(C, Type2, Ctx2),
    
    % Must differ in type
    Type1 \= Type2,
    
    % Extract power levels
    Ctx1 = context(agent_power(P1), _, _, _),
    Ctx2 = context(agent_power(P2), _, _, _),
    
    % Must be non-analytical
    P1 \= analytical,
    P2 \= analytical,
    
    % Must differ in power
    P1 \= P2,
    
    % Calculate power delta for severity assessment
    constraint_indexing:power_modifier(P1, Mod1),
    constraint_indexing:power_modifier(P2, Mod2),
    PowerDelta is abs(Mod1 - Mod2),
    !.

% ============================================================================
% INDEXICAL ANALYSIS UTILITIES (NEW)
% ============================================================================

%% cross_context_analysis(+Constraint, -Analysis)
%  Analyzes how constraint appears across standard contexts
%  Useful for validation and debugging

cross_context_analysis(C, Analysis) :-
    findall(
        context_result(Ctx, Type),
        (standard_context(Ctx),
         dr_type(C, Ctx, Type)),
        Results
    ),
    Analysis = cross_context(C, Results).

% Standard contexts for testing
standard_context(context(agent_power(powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

% ============================================================================
% VERSION & COMPATIBILITY INFO
% ============================================================================

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: dr_type/3 is now primary API (added Context)
  - NEW: Full indexical relativity integration
  - NEW: Power-scaled extractiveness in all classifications
  - NEW: Perspectival gap detection
  - NEW: dr_action/3, dr_mismatch/4 (indexed versions)
  - CHANGED: All classification uses effective_extractiveness
  - MAINTAIN: Backward compatibility via dr_type/2, dr_action/2

v3.2:
  - Added structural signature integration
  - Signature overrides metric-based classification

v3.1:
  - Consolidated namespace
  - Added piton detection

v3.0:
  - Initial metric-based classification

MIGRATION GUIDE v3.x → v4.0:
  Old: dr_type(constraint, Type)
  New: dr_type(constraint, Context, Type)
  
  For backward compat, old form still works (uses analytical context).
  
  To get indexed classification:
    constraint_indexing:default_context(Ctx),  % or build custom context
    dr_type(constraint, Ctx, Type)
*/
:- module(drl_lifecycle, [
    % --- Individual Drift Event Detectors ---
    detect_metric_substitution/1,
    detect_extraction_accumulation/1,
    detect_coordination_loss/1,
    detect_function_obsolescence/1,
    detect_sunset_violation/1,
    detect_extraction_dried_up/1,
    detect_is_piton/1,

    % --- Structured Drift Event API ---
    drift_event/3,                  % drift_event(ConstraintID, EventType, Evidence)
    drift_event/4,                  % drift_event(ConstraintID, Context, EventType, Evidence)

    % --- Transition Path Detection ---
    transition_path/4,              % transition_path(ConstraintID, FromType, ToType, Evidence)
    degradation_chain/3,            % degradation_chain(ConstraintID, Chain, Evidence)
    predicted_terminal_state/3,     % predicted_terminal_state(ConstraintID, State, Confidence)

    % --- Drift Velocity ---
    drift_velocity/3,               % drift_velocity(ConstraintID, Metric, Rate)
    drift_acceleration/3,           % drift_acceleration(ConstraintID, Metric, Accel)

    % --- Severity Classification ---
    drift_severity/3,               % drift_severity(ConstraintID, EventType, Severity)

    % --- Unified Scan ---
    scan_all_drift/1,               % scan_all_drift(-Report)
    scan_constraint_drift/2,        % scan_constraint_drift(+ConstraintID, -Events)
    scan_constraint_drift/3,        % scan_constraint_drift(+ConstraintID, +Context, -Events)

    % --- Drift Report ---
    generate_drift_report/0,        % Print full drift report to stdout
    generate_drift_report/1         % generate_drift_report(+ConstraintID)
]).

:- use_module(narrative_ontology).
:- use_module(domain_priors).
:- use_module(config).
:- use_module(drl_core).
:- use_module(constraint_indexing).

/* ================================================================
   DRL LIFECYCLE MODULE

   Detects constraint degradation patterns (drift events),
   transition paths, drift velocity, and severity.

   Seven drift event types from core.md:
   1. metric_substitution  - Proxy becomes goal (Goodhart)
   2. extraction_accumulation - Rent-seeking added over time
   3. coordination_loss    - Function withers, extraction persists
   4. function_obsolescence - Environment shifts, constraint outdated
   5. sunset_violation     - Temporary becomes permanent
   6. extraction_dried_up  - Mechanism fails, structure persists
   7. internalized_piton   - Enforcer removed, habits remain

   Canonical degradation paths from core.md:
   - rope -> tangled_rope -> snare -> piton
   - rope -> piton (direct obsolescence)
   - scaffold -> piton (sunset violation)
   - scaffold -> snare (calcification with extraction)
   - scaffold -> tangled_rope (extraction added during transition)
   - snare -> false_mountain (naturalization)
   - snare -> piton (internalized piton)
   ================================================================ */

/* ================================================================
   1. UTILITY
   ================================================================ */

%% get_current_year(-Year)
%  Retrieves the current year from the system clock.
get_current_year(Year) :-
    get_time(Stamp),
    stamp_date_time(Stamp, DateTime, local),
    DateTime = date(Year, _, _, _, _, _, _, _, _).

%% safe_metric(+C, +Metric, -Value)
%  Retrieves a metric or fails silently.
safe_metric(C, Metric, Value) :-
    narrative_ontology:constraint_metric(C, Metric, Value).

%% metric_delta(+C, +Metric, -T1, -T2, -Delta)
%  Finds the earliest and latest measurements and computes the change.
metric_delta(C, Metric, T1, T2, Delta) :-
    findall(T-V, narrative_ontology:measurement(_, C, Metric, T, V), Pairs),
    Pairs = [_|_],
    sort(Pairs, Sorted),
    Sorted = [T1-V1|_],
    last(Sorted, T2-V2),
    T2 > T1,
    Delta is V2 - V1.

%% metric_at(+C, +Metric, +Time, -Value)
%  Retrieves measurement at a specific time.
metric_at(C, Metric, Time, Value) :-
    narrative_ontology:measurement(_, C, Metric, Time, Value).

%% metric_trend(+C, +Metric, -Trend)
%  Determines if a metric is increasing, decreasing, or stable.
metric_trend(C, Metric, Trend) :-
    metric_delta(C, Metric, _, _, Delta),
    (   Delta > 0.05  -> Trend = increasing
    ;   Delta < -0.05 -> Trend = decreasing
    ;   Trend = stable
    ).

/* ================================================================
   2. INDIVIDUAL DRIFT EVENT DETECTORS
   Each detector both prints diagnostics AND succeeds/fails.
   ================================================================ */

%% detect_metric_substitution(+ConstraintID)
%  Goodhart drift: proxy metric becomes the goal.
%  Evidence: theater_ratio rising above 0.5 across time points.
detect_metric_substitution(C) :-
    narrative_ontology:measurement(_, C, theater_ratio, T1, TR1),
    narrative_ontology:measurement(_, C, theater_ratio, T2, TR2),
    T2 > T1,
    TR2 > TR1,
    TR2 > 0.5,
    format('  Drift: Metric Substitution in ~w~n', [C]),
    format('    Theater ratio ~2f (~w) -> ~2f (~w)~n', [TR1, T1, TR2, T2]).

%% detect_extraction_accumulation(+ConstraintID)
%  Rent-seeking accumulates over time.
detect_extraction_accumulation(C) :-
    narrative_ontology:measurement(_, C, base_extractiveness, T1, V1),
    narrative_ontology:measurement(_, C, base_extractiveness, T2, V2),
    T2 > T1,
    V2 > V1,
    format('  Drift: Extraction Accumulation in ~w~n', [C]),
    format('    Extractiveness ~2f (~w) -> ~2f (~w)~n', [V1, T1, V2, T2]).

%% detect_coordination_loss(+ConstraintID)
%  Coordination withers while extraction persists.
detect_coordination_loss(C) :-
    narrative_ontology:has_coordination_function(C),
    narrative_ontology:measurement(_, C, coordination_effectiveness, T1, CE1),
    narrative_ontology:measurement(_, C, coordination_effectiveness, T2, CE2),
    T2 > T1,
    CE2 < CE1,
    CE2 < 0.3,
    safe_metric(C, extractiveness, E),
    E > 0.4,
    format('  Drift: Coordination Loss in ~w~n', [C]),
    format('    Coordination dropped to ~2f, extraction still ~2f~n', [CE2, E]).

%% detect_function_obsolescence(+ConstraintID)
%  Original function obsolete due to alternatives.
detect_function_obsolescence(C) :-
    safe_metric(C, alternatives_available, Alt),
    Alt > 0,
    safe_metric(C, resistance_to_change, R),
    R < 0.3,
    safe_metric(C, theater_ratio, TR),
    TR > 0.5,
    format('  Drift: Function Obsolescence in ~w~n', [C]),
    format('    Alternatives exist (~w), low resistance (~2f), high theater (~2f)~n', [Alt, R, TR]).

%% detect_sunset_violation(+ConstraintID)
%  Temporary constraint became permanent.
detect_sunset_violation(C) :-
    narrative_ontology:has_sunset_clause(C),
    safe_metric(C, sunset_time, SunsetYear),
    get_current_year(CurrentYear),
    CurrentYear > SunsetYear,
    format('  Drift: Sunset Violation in ~w~n', [C]),
    format('    Sunset was ~w, now ~w~n', [SunsetYear, CurrentYear]).

%% detect_extraction_dried_up(+ConstraintID)
%  Extraction mechanism failed but structure persists (zombie constraint).
detect_extraction_dried_up(C) :-
    safe_metric(C, extractiveness, E),
    E < 0.10,
    safe_metric(C, suppression_requirement, S),
    S > 0.50,
    format('  Drift: Extraction Dried Up in ~w~n', [C]),
    format('    Extraction ~2f but suppression still ~2f~n', [E, S]).

%% detect_is_piton(+ConstraintID)
%  Internalized piton: extraction removed but habits remain.
detect_is_piton(C) :-
    safe_metric(C, extractiveness, E),
    E < 0.10,
    safe_metric(C, theater_ratio, TR),
    TR > 0.70,
    \+ narrative_ontology:requires_active_enforcement(C),
    format('  Drift: Internalized Piton in ~w~n', [C]),
    format('    Low extraction (~2f), high theater (~2f), no enforcement~n', [E, TR]).

/* ================================================================
   3. STRUCTURED DRIFT EVENT API
   Returns data structures instead of printing.
   ================================================================ */

%% drift_event(+ConstraintID, -EventType, -Evidence)
%  Non-indexed drift detection. Returns structured evidence.
drift_event(C, metric_substitution, evidence(theater_delta, T1, T2, TR1, TR2)) :-
    narrative_ontology:measurement(_, C, theater_ratio, T1, TR1),
    narrative_ontology:measurement(_, C, theater_ratio, T2, TR2),
    T2 > T1, TR2 > TR1, TR2 > 0.5.

drift_event(C, extraction_accumulation, evidence(extraction_delta, T1, T2, V1, V2)) :-
    narrative_ontology:measurement(_, C, base_extractiveness, T1, V1),
    narrative_ontology:measurement(_, C, base_extractiveness, T2, V2),
    T2 > T1, V2 > V1.

drift_event(C, coordination_loss, evidence(coordination_drop, CE2, extraction_persist, E)) :-
    narrative_ontology:has_coordination_function(C),
    narrative_ontology:measurement(_, C, coordination_effectiveness, T1, CE1),
    narrative_ontology:measurement(_, C, coordination_effectiveness, T2, CE2),
    T2 > T1, CE2 < CE1, CE2 < 0.3,
    safe_metric(C, extractiveness, E), E > 0.4.

drift_event(C, function_obsolescence, evidence(alternatives, Alt, resistance, R, theater, TR)) :-
    safe_metric(C, alternatives_available, Alt), Alt > 0,
    safe_metric(C, resistance_to_change, R), R < 0.3,
    safe_metric(C, theater_ratio, TR), TR > 0.5.

drift_event(C, sunset_violation, evidence(sunset_year, SunsetYear, current_year, CurrentYear)) :-
    narrative_ontology:has_sunset_clause(C),
    safe_metric(C, sunset_time, SunsetYear),
    get_current_year(CurrentYear),
    CurrentYear > SunsetYear.

drift_event(C, extraction_dried_up, evidence(extraction, E, suppression, S)) :-
    safe_metric(C, extractiveness, E), E < 0.10,
    safe_metric(C, suppression_requirement, S), S > 0.50.

drift_event(C, internalized_piton, evidence(extraction, E, theater, TR)) :-
    safe_metric(C, extractiveness, E), E < 0.10,
    safe_metric(C, theater_ratio, TR), TR > 0.70,
    \+ narrative_ontology:requires_active_enforcement(C).

%% drift_event(+ConstraintID, +Context, -EventType, -Evidence)
%  Context-indexed drift detection.
%  Same degradation can look different from different power positions.
%  A moderate-extraction constraint may appear as extraction_accumulation
%  from a powerless context (amplified by pi=1.5) but stable from
%  an institutional context (reduced by pi=-0.2).
drift_event(C, Context, extraction_accumulation_indexed, evidence(effective_chi, Chi, trend, Trend)) :-
    constraint_indexing:valid_context(Context),
    constraint_indexing:extractiveness_for_agent(C, Context, Chi),
    config:param(rope_extraction_ceiling, RopeCeil),
    Chi > RopeCeil,
    metric_trend(C, base_extractiveness, Trend),
    Trend = increasing.

drift_event(C, Context, false_mountain_drift, evidence(claimed, mountain, actual, ActualType)) :-
    constraint_indexing:valid_context(Context),
    narrative_ontology:constraint_claim(C, mountain),
    drl_core:dr_type(C, Context, ActualType),
    ActualType \= mountain.

drift_event(C, Context, load_bearing_degradation, evidence(type, Type, extraction, Chi)) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, Type),
    member(Type, [snare, tangled_rope]),
    constraint_indexing:extractiveness_for_agent(C, Context, Chi),
    config:param(snare_load_bearing_threshold, T),
    Chi > T,
    metric_trend(C, base_extractiveness, increasing).

/* ================================================================
   4. TRANSITION PATH DETECTION
   Detects the canonical degradation paths from core.md.
   ================================================================ */

%% transition_path(+ConstraintID, -FromType, -ToType, -Evidence)
%  Detects a constraint in the process of transitioning between types.
%  Uses current metrics + drift events to infer the transition.

% Rope -> Tangled Rope (extraction accumulating into coordination)
transition_path(C, rope, tangled_rope, evidence(extraction_rising, E, has_coordination, true)) :-
    drl_core:dr_type(C, Type),
    Type = rope,
    safe_metric(C, extractiveness, E),
    config:param(rope_extraction_ceiling, Ceil),
    E > Ceil * 0.7,  % Within 30% of ceiling
    narrative_ontology:has_coordination_function(C),
    metric_trend(C, base_extractiveness, increasing).

% Tangled Rope -> Snare (coordination dying while extraction grows)
transition_path(C, tangled_rope, snare, evidence(coordination_declining, true, extraction, E)) :-
    drl_core:dr_type(C, Type),
    Type = tangled_rope,
    safe_metric(C, extractiveness, E),
    config:param(snare_extraction_floor, Floor),
    E > Floor * 0.8,  % Approaching snare threshold
    (   drift_event(C, coordination_loss, _)
    ;   metric_trend(C, coordination_effectiveness, decreasing)
    ).

% Rope -> Piton (direct obsolescence, no extraction phase)
transition_path(C, rope, piton, evidence(function_obsolete, true, theater_high, TR)) :-
    drl_core:dr_type(C, Type),
    Type = rope,
    safe_metric(C, theater_ratio, TR),
    TR > 0.5,
    drift_event(C, function_obsolescence, _).

% Scaffold -> Piton (sunset violation)
transition_path(C, scaffold, piton, evidence(sunset_violated, true)) :-
    drl_core:dr_type(C, Type),
    Type = scaffold,
    drift_event(C, sunset_violation, _).

% Scaffold -> Snare (calcification with extraction)
transition_path(C, scaffold, snare, evidence(extraction_added, E, sunset_violated, Violated)) :-
    drl_core:dr_type(C, Type),
    Type = scaffold,
    safe_metric(C, extractiveness, E),
    config:param(snare_extraction_floor, Floor),
    E > Floor * 0.7,
    (   drift_event(C, sunset_violation, _)
    ->  Violated = true
    ;   Violated = false
    ).

% Scaffold -> Tangled Rope (extraction added during transition)
transition_path(C, scaffold, tangled_rope, evidence(extraction_emerging, E, coordination_intact, true)) :-
    drl_core:dr_type(C, Type),
    Type = scaffold,
    safe_metric(C, extractiveness, E),
    config:param(tangled_rope_extraction_floor, Floor),
    E > Floor * 0.7,
    narrative_ontology:has_coordination_function(C).

% Snare -> I-Piton (internalization)
transition_path(C, snare, piton, evidence(internalized, true)) :-
    drl_core:dr_type(C, Type),
    Type = snare,
    drift_event(C, internalized_piton, _).

% Snare -> False Mountain (naturalization)
transition_path(C, snare, false_mountain, evidence(naturalized, true, claimed, mountain)) :-
    drl_core:dr_type(C, Type),
    Type = snare,
    narrative_ontology:constraint_claim(C, mountain).

%% degradation_chain(+ConstraintID, -Chain, -Evidence)
%  Detects multi-step degradation chains by examining measurement history.
%  Returns the full chain of types observed across time points.
degradation_chain(C, Chain, evidence(time_span, T1, T2)) :-
    findall(T-Type,
            (narrative_ontology:measurement(_, C, _, T, _),
             classify_snapshot(C, T, Type)),
            RawPairs),
    RawPairs \= [],
    sort(RawPairs, Sorted),
    pairs_values(Sorted, TypeList),
    deduplicate_consecutive(TypeList, Chain),
    length(Chain, Len),
    Len > 1,
    Sorted = [T1-_|_],
    last(Sorted, T2-_).

%% classify_snapshot(+C, +Time, -Type)
%  Classifies a constraint at a specific time using measurements available.
classify_snapshot(C, Time, Type) :-
    (   metric_at(C, base_extractiveness, Time, E)
    ->  true
    ;   safe_metric(C, extractiveness, E)
    ->  true
    ;   E = 0.5
    ),
    (   metric_at(C, suppression_requirement, Time, S)
    ->  true
    ;   safe_metric(C, suppression_requirement, S)
    ->  true
    ;   S = 0.5
    ),
    snapshot_type(C, E, S, Type).

snapshot_type(_, E, S, mountain) :-
    config:param(mountain_suppression_ceiling, SCeil),
    config:param(mountain_extractiveness_max, ECeil),
    S =< SCeil, E =< ECeil, !.
snapshot_type(C, E, S, tangled_rope) :-
    config:param(tangled_rope_extraction_floor, EFloor),
    config:param(tangled_rope_suppression_floor, SFloor),
    E >= EFloor, S >= SFloor,
    narrative_ontology:has_coordination_function(C), !.
snapshot_type(_, E, S, snare) :-
    config:param(snare_extraction_floor, EFloor),
    config:param(snare_suppression_floor, SFloor),
    E >= EFloor, S >= SFloor, !.
snapshot_type(_, E, _, rope) :-
    config:param(rope_extraction_ceiling, ECeil),
    E =< ECeil, !.
snapshot_type(_, E, _, piton) :-
    config:param(piton_extraction_ceiling, ECeil),
    E =< ECeil, !.
snapshot_type(_, _, _, unknown).

%% predicted_terminal_state(+ConstraintID, -State, -Confidence)
%  Predicts where a constraint is heading based on current drift events
%  and transition paths.
predicted_terminal_state(C, piton, high) :-
    drift_event(C, function_obsolescence, _),
    drift_event(C, extraction_dried_up, _), !.

predicted_terminal_state(C, piton, high) :-
    drift_event(C, internalized_piton, _), !.

predicted_terminal_state(C, piton, medium) :-
    drift_event(C, sunset_violation, _), !.

predicted_terminal_state(C, snare, high) :-
    transition_path(C, tangled_rope, snare, _), !.

predicted_terminal_state(C, snare, medium) :-
    drift_event(C, extraction_accumulation, _),
    drift_event(C, coordination_loss, _), !.

predicted_terminal_state(C, tangled_rope, medium) :-
    transition_path(C, rope, tangled_rope, _), !.

predicted_terminal_state(C, tangled_rope, low) :-
    drift_event(C, extraction_accumulation, _),
    narrative_ontology:has_coordination_function(C), !.

predicted_terminal_state(_, stable, low).

/* ================================================================
   5. DRIFT VELOCITY AND ACCELERATION
   ================================================================ */

%% drift_velocity(+ConstraintID, +Metric, -RatePerYear)
%  Rate of change per year for a given metric.
drift_velocity(C, Metric, Rate) :-
    metric_delta(C, Metric, T1, T2, Delta),
    Duration is T2 - T1,
    Duration > 0,
    Rate is Delta / Duration.

%% drift_acceleration(+ConstraintID, +Metric, -Acceleration)
%  Whether drift is accelerating, decelerating, or constant.
%  Uses three measurement points minimum.
drift_acceleration(C, Metric, Acceleration) :-
    findall(T-V, narrative_ontology:measurement(_, C, Metric, T, V), Pairs),
    sort(Pairs, Sorted),
    length(Sorted, N), N >= 3,
    compute_acceleration(Sorted, Acceleration).

compute_acceleration(Sorted, Acceleration) :-
    Sorted = [T1-V1, T2-V2, T3-V3|_],
    D1 is T2 - T1, D1 > 0,
    D2 is T3 - T2, D2 > 0,
    R1 is (V2 - V1) / D1,
    R2 is (V3 - V2) / D2,
    RateDelta is R2 - R1,
    (   RateDelta > 0.01  -> Acceleration = accelerating
    ;   RateDelta < -0.01 -> Acceleration = decelerating
    ;   Acceleration = constant
    ).

/* ================================================================
   6. SEVERITY CLASSIFICATION
   ================================================================ */

%% drift_severity(+ConstraintID, +EventType, -Severity)
%  Classifies drift severity: critical | warning | watch
%
%  Critical: Active harm likely without intervention.
%  Warning: Degradation in progress, intervention recommended.
%  Watch: Early indicators, monitor closely.

drift_severity(C, sunset_violation, critical) :-
    drift_event(C, sunset_violation, _),
    safe_metric(C, extractiveness, E), E > 0.3, !.
drift_severity(_, sunset_violation, warning).

drift_severity(C, extraction_accumulation, critical) :-
    drift_event(C, extraction_accumulation, evidence(_, _, _, _, V2)),
    config:param(snare_extraction_floor, Floor),
    V2 >= Floor, !.
drift_severity(C, extraction_accumulation, warning) :-
    drift_event(C, extraction_accumulation, evidence(_, _, _, _, V2)),
    config:param(tangled_rope_extraction_floor, Floor),
    V2 >= Floor, !.
drift_severity(_, extraction_accumulation, watch).

drift_severity(_, coordination_loss, critical) :-
    !.  % Coordination loss is always critical (irreversible harm likely)

drift_severity(_, internalized_piton, warning).

drift_severity(_, extraction_dried_up, warning).

drift_severity(C, metric_substitution, Severity) :-
    (   safe_metric(C, theater_ratio, TR), TR > 0.7
    ->  Severity = critical
    ;   Severity = warning
    ), !.

drift_severity(_, function_obsolescence, watch).

% Default
drift_severity(_, _, watch).

/* ================================================================
   7. UNIFIED SCAN
   ================================================================ */

%% scan_constraint_drift(+ConstraintID, -Events)
%  Scans a single constraint for all drift events.
%  Returns list of drift(EventType, Evidence, Severity).
scan_constraint_drift(C, Events) :-
    findall(
        drift(EventType, Evidence, Severity),
        (   drift_event(C, EventType, Evidence),
            drift_severity(C, EventType, Severity)
        ),
        Events
    ).

%% scan_constraint_drift(+ConstraintID, +Context, -Events)
%  Context-indexed scan: includes both standard and indexed drift events.
scan_constraint_drift(C, Context, Events) :-
    findall(
        drift(EventType, Evidence, Severity),
        (   (   drift_event(C, EventType, Evidence)
            ;   drift_event(C, Context, EventType, Evidence)
            ),
            drift_severity(C, EventType, Severity)
        ),
        Events
    ).

%% scan_all_drift(-Report)
%  Scans all known constraints for drift events.
%  Returns report(TotalConstraints, TotalEvents, Critical, Warning, Watch, Details).
scan_all_drift(Report) :-
    findall(C, narrative_ontology:constraint_claim(C, _), AllCs),
    sort(AllCs, Constraints),
    length(Constraints, NumConstraints),
    findall(
        constraint_drift(C, Events),
        (   member(C, Constraints),
            scan_constraint_drift(C, Events),
            Events \= []
        ),
        Details
    ),
    count_by_severity(Details, Critical, Warning, Watch),
    flatten_events(Details, AllEvents),
    length(AllEvents, TotalEvents),
    Report = report(NumConstraints, TotalEvents, Critical, Warning, Watch, Details).

count_by_severity(Details, Critical, Warning, Watch) :-
    flatten_events(Details, AllEvents),
    include(is_severity(critical), AllEvents, Cs), length(Cs, Critical),
    include(is_severity(warning), AllEvents, Ws), length(Ws, Warning),
    include(is_severity(watch), AllEvents, As), length(As, Watch).

is_severity(Sev, drift(_, _, Sev)).

flatten_events([], []).
flatten_events([constraint_drift(_, Events)|Rest], All) :-
    flatten_events(Rest, RestAll),
    append(Events, RestAll, All).

/* ================================================================
   8. DRIFT REPORT GENERATION
   ================================================================ */

%% generate_drift_report/0
%  Generates a full drift event report across all constraints.
generate_drift_report :-
    format('~n================================================================~n'),
    format('  DRIFT EVENT REPORT~n'),
    format('================================================================~n~n'),
    scan_all_drift(report(NumC, NumE, Critical, Warning, Watch, Details)),
    format('  Constraints scanned: ~w~n', [NumC]),
    format('  Total drift events:  ~w~n', [NumE]),
    format('  Critical: ~w | Warning: ~w | Watch: ~w~n~n', [Critical, Warning, Watch]),
    (   Details = []
    ->  format('  No drift events detected.~n')
    ;   forall(member(constraint_drift(C, Events), Details),
              print_constraint_drift(C, Events))
    ),
    format('~n--- Transition Path Analysis ---~n'),
    forall(
        (narrative_ontology:constraint_claim(C2, _), transition_path(C2, From, To, Ev)),
        format('  ~w: ~w -> ~w (~w)~n', [C2, From, To, Ev])
    ),
    format('~n--- Terminal State Predictions ---~n'),
    forall(
        (narrative_ontology:constraint_claim(C3, _), predicted_terminal_state(C3, State, Conf), State \= stable),
        format('  ~w -> ~w (confidence: ~w)~n', [C3, State, Conf])
    ),
    format('~n================================================================~n').

%% generate_drift_report(+ConstraintID)
%  Generates drift report for a single constraint.
generate_drift_report(C) :-
    format('~n--- Drift Analysis: ~w ---~n', [C]),
    scan_constraint_drift(C, Events),
    (   Events = []
    ->  format('  No drift events detected.~n')
    ;   forall(member(drift(Type, Ev, Sev), Events),
              format('  [~w] ~w: ~w~n', [Sev, Type, Ev]))
    ),
    % Transition paths
    (   transition_path(C, From, To, TEv)
    ->  format('  Transition: ~w -> ~w (~w)~n', [From, To, TEv])
    ;   true
    ),
    % Terminal state prediction
    predicted_terminal_state(C, State, Conf),
    (   State \= stable
    ->  format('  Predicted terminal: ~w (confidence: ~w)~n', [State, Conf])
    ;   format('  No degradation trajectory detected.~n')
    ),
    % Velocity
    (   drift_velocity(C, base_extractiveness, Rate)
    ->  format('  Extraction drift velocity: ~4f/year~n', [Rate])
    ;   true
    ),
    format('~n').

print_constraint_drift(C, Events) :-
    format('  ~w:~n', [C]),
    forall(member(drift(Type, Evidence, Severity), Events),
           format('    [~w] ~w~n        Evidence: ~w~n', [Severity, Type, Evidence])).

/* ================================================================
   9. HELPER PREDICATES
   ================================================================ */

%% deduplicate_consecutive(+List, -Deduped)
%  Removes consecutive duplicates: [a,a,b,b,a] -> [a,b,a]
deduplicate_consecutive([], []).
deduplicate_consecutive([X], [X]).
deduplicate_consecutive([X,X|Rest], Deduped) :-
    !, deduplicate_consecutive([X|Rest], Deduped).
deduplicate_consecutive([X,Y|Rest], [X|Deduped]) :-
    X \= Y,
    deduplicate_consecutive([Y|Rest], Deduped).

%% last(+List, -Last)
last([X], X).
last([_|T], X) :- last(T, X).

%% pairs_values(+Pairs, -Values)
pairs_values([], []).
pairs_values([_-V|Rest], [V|Vs]) :- pairs_values(Rest, Vs).
% ============================================================================
% DRL MODAL LOGIC - INDEXICAL VERSION v4.0
% ============================================================================
% This module implements context-indexed modal reasoning for Deferential Realism.
% All dependency chains, transformations, and counterfactuals are relative to
% WHO is analyzing/intervening and WHEN they're doing it.
%
% BREAKING CHANGES FROM v3.x:
% - dependency_chain/4 → dependency_chain/5 (added Context)
% - assess_scaffold_need/2 → assess_scaffold_need/3 (added Context)
% - simulate_cut/2 → simulate_cut/3 (added Context)
% - composite_type/3 → composite_type/4 (added Context)
% - All counterfactual reasoning now indexed
%
% KEY INSIGHT: "Load-bearing" depends on WHO is cutting the constraint.
% What's load-bearing for powerless individual may be non-essential for institution.
%
% Integration: Load after drl_core.pl (v4.0+)
% ============================================================================

:- module(drl_modal_logic, [
    % Stage 1: Composition Rules (INDEXED)
    composite_type/4,               % Added Context parameter
    composite_type/3,               % Backward compat
    composition_rule/3,
    detect_extraction_dominance/2,
    detect_necessity_inheritance/2,
    
    % Stage 2: Transformation Tracking (Context-aware)
    constraint_history/3,           % Added Context parameter
    constraint_history/2,           % Backward compat
    transformation_detected/5,      
    transformation_type/6,
    canonical_transformation/6,
    predict_transformation/3,
    
    % Stage 3: Counterfactual Reasoning (INDEXED)
    simulate_cut/3,                 % Added Context parameter
    simulate_cut/2,                 % Backward compat
    dependency_chain/5,             % Added Context parameter
    dependency_chain/4,             % Backward compat
    infer_structural_coupling/3,
    assess_scaffold_need/3,         % Added Context parameter
    assess_scaffold_need/2,         % Backward compat
    counterfactual_world/4,         % Added Context parameter
    counterfactual_world/3,         % Backward compat

    % Stage 4: Audit
    possibly/1,
    necessarily/1,
    is_snare/1,
    is_mountain/1,
    is_rope/1
]).

:- use_module(drl_audit_core).
:- use_module(drl_core).
:- use_module(constraint_indexing).
:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(coercion_projection).

:- dynamic agent_index/2.
:- dynamic constraint_data/2.

% Scaled for the Powerless
is_snare(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, powerless, Chi),
    drl_audit_core:structural_signature(Chi, Data, snare).

% Scaled for the Observer
is_mountain(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, analytical, Chi),
    drl_audit_core:structural_signature(Chi, Data, mountain).

% Scaled for the Beneficiary
is_rope(C) :- 
    constraint_data(C, Data),
    member(base_extractiveness(Base), Data),
    drl_audit_core:effective_extraction(Base, institutional, Chi),
    drl_audit_core:structural_signature(Chi, Data, rope).

/* ================================================================
   MODAL LOGIC EXTENSION FOR DEFERENTIAL REALISM v4.0
   
   VERSION 4.0 CHANGES:
   - Full indexical relativity integration
   - All dependency analysis is context-relative
   - "Load-bearing" now indexed to WHO is cutting
   - Scaffold assessment indexed to WHO needs transition
   - Theorem 3 ("cutting load-bearing Snare requires Scaffold")
     now evaluates per perspective
   
   CRITICAL THEOREM 3 UPGRADE:
   OLD: "If Snare is load-bearing, cutting requires Scaffold"
   NEW: "If Snare is load-bearing FROM CONTEXT C, cutting from C requires Scaffold"
   
   Example: Property rights
   - FROM powerless context: load-bearing Mountain (shelter dependency)
   - FROM institutional context: non-essential Rope (coordination choice)
   - Institutional cutting WITHOUT considering powerless dependency = catastrophe
   
   This module implements three stages of indexed modal reasoning:
   1. Composition Rules - how constraints interact (context-aware)
   2. Transformation Tracking - temporal evolution (context-aware)
   3. Counterfactual Reasoning - intervention simulation (context-indexed)
   ================================================================ */

/* ================================================================
   STAGE 1: COMPOSITION RULES (INDEXED)
   Modal logic for how constraints interact and compose
   ================================================================ */

%% composite_type(+C1, +C2, +Context, -ResultType)
% PRIMARY API: Determines composite type FROM A SPECIFIC CONTEXT
composite_type(C1, C2, Context, Result) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C1, Context, T1),
    drl_core:dr_type(C2, Context, T2),
    composition_rule(T1, T2, Result).

%% composite_type(+C1, +C2, -ResultType)
% BACKWARD COMPAT: Uses analytical context
composite_type(C1, C2, Result) :-
    constraint_indexing:default_context(Ctx),
    composite_type(C1, C2, Ctx, Result).

%% composition_rule(+Type1, +Type2, -CompositeType)
% Formal modal composition rules from DR logic
% NOTE: These rules are NOT indexed - they're about logical structure
%       Context affects input types, not composition rules themselves

% Necessity Inheritance: ■ C₁ ∧ (C₁ → C₂) ⇒ ■ C₂
% If C1 is a Mountain and implies C2, then C2 is also a Mountain
composition_rule(mountain, _, mountain) :- !.
composition_rule(_, mountain, mountain) :- !.

% Extraction Dominance: ⊞C₁ ∧ ⊠ C₂ ∧ Embedded(C₂, C₁) ⇒ ⊠ (C₁ ∧ C₂)
% When a Snare is embedded in a Rope, the whole becomes extractive
composition_rule(rope, snare, snare) :- !.
composition_rule(snare, rope, snare) :- !.
composition_rule(tangled_rope, snare, snare) :- !.
composition_rule(snare, tangled_rope, snare) :- !.

% Snare Dominance: Multiple Snares compound
composition_rule(snare, snare, snare) :- !.

% Rope Composition: ⊞C₁ ∧ ⊞C₂ ∧ Compatible(C₁, C₂) ⇒ ⊞(C₁ ∧ C₂)
% Compatible Ropes can be composed into compound Ropes
composition_rule(rope, rope, rope) :- !.

% Tangled interactions
composition_rule(tangled_rope, tangled_rope, tangled_rope) :- !.
composition_rule(rope, tangled_rope, tangled_rope) :- !.
composition_rule(tangled_rope, rope, tangled_rope) :- !.

% Piton contamination
composition_rule(piton, _, piton) :- !.
composition_rule(_, piton, piton) :- !.

% Unknown fallback
composition_rule(_, _, unknown).

%% detect_extraction_dominance(+Composite, -Evidence)
% Detects when a Rope is corrupted by an embedded Snare
% NOTE: Uses default analytical context for detection
detect_extraction_dominance(Composite, Evidence) :-
    narrative_ontology:affects_constraint(Composite, Component),
    drl_core:dr_type(Component, snare),
    narrative_ontology:constraint_metric(Component, extractiveness, X),
    X >= 0.66,
    Evidence = embedded_snare(Component, X).

%% detect_necessity_inheritance(+Source, -Derived)
% Detects when a Mountain constraint logically implies another constraint
% NOTE: Uses default analytical context for detection
detect_necessity_inheritance(Source, Derived) :-
    drl_core:dr_type(Source, mountain),
    narrative_ontology:affects_constraint(Source, Derived),
    narrative_ontology:constraint_metric(Source, suppression_requirement, E_source),
    E_source =< 0.05,
    % If the derived constraint should also be a Mountain
    narrative_ontology:constraint_metric(Derived, suppression_requirement, E_derived),
    E_derived =< 0.05.

/* ================================================================
   STAGE 2: TRANSFORMATION TRACKING (CONTEXT-AWARE)
   Temporal modal logic for constraint evolution
   ================================================================ */

%% constraint_history(+C, +Context, -Timeline)
% PRIMARY API: Collects constraint history FROM A SPECIFIC CONTEXT
% Same constraint may have different transformation patterns from different perspectives
constraint_history(C, Context, Timeline) :-
    constraint_indexing:valid_context(Context),
    findall(state(T, Type), 
            (narrative_ontology:measurement(_, C, _, T, _),
             dr_type_at(C, T, Context, Type)),
            TimelineUnsorted),
    sort(TimelineUnsorted, Timeline).

%% constraint_history(+C, -Timeline)
% BACKWARD COMPAT: Uses analytical context
constraint_history(C, Timeline) :-
    constraint_indexing:default_context(Ctx),
    constraint_history(C, Ctx, Timeline).

%% dr_type_at(+C, +Time, +Context, -Type)
% Determines constraint type at specific time FROM SPECIFIC CONTEXT
% NOTE: This is the key integration point - past metrics + current context
dr_type_at(C, Time, Context, Type) :-
    % Get metrics at this historical time
    (narrative_ontology:measurement(_, C, suppression_requirement, Time, E) -> true ; E = 0.5),
    (narrative_ontology:measurement(_, C, extractiveness, Time, BaseX) -> true ; BaseX = 0.5),
    
    % Apply current context's power scaling to historical metrics
    Context = context(agent_power(Power), _, _, _),
    constraint_indexing:power_modifier(Power, Modifier),
    EffectiveX is BaseX * Modifier,
    
    % Classify using effective extractiveness
    classify_at_time_indexed(C, E, EffectiveX, Context, Type).

%% classify_at_time_indexed(+C, +E, +EffectiveX, +Context, -Type)
% Classification logic using power-scaled extractiveness
% Recognizes: mountain, rope, snare, tangled_rope, piton, scaffold

% Scaffold (temporary support structure)
classify_at_time_indexed(C, _E, X, _Context, scaffold) :-
    narrative_ontology:entity(C, scaffold),
    config:param(tangled_rope_extraction_ceil, Ceil),
    X =< Ceil, !.

% Mountain (appears unchangeable from this context)
classify_at_time_indexed(_C, E, _X, Context, mountain) :-
    config:param(mountain_suppression_ceiling, Ceil),
    E =< Ceil,
    constraint_indexing:effective_immutability_for_context(Context, mountain), !.

% Snare (extractive + enforced + changeable)
classify_at_time_indexed(_C, E, X, Context, snare) :-
    config:param(snare_extraction_floor, XFloor),
    config:param(snare_suppression_floor, EFloor),
    X >= XFloor,
    E >= EFloor,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Tangled Rope (moderate extraction)
classify_at_time_indexed(_C, _E, X, Context, tangled_rope) :-
    config:param(rope_extraction_ceiling, RopeX),
    config:param(tangled_rope_extraction_ceil, TangledX),
    X > RopeX,
    X =< TangledX,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Piton (low extraction, high maintenance)
classify_at_time_indexed(_C, E, X, _Context, piton) :-
    config:param(piton_extraction_ceiling, XCeil),
    X =< XCeil,
    E > XCeil, !.

% Rope (low extraction, changeable)
classify_at_time_indexed(_C, _E, X, Context, rope) :-
    config:param(rope_extraction_ceiling, XCeil),
    X =< XCeil,
    constraint_indexing:effective_immutability_for_context(Context, rope), !.

% Unknown fallback
classify_at_time_indexed(_C, _E, _X, _Context, unknown).

%% transformation_detected(+C, +FromType, +ToType, -T1, -T2)
% Detects when constraint transformed from one type to another
% Uses actual measurement times (not iteration)
transformation_detected(C, From, To, T1, T2) :-
    constraint_history(C, Timeline),
    member(state(T1, From), Timeline),
    member(state(T2, To), Timeline),
    T2 > T1,
    From \= To,
    % Ensure no intermediate different type
    \+ (member(state(Tm, Mid), Timeline),
        Tm > T1, Tm < T2,
        Mid \= From, Mid \= To).

%% transformation_type(+C, +From, +To, +T1, +T2, -Label)
% Classifies the type of transformation with semantic label

transformation_type(C, rope, snare, T1, T2, capture) :-
    transformation_detected(C, rope, snare, T1, T2),
    check_capture_between(C, T1, T2).

transformation_type(C, rope, piton, T1, T2, obsolescence) :-
    transformation_detected(C, rope, piton, T1, T2),
    \+ check_capture_between(C, T1, T2).

transformation_type(C, scaffold, snare, T1, T2, calcification) :-
    transformation_detected(C, scaffold, snare, T1, T2),
    narrative_ontology:entity(C, scaffold),
    check_capture_between(C, T1, T2).

transformation_type(C, mountain, rope, T1, T2, discovery) :-
    transformation_detected(C, mountain, rope, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

transformation_type(C, mountain, snare, T1, T2, discovery) :-
    transformation_detected(C, mountain, snare, T1, T2),
    narrative_ontology:constraint_claim(C, mountain).

%% canonical_transformation(?C, ?From, ?To, -T1_earliest, -T2_latest, ?Label)
% Returns canonical (deduplicated) transformation
canonical_transformation(C, From, To, T1_earliest, T2_latest, Label) :-
    setof((T1, T2), transformation_type(C, From, To, T1, T2, Label), Pairs),
    findall(T1, member((T1, _), Pairs), T1s),
    findall(T2, member((_, T2), Pairs), T2s),
    min_list(T1s, T1_earliest),
    max_list(T2s, T2_latest).

%% check_capture_between(+C, +T1, +T2)
% Helper: detects if beneficiaries became concentrated
check_capture_between(C, T1, T2) :-
    narrative_ontology:measurement(_, C, extractiveness, T1, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    X2 > X1,
    X2 >= 0.66.

%% predict_transformation(+C, +CurrentType, -LikelyFutureType)
% Predicts likely future transformation based on trajectory
% NOTE: Uses analytical context for prediction
predict_transformation(C, rope, snare) :-
    findall(X, narrative_ontology:measurement(_, C, extractiveness, _, X), Xs),
    length(Xs, N), N >= 2,
    last(Xs, X_latest),
    X_latest > 0.5,
    X_latest < 0.66,
    Xs = [X_first|_],
    X_latest > X_first.

predict_transformation(C, rope, piton) :-
    findall(E, narrative_ontology:measurement(_, C, suppression_requirement, _, E), Es),
    length(Es, N), N >= 2,
    last(Es, E_latest),
    E_latest > 0.3,
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X < 0.35.

predict_transformation(C, tangled_rope, snare) :-
    narrative_ontology:constraint_metric(C, extractiveness, X),
    X > 0.5.

/* ================================================================
   STAGE 3: COUNTERFACTUAL REASONING (INDEXED)
   Reasoning about possible worlds after interventions
   NOW INDEXED: "What happens if WE cut this?" depends on WHO "we" are
   ================================================================ */

%% simulate_cut(+Constraint, +Context, -Effects)
% PRIMARY API: Simulates cutting a constraint FROM A SPECIFIC CONTEXT
% CRITICAL: Same cut has different effects depending on who does it
%
% Example: Cutting property rights
%   FROM institutional context: moderate coordination disruption
%   FROM powerless context: catastrophic (removes only shelter access)
simulate_cut(Constraint, Context, Effects) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    (Type = snare ; Type = piton ; Type = rope),  % Only cut these types
    findall(effect(Target, Impact, Reason),
            dependency_chain(Constraint, Target, Impact, Reason, Context),
            Effects).

%% simulate_cut(+Constraint, -Effects)
% BACKWARD COMPAT: Uses analytical context
simulate_cut(Constraint, Effects) :-
    constraint_indexing:default_context(Ctx),
    simulate_cut(Constraint, Ctx, Effects).

%% dependency_chain(+Source, -Target, -Impact, -Reason, +Context)
% PRIMARY API: Discovers dependencies FROM A SPECIFIC CONTEXT
% CRITICAL UPGRADE: "Depends on" is now relative to WHO would be affected
%
% What's load-bearing from powerless context may be non-essential from institutional
dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 1. Explicit dependencies (declared in data)
    narrative_ontology:affects_constraint(Source, Target),
    estimate_impact_indexed(Source, Target, Context, Impact, Reason).

dependency_chain(Source, Target, Impact, Reason, Context) :-
    constraint_indexing:valid_context(Context),
    
    % 2. Inferred structural coupling
    infer_structural_coupling(Source, Target, Strength),
    Strength > 0.85,
    
    % But assess impact FROM THIS CONTEXT
    (   context_depends_critically(Target, Source, Context)
    ->  Impact = catastrophic,
        Reason = inferred_load_bearing_coupling
    ;   Impact = moderate,
        Reason = inferred_weak_coupling
    ).

%% dependency_chain(+Source, -Target, -Impact, -Reason)
% BACKWARD COMPAT: Uses analytical context
dependency_chain(Source, Target, Impact, Reason) :-
    constraint_indexing:default_context(Ctx),
    dependency_chain(Source, Target, Impact, Reason, Ctx).

%% context_depends_critically(+Target, +Source, +Context)
% NEW: Determines if Target critically depends on Source FROM CONTEXT
% Used to detect load-bearing relationships per perspective
context_depends_critically(Target, Source, Context) :-
    % Target appears as Mountain from this context
    drl_core:dr_type(Target, Context, mountain),
    
    % Source provides the only perceived stability
    drl_core:dr_type(Source, Context, SourceType),
    member(SourceType, [rope, snare]),
    
    % Check if Target's stability requires Source
    narrative_ontology:affects_constraint(Source, Target).

%% estimate_impact_indexed(+Source, +Target, +Context, -Impact, -Reason)
% Estimates impact of cutting Source on Target FROM SPECIFIC CONTEXT
% CRITICAL: Same cut has different impacts depending on who's cutting

estimate_impact_indexed(Source, Target, Context, catastrophic, load_bearing) :-
    % Source is load-bearing FROM THIS CONTEXT
    drl_core:dr_type(Source, Context, snare),
    narrative_ontology:constraint_metric(Source, extractiveness, X),
    config:param(snare_load_bearing_threshold, T),
    X > T,
    
    % Target depends on it FROM THIS CONTEXT
    drl_core:dr_type(Target, Context, mountain),
    !.

estimate_impact_indexed(Source, Target, Context, beneficial, removes_extraction) :-
    % Source is extractive, Target is functional
    drl_core:dr_type(Source, Context, snare),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(Source, Target, Context, moderate, disrupts_coordination) :-
    % Both are coordination mechanisms
    drl_core:dr_type(Source, Context, rope),
    drl_core:dr_type(Target, Context, rope),
    !.

estimate_impact_indexed(_, _, _, negligible, no_dependency) :- !.

%% infer_structural_coupling(+C1, +C2, -Strength)
% Discovers hidden dependencies via temporal correlation
% NOTE: This is NOT indexed - coupling is structural fact
infer_structural_coupling(C1, C2, Strength) :-
    C1 \= C2,
    findall(G1, dr_gradient_at(C1, _, G1), Gs1),
    findall(G2, dr_gradient_at(C2, _, G2), Gs2),
    length(Gs1, L), L > 1, length(Gs2, L),
    calculate_coupling_strength(Gs1, Gs2, Strength).

dr_gradient_at(C, T, Grad) :-
    narrative_ontology:measurement(_, C, extractiveness, T, X1),
    narrative_ontology:measurement(_, C, extractiveness, T2, X2),
    T2 > T, !,
    Grad is X2 - X1.

calculate_coupling_strength([], [], 1.0).
calculate_coupling_strength([H1|T1], [H2|T2], S) :-
    ( (H1 > 0, H2 > 0) ; (H1 < 0, H2 < 0) ; (H1 == 0, H2 == 0) ),
    calculate_coupling_strength(T1, T2, SubS),
    S is 0.2 + SubS.
calculate_coupling_strength([_|T1], [_|T2], S) :-
    calculate_coupling_strength(T1, T2, S).

%% assess_scaffold_need(+Constraint, +Context, -Assessment)
% PRIMARY API: Determines if cutting requires Scaffold FROM SPECIFIC CONTEXT
% THEOREM 3 INDEXED: "Need scaffold" depends on WHO is cutting
%
% Critical case: Institutional cutting powerless Mountain
%   FROM institutional context: no_scaffold_needed (just coordination)
%   FROM powerless context: scaffold_required (removes survival support)
%   SYSTEM MUST EVALUATE BOTH CONTEXTS before allowing cut
assess_scaffold_need(Constraint, Context, Assessment) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(Constraint, Context, Type),
    member(Type, [snare, piton, rope]),
    
    simulate_cut(Constraint, Context, Effects),
    
    (   member(effect(_, catastrophic, load_bearing), Effects)
    ->  (   narrative_ontology:entity(Scaffold, scaffold),
            Scaffold \= Constraint
        ->  Assessment = scaffold_present
        ;   Assessment = scaffold_required
        )
    ;   Assessment = no_scaffold_needed
    ).

%% assess_scaffold_need(+Constraint, -Assessment)
% BACKWARD COMPAT: Uses analytical context
assess_scaffold_need(Constraint, Assessment) :-
    constraint_indexing:default_context(Ctx),
    assess_scaffold_need(Constraint, Ctx, Assessment).

%% counterfactual_world(+Intervention, +CurrentWorld, +Context, -FutureWorld)
% PRIMARY API: Models state after intervention FROM SPECIFIC CONTEXT
counterfactual_world(cut(C), current, Context, after_cut) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, Type),
    format('In world after cutting ~w (~w from ~w):~n', [C, Type, Context]),
    simulate_cut(C, Context, Effects),
    forall(member(effect(Target, Impact, Reason), Effects),
           format('  - ~w: ~w (~w)~n', [Target, Impact, Reason])).

counterfactual_world(add_scaffold(S, For), current, Context, with_scaffold) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(For, Context, snare),
    format('In world with scaffold ~w for ~w (from ~w):~n', [S, For, Context]),
    format('  - Temporary support for transition~n'),
    format('  - Allows safe removal of ~w~n', [For]).

%% counterfactual_world(+Intervention, +CurrentWorld, -FutureWorld)
% BACKWARD COMPAT: Uses analytical context
counterfactual_world(Intervention, Current, Future) :-
    constraint_indexing:default_context(Ctx),
    counterfactual_world(Intervention, Current, Ctx, Future).

/* ================================================================
   CROSS-CONTEXT DEPENDENCY ANALYSIS (NEW)
   Critical for detecting "institutional Mountain collapse"
   ================================================================ */

%% check_all_contexts(+Constraint, -MultiContextReport)
% NEW: Evaluates cutting a constraint across multiple standard contexts
% CRITICAL FOR SAFETY: Before cutting, check impact on ALL perspectives
%
% Example usage:
%   check_all_contexts(property_rights_2025, Report)
%   → Shows if cut is safe for institution but catastrophic for powerless
check_all_contexts(Constraint, Report) :-
    findall(
        context_impact(Context, Type, ScaffoldNeed, Effects),
        (   standard_context(Context),
            drl_core:dr_type(Constraint, Context, Type),
            assess_scaffold_need(Constraint, Context, ScaffoldNeed),
            simulate_cut(Constraint, Context, Effects)
        ),
        Impacts
    ),
    Report = multi_context_analysis(Constraint, Impacts).

% Standard contexts for cross-perspective analysis
standard_context(context(agent_power(powerless), 
                        time_horizon(biographical), 
                        exit_options(trapped), 
                        spatial_scope(local))).

standard_context(context(agent_power(individual_moderate), 
                        time_horizon(biographical), 
                        exit_options(mobile), 
                        spatial_scope(national))).

standard_context(context(agent_power(institutional), 
                        time_horizon(generational), 
                        exit_options(arbitrage), 
                        spatial_scope(national))).

standard_context(context(agent_power(analytical), 
                        time_horizon(civilizational), 
                        exit_options(analytical), 
                        spatial_scope(global))).

% ============================================================================
% NEW: INDEXICAL PERSPECTIVE AUDIT
% ============================================================================
% Checks if two agents experience a structural conflict (Risk Gap)
% Implements Section IV-B
detect_perspectival_risk(ConstraintID, Agent1, Agent2, RiskLabel) :-
    % 1. Get the base extraction score for the constraint
    constraint_data(ConstraintID, Data),
    member(base_extractiveness(X_base), Data),
    
    % 2. Calculate what each agent "sees" based on their power index
    % Uses the pi scaling function from drl_audit_core
    agent_index(Agent1, context(Power1, _, _, _)),
    agent_index(Agent2, context(Power2, _, _, _)),
    
    drl_audit_core:effective_extraction(X_base, Power1, Chi1),
    drl_audit_core:effective_extraction(X_base, Power2, Chi2),
    
    % 3. Determine the structural type for each agent
    drl_audit_core:structural_signature(Chi1, Data, Type1),
    drl_audit_core:structural_signature(Chi2, Data, Type2),
    
    % 4. Match against the Risk Table
    drl_audit_core:omega_risk(Type1, Type2, RiskLabel, _).

% possibly(C) is true if the constraint is a Rope (changeable/contingent)
possibly(C) :- 
    constraint_indexing:default_context(Ctx),
    drl_core:dr_type(C, Ctx, rope).

% necessarily(C) is true if the constraint is a Mountain (fixed/required)
necessarily(C) :- 
    constraint_indexing:default_context(Ctx),
    drl_core:dr_type(C, Ctx, mountain).

/* ================================================================
   UTILITY PREDICATES
   ================================================================ */

%% last(+List, -Last)
% Gets the last element of a list
last([X], X) :- !.
last([_|Xs], Last) :- last(Xs, Last).

% Provide a fail-safe default so they are "defined" even if no data is loaded
agent_index(_, _) :- fail.
constraint_data(_, _) :- fail.

/* ================================================================
   VERSION & MIGRATION INFO
   ================================================================ */

/*
VERSION HISTORY:
v4.0 (2025-01-17):
  - BREAKING: Full indexical relativity integration
  - NEW: dependency_chain/5 (added Context)
  - NEW: assess_scaffold_need/3 (added Context)
  - NEW: simulate_cut/3 (added Context)
  - NEW: context_depends_critically/3
  - NEW: estimate_impact_indexed/5
  - NEW: check_all_contexts/2 (multi-perspective safety check)
  - CHANGED: All dependency analysis is context-relative
  - MAINTAIN: Backward compatibility via /4, /3, /2 versions

v3.x:
  - Non-indexed modal logic
  - Single "God's eye view" dependency chains

MIGRATION GUIDE v3.x → v4.0:
  Old: dependency_chain(source, target, impact, reason)
  New: dependency_chain(source, target, impact, reason, context)
  
  Old: assess_scaffold_need(snare, assessment)
  New: assess_scaffold_need(snare, context, assessment)
  
  CRITICAL NEW REQUIREMENT:
  Before cutting any constraint, MUST evaluate:
    check_all_contexts(constraint, Report)
  to detect if cut is safe from one context but catastrophic from another.
  
  This prevents "institutional Mountain collapse" - where institution
  cuts what they see as Rope, unknowingly destroying powerless Mountain.
*/
:- module(intent_engine, [
	classify_interval/3,
	analyze_intent/1
]).

:- use_module(library(lists)).        % Required for sum_list/2
:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(coercion_projection). % Math Provider
:- use_module(pattern_analysis).        % State Provider

/* ================================================================
   1. MAIN ENTRY
   ================================================================ */

classify_interval(IntervalID, Pattern, Confidence) :-
    % Ensure the analysis service has populated the dynamic facts
    pattern_analysis:analyze_interval(IntervalID),
    pattern_analysis:interval_preliminary_pattern(IntervalID, Prelim),
    pattern_analysis:interval_system_gradient(IntervalID, coercion, Gsys),
    pattern_analysis:interval_data_completeness(IntervalID, DataScore),
    
    collect_intent_evidence(IntervalID, Evidence),
    (   structural_coercive_intent(IntervalID, Prelim, Gsys, Evidence)
    ->  Pattern = structural_coercive_intent,
        refine_confidence(Evidence, DataScore, Confidence)
    ;   classify_non_intent(Prelim, Pattern),
        fallback_confidence(DataScore, Confidence)
    ).

/* ================================================================
   2. STRUCTURAL COERCIVE INTENT (4 CONDITIONS)
   ================================================================ */

structural_coercive_intent(_IntervalID, Prelim, Gsys, Evidence) :-
    % Condition 1: Strong Positive Gradient
    Prelim = increasing_coercion,
    config:param(system_gradient_strong_threshold, StrongThr),
    Gsys > StrongThr,

    % Condition 2: Alternatives Rejected
    member(viable(_System, Alt), Evidence),
    member(rejected(_System2, Alt), Evidence),

    % Condition 3: Beneficiary Asymmetry
    findall((Class, Delta), member(power(Class, Delta), Evidence), PCs),
    PCs \= [],
    max_by_value((MainBeneficiary, DeltaMain), PCs),
    config:param(beneficiary_gain_min, GainMin),
    DeltaMain >= GainMin,

    % Condition 4: Suppression/Resistance Alignment
    config:param(structural_suppression_min, SMin),
    config:param(structural_resistance_min, RMin),
    findall(ValS, member(supp(MainBeneficiary, structural, ValS), Evidence), Ss),
    findall(ValR, member(resist(MainBeneficiary, structural, ValR), Evidence), Rs),
    Ss \= [], Rs \= [],
    average_list(Ss, AvgS), AvgS >= SMin,
    average_list(Rs, AvgR), AvgR >= RMin.

/* ================================================================
   3. HELPERS & UTILS
   ================================================================ */

collect_intent_evidence(IntervalID, Evidence) :-
    findall(viable(S,A), intent_viable_alternative(IntervalID, S, A), VAs),
    findall(rejected(S,A), intent_alternative_rejected(IntervalID, S, A), RAs),
    findall(power(C,D), intent_power_change(IntervalID, C, D), PCs),
    findall(supp(C,L,V), intent_suppression_level(IntervalID, C, L, V), Supps),
    findall(resist(C,L,V), intent_resistance_level(IntervalID, C, L, V), Ress),
    append([VAs, RAs, PCs, Supps, Ress], Evidence).

classify_non_intent(Prelim, Pattern) :-
    (Prelim = increasing_coercion -> Pattern = increasing_coercion 
    ; Prelim = decreasing_coercion -> Pattern = decreasing_coercion 
    ; Pattern = stable).

refine_confidence(Evidence, DataScore, Conf) :-
    length(Evidence, NEv),
    config:param(data_high_threshold, DH),
    (DataScore >= DH, NEv >= 5 -> Conf = high ; Conf = medium).

fallback_confidence(DataScore, Conf) :-
    config:param(data_high_threshold, DH),
    (DataScore >= DH -> Conf = high ; Conf = low).

% Local helper predicates (not exported)
% FIXED: Renamed to avoid conflicts with library predicates

% Safe average that handles empty lists
average_list([], 0).
average_list(List, Avg) :- 
    List \= [],
    sum_list(List, Sum), 
    length(List, N), 
    Avg is Sum / N.

% Find tuple with maximum second element
% FIXED: Renamed from max_member to avoid conflict with library(lists)
max_by_value((C, D), List) :- 
    member((C, D), List), 
    \+ (member((_, D2), List), D2 > D).

%% analyze_intent(+IntervalID)
%  Harness wrapper to satisfy test_harness.pl.
analyze_intent(IntervalID) :-
    (   classify_interval(IntervalID, Pattern, Confidence)
    ->  format('  [INTENT] Result: ~w (Confidence: ~w)~n', [Pattern, Confidence])
    ;   format('  [INTENT] Analysis failed for ~w~n', [IntervalID])
    ).
:- module(isomorphism_engine, [
    find_isomorphism/3,
    cluster_by_signature/2,
    generate_cross_domain_index/1,
    find_high_risk_isomorphism/3
]).

:- use_module(structural_signatures).
:- use_module(narrative_ontology).
:- use_module(domain_priors).
:- use_module(config).

%% find_isomorphism(+ConstraintA, -ConstraintB, -SimilarityScore)
%  Calculates the structural similarity between two constraints based on 
%  their 7-point signature profile.
find_isomorphism(C1, C2, Score) :-
    C1 \= C2,
    structural_signatures:get_constraint_profile(C1, Profile1),
    structural_signatures:get_constraint_profile(C2, Profile2),
    calculate_profile_distance(Profile1, Profile2, Distance),
    Score is 1.0 - Distance,
    config:param(isomorphism_threshold, T),
    Score >= T.

%% calculate_profile_distance(+P1, +P2, -Distance)
%  Computes normalized Euclidean distance across the metric components 
%  of the structural profiles.
calculate_profile_distance(
    profile(A1, S1, R1, B1, Alt1, _, _),
    profile(A2, S2, R2, B2, Alt2, _, _),
    Distance
) :-
    % Normalized Beneficiary Delta (capped at 5 for scale)
    BN1 is min(B1, 5) / 5,
    BN2 is min(B2, 5) / 5,
    % Alternative parity (0 if same, 1 if different)
    (Alt1 == Alt2 -> AltD = 0 ; AltD = 1),
    
    D2 is (A1-A2)^2 + (S1-S2)^2 + (R1-R2)^2 + (BN1-BN2)^2 + (AltD * 0.5)^2,
    Distance is sqrt(D2) / 2.5. % Normalized to [0,1]

%% cluster_by_signature(+Signature, -Cluster)
%  Finds all constraints sharing a specific structural signature.
cluster_by_signature(Sig, Cluster) :-
    findall(C, structural_signatures:constraint_signature(C, Sig), Cluster).

%% generate_cross_domain_index(-Index)
%  The "Pattern Search" entry point.
generate_cross_domain_index(Index) :-
    findall(iso(C1, C2, S), (
        narrative_ontology:constraint_claim(C1, _),
        domain_priors:category_of(C1, Cat1),
        find_isomorphism(C1, C2, S),
        domain_priors:category_of(C2, Cat2),
        Cat1 \= Cat2 % Only return cross-domain matches
	    ), Index).

%% find_high_risk_isomorphism(-C1, -C2, -Score)
%  Filters isomorphisms specifically for "Snare" or "Tangled Rope" clusters.
find_high_risk_isomorphism(C1, C2, Score) :-
    find_isomorphism(C1, C2, Score),
    is_high_risk(C1),
    is_high_risk(C2).

%% is_high_risk(+Constraint)
%  Checks if a constraint is classified as a Snare or Tangled Rope 
%  from the default analytical perspective.
is_high_risk(C) :-
    drl_core:dr_type(C, Type),
    member(Type, [snare, tangled_rope]).
:- module(isomorphism_report, [
    generate_isomorphism_report/0,
    report_isomorphism_to_file/1
]).

:- use_module(isomorphism_engine).
:- use_module(narrative_ontology).
:- use_module(domain_priors).

%% generate_isomorphism_report
%  Scans the current Knowledge Base and prints a Markdown-formatted 
%  table of structural isomorphisms across different domains.
generate_isomorphism_report :-
    format('~n# CROSS-DOMAIN ISOMORPHISM INDEX~n'),
    format('| Domain A (Technical/Formal) | Domain B (Social/Institutional) | Similarity | Structural Logic |~n'),
    format('| :--- | :--- | :--- | :--- |~n'),
    
    % Generate the index using the engine
    isomorphism_engine:generate_cross_domain_index(Index),
    
    % Filter and sort by score for the report
    sort(3, @>=, Index, SortedIndex),
    
    forall(member(iso(C1, C2, Score), SortedIndex),
           (   % Only report if C1 is "technical" and C2 is "social" to highlight the thesis
               domain_priors:category_of(C1, Cat1),
               domain_priors:category_of(C2, Cat2),
               (is_technical(Cat1), is_social(Cat2))
           ->  get_logic_explanation(C1, C2, Explanation),
               format('| ~w | ~w | ~2f | ~w |~n', [C1, C2, Score, Explanation])
           ;   true
           )).

%% is_technical(+Category)
%  Helper to identify formal/technical domains[cite: 103, 104, 115].
is_technical(physical_natural).
is_technical(formal_logic).
is_technical(extractive_market). % Often technical in your datasets

%% is_social(+Category)
%  Helper to identify social/historical domains[cite: 106, 107, 128].
is_social(narrative_history).
is_social(statutory_formal).
is_social(election_cycle).

%% get_logic_explanation(+C1, +C2, -Explanation)
%  Summarizes why the two constraints are twins[cite: 457, 458, 459].
get_logic_explanation(C1, C2, Explanation) :-
    structural_signatures:constraint_signature(C1, Sig),
    structural_signatures:explain_signature(C1, Sig, BaseExpl),
    % Truncate or simplify the explanation for table format
    format(atom(Explanation), 'Both function as ~w.', [Sig]).

%% generate_high_risk_index
%  Generates a Markdown report limited to high-risk structural twins.
generate_high_risk_index :-
    format('~n# HIGH-RISK STRUCTURAL ISOMORPHISM AUDIT~n'),
    format('| Risk Cluster (Formal) | Risk Cluster (Social) | Similarity | Risk Type |~n'),
    format('| :--- | :--- | :--- | :--- |~n'),
    
    findall(iso(C1, C2, S), (
        domain_priors:category_of(C1, Cat1),
        find_high_risk_isomorphism(C1, C2, S),
        domain_priors:category_of(C2, Cat2),
        Cat1 \= Cat2,
        is_technical(Cat1) % Source is a technical system
    ), HighRiskIndex),
    
    sort(3, @>=, HighRiskIndex, Sorted),
    
    forall(member(iso(C1, C2, Score), Sorted),
           (   drl_core:dr_type(C1, Type),
               format('| ~w | ~w | ~2f | ~w |~n', [C1, C2, Score, Type])
           )).
:- module(narrative_ontology, [
    % Core ontology
    entity/2,
    interval/3,
    event/4,

    % CE v2.0 constraint layer
    constraint_claim/2,
    recommendation/2,
    affects_constraint/2,
    veto_actor/1,
    veto_exposed/2,
    constraint_metric/3,
    omega_variable/3,

    % Optional measurement layer (v3.1 coercion metrics)
    measurement/5,

    % Optional intent evidence layer
    intent_viable_alternative/3,
    intent_alternative_rejected/3,
    intent_beneficiary_class/2,
    intent_power_change/3,
    intent_suppression_level/4,
    intent_resistance_level/4,
    intent_norm_strength/3,

    % Tangled rope category (Added January 2026)
    constraint_type/1,
    constraint_type_name/2,
    is_tangled_rope/1,
    has_coordination_function/1,
    has_asymmetric_extraction/1,

    % Scaffold
    has_sunset_clause/1,
    
    % Validation entry point
    validate_ontology/0
]).

:- use_module(config). % Added to allow access to configuration parameters

/* ============================================================
   1. MULTIFILE & DYNAMIC DECLARATIONS
   ============================================================ */

:- multifile
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5, intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3, theater_ratio/2,
    constraint_beneficiary/2, constraint_victim/2.

:- dynamic
    attribute/3, has_mandatrophy_declaration/1,
    entity/2, interval/3, event/4,
    constraint_claim/2, recommendation/2, affects_constraint/2,
    veto_actor/1, veto_exposed/2, constraint_metric/3, omega_variable/3,
    measurement/5, has_sunset_clause/1,
    intent_viable_alternative/3, intent_alternative_rejected/3,
    intent_beneficiary_class/2, intent_power_change/3,
    intent_suppression_level/4, intent_resistance_level/4,
    intent_norm_strength/3, constraint_claim/3,
    constraint_beneficiary/2, constraint_victim/2.

/* ============================================================
   2. VALIDATION LOGIC
   ============================================================ */
%% attribute(+Subject, +Key, +Value)
%  Generic metadata getter/setter used for indexical resolution.
%  This links the metadata check in is_indexical_resolution_declared/1 
%  to the actual stored metrics.
attribute(S, K, V) :- 
    narrative_ontology:constraint_metric(S, K, V).

%% has_mandatrophy_declaration(+Constraint)
%  A manual override flag used by check_indexical_relativity/1.
%  If a constraint is explicitly marked as 'mandatrophy' in its metadata,
%  it passes the indexical relativity gate.
has_mandatrophy_declaration(C) :- 
    attribute(C, lifecycle, mandatrophy).

%% validate_ontology
%  Master entry point for checking Knowledge Base integrity.
validate_ontology :-
    (   validate_entities,
        validate_intervals,
        validate_events,
        validate_constraint_claims,
        validate_constraint_metrics,
        validate_measurements,
        validate_omegas,
        validate_intent
    ).

validate_entities :-
    forall(entity(ID,Type),
        ( atom(ID),
          member(Type, [powerless, powerful, 
                        institutional, analytical, class])
        -> true
        ;  format('ERROR: Invalid entity(~w,~w)~n',[ID,Type]), fail
        )).

validate_intervals :-
    forall(interval(ID,Start,End),
        ( atom(ID), integer(Start), integer(End), Start =< End
        -> true
        ;  format('ERROR: Invalid interval(~w,~w,~w)~n',[ID,Start,End]), fail
        )).

validate_events :-
    forall(event(ID,Time,Actor,Type),
        ( atom(ID), integer(Time), (entity(Actor,_) ; atom(Actor)), atom(Type)
        -> true
        ;  format('ERROR: Invalid event(~w,~w,~w,~w)~n',[ID,Time,Actor,Type]), fail
        )).

%% validate_constraint_claims
%  Updated for v3.2.4 schema expansion.
%  Added tangled_rope category (January 2026) based on empirical validation of 467 constraints.
validate_constraint_claims :-
    forall(constraint_claim(Name, Type),
        ( member(Type, [mountain, rope, tangled_rope, snare, piton])
        -> true
        ;  format('ERROR: Ontological Violation in ~w: "~w" is not a valid constraint type.~n', [Name, Type]),
           fail
        )).

validate_constraint_metrics :-
    forall(constraint_metric(Name,Metric,Val),
        ( (constraint_claim(Name,_) ; true),
          atom(Metric),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid constraint_metric(~w,~w,~w)~n',[Name,Metric,Val]), fail
        )).

validate_measurements :-
    forall(measurement(ID,Target,Metric,Time,Val),
        ( atom(ID),
          (entity(Target,_) ; interval(Target,_,_)),
          (atom(Metric) ; compound(Metric)),
          integer(Time),
          number(Val), Val >= 0.0, Val =< 1.0
        -> true
        ;  format('ERROR: Invalid measurement(~w,~w,~w,~w,~w)~n',
                  [ID,Target,Metric,Time,Val]), fail
        )).

validate_omegas :-
    forall(omega_variable(ID, Type, Desc),
        ( atom(ID),
          member(Type, [empirical, conceptual, preference]),
          (atom(Desc) ; string(Desc))
        -> true
        ;  format('ERROR: Invalid omega_variable(~w,~w,~w)~n',[ID,Type,Desc]), fail
        )).

validate_intent :-
    forall(intent_viable_alternative(I,S,A),
        ( (interval(I,_,_) ; atom(I)), (entity(S,_) ; atom(S)), atom(A)
        -> true
        ;  format('ERROR: Invalid intent_viable_alternative(~w,~w,~w)~n',[I,S,A]), fail
        )).

/* ==========================================================================
   TANGLED ROPE CATEGORY - EMPIRICAL VALIDATION (Added January 2026)
   ========================================================================== */

/**
 * TANGLED ROPE CATEGORY - EMPIRICAL VALIDATION
 *
 * Added based on corpus analysis of 467 constraints (January 2026):
 * - 168 constraints (36%) show hybrid coordination/extraction pattern
 * - Cannot be explained by indexing alone (structural hybridity is real)
 * - Pattern mining confirmed empirical necessity
 *
 * Examples from corpus:
 * - carbon_credit_markets (0.55 extraction, 0.60 suppression)
 * - academic_tenure_system (0.75 extraction, 0.60 suppression)
 * - platform_network_effects (coordination + extraction)
 *
 * Key distinction from pure types:
 * - NOT pure rope (extraction too high, >0.40)
 * - NOT pure snare (has genuine coordination function)
 * - Requires surgical reform: preserve coordination, cut extraction
 */

%% constraint_type(?Type)
%  Valid constraint types in the framework.
constraint_type(mountain).
constraint_type(rope).
constraint_type(tangled_rope).  % Validated by corpus analysis (168/467 constraints, 36%)
constraint_type(snare).
constraint_type(piton).

%% constraint_type_name(?Type, ?Name)
%  Human-readable names for constraint types.
constraint_type_name(mountain, 'Mountain (Natural Constraint)').
constraint_type_name(rope, 'Rope (Pure Coordination)').
constraint_type_name(tangled_rope, 'Tangled Rope (Hybrid Coordination/Extraction)').
constraint_type_name(snare, 'Snare (Pure Extraction)').
constraint_type_name(piton, 'Piton (Degraded Coordination)').


%% is_tangled_rope(+ConstraintID)
%  Tangled rope signature detection.
%  Must have BOTH coordination function AND asymmetric extraction.
is_tangled_rope(ConstraintID) :-
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(ConstraintID, ExtMetricName, E),
    config:param(tangled_rope_extraction_floor, TR_E_Floor),
    config:param(tangled_rope_extraction_ceil, TR_E_Ceil),
    E >= TR_E_Floor, E =< TR_E_Ceil,
    config:param(suppression_metric_name, SuppMetricName),
    narrative_ontology:constraint_metric(ConstraintID, SuppMetricName, S),
    config:param(tangled_rope_suppression_floor, TR_S_Floor),
    S >= TR_S_Floor,
    domain_priors:requires_active_enforcement(ConstraintID),
    % Must have both coordination function AND extraction
    has_coordination_function(ConstraintID),
    has_asymmetric_extraction(ConstraintID).

%% has_coordination_function(+ConstraintID)
%  Check if constraint solves a collective action problem.
%  Evidence: Has multiple beneficiaries or provides network effects.
%  Note: constraint_beneficiary/2 is defined in individual test files.
has_coordination_function(ConstraintID) :-
    constraint_beneficiary(ConstraintID, _),
    !.

%% has_asymmetric_extraction(+ConstraintID)
%  Check for asymmetric beneficiary distribution.
%  Evidence: Has victims or concentrated benefits.
%  Note: constraint_victim/2 is defined in individual test files.
has_asymmetric_extraction(ConstraintID) :-
    constraint_victim(ConstraintID, _),
    !.

/* ==========================================================================
   INDEXICAL GATE (v3.1)
   ========================================================================== */

% Indexical Gate: Flags Mountains that are actually Shadow Nooses.
check_indexical_relativity(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(ID, ExtMetricName, E),
    E > 0.7,
    % Require a manual "Mandatrophy Acknowledgement" in the file metadata
    \+ has_mandatrophy_declaration(ID).

% Every domain must be indexed to power-perspectives (mountain/rope/tangled_rope/snare).
% Note: With tangled_rope addition, we now have 4 categories but validation remains
% focused on ensuring at least the traditional 3-pillar coverage is maintained.
validate_indexical_completeness(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    constraint_indexing:constraint_classification(ID, rope, _),
    constraint_indexing:constraint_classification(ID, snare, _),
    !.
validate_indexical_completeness(ID) :-
    format('ERROR: Perspectival Gap in ~w. Missing 3-pillar coverage.~n', [ID]),
    fail.

/* ==========================================================================
   MANDATROPHY RECONCILIATION (v3.1)
   ========================================================================== */

% is_mandatrophy_resolved/1: Explicitly standardizes the 2 residual Omegas.
is_mandatrophy_resolved(gale_shapley).        % The Algorithm is the Mandate.
is_mandatrophy_resolved(planetary_boundaries). % The Biological Limit is the Mandate.

% detect_omega/2: Identifies logical friction points.
% This rule is updated to exempt "Hardened Mandatrophy."
detect_omega(Name, mandatrophy) :-
    constraint_indexing:constraint_classification(Name, mountain, _),
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(Name, ExtMetricName, E),
    E > 0.7,
    % The Paradox: A Mountain (Fact) behaves like a Snare (Trap).
    % If the domain is recognized as Mandatrophic, it is no longer an Omega.
    \+ is_mandatrophy_resolved(Name).

% System Insight: Logic for the Parsing Suite
count_unresolved_omegas(Count) :-
    aggregate_all(count, detect_omega(_, _), Count).

% Mandatrophy Detector: Flags Mountains that function as Traps.
detect_mandatrophy_omega(ID) :-
    constraint_indexing:constraint_classification(ID, mountain, _),
    config:param(extractiveness_metric_name, ExtMetricName),
    narrative_ontology:constraint_metric(ID, ExtMetricName, E),
    E > 0.7,
    % Check for the explicit resolution marker in the file
    \+ is_indexical_resolution_declared(ID).

is_indexical_resolution_declared(ID) :-
    % Looks for the standardized resolution hook in the metadata
    attribute(ID, indexical_resolution, resolved).

% Add-ons

has_sunset_clause(_) :- fail. % Default fail if not explicitly defined in instance

% Maps claim/2 into claim/3 for context-indexed lookups
constraint_claim(ID, Type, _Context) :- 
    constraint_claim(ID, Type).
:- module(pattern_analysis, [
    analyze_interval/1,
    interval_system_gradient/3,
    interval_data_completeness/2,
    interval_preliminary_pattern/2
]).

:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(coercion_projection).

:- dynamic interval_system_gradient/3.
:- dynamic interval_data_completeness/2.
:- dynamic interval_preliminary_pattern/2.

analyze_interval(IntervalID) :-
    narrative_ontology:interval(IntervalID, T0, _),
    retractall(interval_system_gradient(IntervalID, _, _)),
    retractall(interval_data_completeness(IntervalID, _)),
    retractall(interval_preliminary_pattern(IntervalID, _)),

    coercion_projection:system_gradient(IntervalID, T0, Gsys),
    assertz(interval_system_gradient(IntervalID, coercion, Gsys)),

    compute_completeness(IntervalID, Score),
    assertz(interval_data_completeness(IntervalID, Score)),

    config:param(system_gradient_threshold, Thr),
    (Gsys > Thr -> P = increasing_coercion ; Gsys < -Thr -> P = decreasing_coercion ; P = stable),
    assertz(interval_preliminary_pattern(IntervalID, P)).

compute_completeness(ID, Score) :-
    narrative_ontology:interval(ID, T0, Tn),
    findall((L, T), (config:level(L), member(T, [T0, Tn]), coercion_projection:coercion_vector(L, T, _)), Vectors),
    length(Vectors, N),
    Score is N / 8.
:- module(psych_bridge, [
    is_substrate/3,
    is_negotiable_pattern/3,
    is_hybrid_pattern/3,
    is_self_extraction/3,
    is_developmental_support/3,
    is_abandoned_camp/3
]).

:- use_module(drl_core).
:- use_module(narrative_ontology).

% Helper predicate to temporarily swap metrics for psychological analysis.
% It checks for 'internalization_depth' and maps it to 'suppression_requirement'
% for the duration of a goal's execution.
with_psych_metric(Constraint, Goal) :-
    (   narrative_ontology:constraint_metric(Constraint, internalization_depth, Depth)
    ->  % If internalization_depth exists, use it for suppression_requirement
        asserta(narrative_ontology:constraint_metric(Constraint, suppression_requirement, Depth)),
        call(Goal),
        retract(narrative_ontology:constraint_metric(Constraint, suppression_requirement, Depth))
    ;   % Otherwise, just call the goal with existing metrics
        call(Goal)
    ).

%% is_substrate(?Constraint, ?Context, ?Type)
%  Psychological alias for is_mountain. Represents biological or neurological limits.
is_substrate(C, Context, substrate) :-
    with_psych_metric(C, drl_core:is_mountain(C, Context, mountain)).

%% is_negotiable_pattern(?Constraint, ?Context, ?Type)
%  Psychological alias for is_rope. Represents healthy, functional habits.
is_negotiable_pattern(C, Context, negotiable_pattern) :-
    with_psych_metric(C, drl_core:is_rope(C, Context, rope)).

%% is_hybrid_pattern(?Constraint, ?Context, ?Type)
%  Psychological alias for is_tangled_rope. Represents habits that both serve and harm.
is_hybrid_pattern(C, Context, hybrid_pattern) :-
    with_psych_metric(C, drl_core:is_tangled_rope(C, Context, tangled_rope)).

%% is_self_extraction(?Constraint, ?Context, ?Type)
%  Psychological alias for is_snare. Represents self-destructive patterns like addiction.
is_self_extraction(C, Context, self_extraction) :-
    with_psych_metric(C, drl_core:is_snare(C, Context, snare)).

%% is_developmental_support(?Constraint, ?Context, ?Type)
%  Psychological alias for is_scaffold. Represents temporary supports like therapy or mentorship.
is_developmental_support(C, Context, developmental_support) :-
    with_psych_metric(C, drl_core:is_scaffold(C, Context, scaffold)).

%% is_abandoned_camp(?Constraint, ?Context, ?Type)
%  Psychological alias for is_piton. Represents outdated trauma responses or obsolete coping mechanisms.
is_abandoned_camp(C, Context, abandoned_camp) :-
    with_psych_metric(C, drl_core:is_piton(C, Context, piton)).
:- module(report_generator, [
    generate_full_report/1,
    generate_indexed_report/3,
    generate_omegas_from_gaps/1,
    omega_from_gap/5,
    cross_domain_audit/0,
    forensic_audit_false_mountains/0,
    generate_omega_resolution_scenarios/0,
    generate_omega_triage/0
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(intent_engine, except([classify_interval/3])).
:- use_module(coercion_projection).
:- use_module(pattern_analysis).
:- use_module(constraint_bridge).
:- use_module(drl_core).
:- use_module(uke_dr_bridge).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(isomorphism_engine). % Required for isomorphism audit
:- use_module(domain_priors).      % Required for forensic audit
:- use_module(utils).              % Safe helpers for defensive programming
:- use_module(drl_lifecycle).      % Drift event detection & lifecycle analysis

% Suppress warning - we intentionally override intent_engine:classify_interval/3
:- discontiguous classify_interval/3.

/* ============================================================================
   TYPE DESCRIPTIONS & STRATEGIES (Updated January 2026 for Tangled Rope)
   ============================================================================ */

%% type_description(?Type, ?Description)
%  Human-readable descriptions for constraint types.
type_description(mountain,
    'Natural constraint - unchangeable given current understanding of reality').
type_description(rope,
    'Pure coordination - low extraction, solves collective action problems').
type_description(tangled_rope,
    'Hybrid coordination/extraction - provides genuine coordination while extracting asymmetrically').
type_description(snare,
    'Pure extraction - minimal coordination benefit, high asymmetric extraction').
type_description(piton,
    'Maintained constraint - low extraction but high suppression costs, should be cut but isn''t').

%% type_strategy(?Type, ?Strategy)
%  Strategic recommendations for each constraint type.
type_strategy(mountain,
    'Accept - Work within natural constraints, adapt strategies accordingly').
type_strategy(rope,
    'Maintain - Preserve coordination mechanisms, ensure fair access and participation').
type_strategy(tangled_rope,
    'Reform carefully - Preserve coordination core while cutting extractive elements. Requires surgical separation.').
type_strategy(snare,
    'Cut - Remove extractive constraints, replace with fair alternatives if coordination needed').
type_strategy(piton,
    'Bypass or eliminate - High maintenance cost without value, find alternatives').

%% type_color(?Type, ?Color)
%  Color coding for visualization and reports.
type_color(mountain, blue).
type_color(rope, green).
type_color(tangled_rope, orange).  % Orange for hybrid nature
type_color(snare, red).
type_color(piton, gray).

/* ============================================================================
   1. EXECUTIVE SUMMARY (MAIN ENTRY)
   ============================================================================ */

generate_full_report(IntervalID) :-
    narrative_ontology:interval(IntervalID, T_start, Tn),
    classify_interval(IntervalID, Pattern, Conf),
    
    format('~n~n====================================================~n'),
    format('   DEFERENTIAL REALISM (DR) EXECUTIVE SUMMARY      ~n'),
    format('====================================================~n'),
    format('Timeline:       ~w to ~w~n', [T_start, Tn]),
    format('Structural Pattern: ~w~n', [Pattern]),
    format('Confidence:     ~w~n', [Conf]),
    
    % --- SECTION 1: DRL INDEXICAL AUDIT ---
    format('~n[CONSTRAINT INVENTORY: INDEXICAL AUDIT]~n'),
    forall(
        narrative_ontology:constraint_claim(C, Claimed),
        (
            format('~n~nConstraint: ~w~n', [C]),
            format('  Claimed Type: ~w~n', [Claimed]),
            format('  Perspectives:~n'),
            forall(
                constraint_indexing:constraint_classification(C, Type, Context),
                (
                    format('    - [~w]: ~w', [Context, Type]),
                    ( Type == Claimed -> format(' (Matches Claim)~n')
                    ; format(' (Mismatch)~n')
                    )
                )
            )
        )
    ),

    % --- SECTION 2: ISOMORPHISM AUDIT ---
    generate_isomorphism_audit(IntervalID),

    % --- SECTION 2A: COMPREHENSIVE CROSS-DOMAIN AUDIT ---
    cross_domain_audit,

    % --- SECTION 3: META-LOGICAL AUDIT ---
    format('~n[META-LOGICAL AUDIT: ONTOLOGICAL FRAUD DETECTION]~n'),
    (   setof((C, Err, Sev), drl_core:dr_mismatch(C, Err, Sev), Errors)
    ->  forall(member((C, Err, Sev), Errors),
               format('  ! ALERT [~w]: ~w detected for ~w~n', [Sev, Err, C]))
    ;   format('  No classification errors detected. System is Ontologically Coherent.~n')
    ),

    % --- SECTION 3A: FORENSIC AUDIT FOR FALSE MOUNTAINS ---
    forensic_audit_false_mountains,

    % --- SECTION 4: STRUCTURAL SIGNATURE ANALYSIS ---
    format('~n[STRUCTURAL SIGNATURE ANALYSIS]~n'),
    (   catch(
            forall(narrative_ontology:constraint_claim(CSig, _Claim),
                   report_constraint_signature(CSig)),
            Error,
            format('  [FAIL] Exception: ~w~n', [Error]))
    ;   true
    ),

    % --- SECTION 5: UKE_DR FEASIBILITY BRIDGE ---
    format('~n[UKE_DR FEASIBILITY BRIDGE]~n'),
    format('  ~40s | ~12s~n', ['Recommendation', 'UKE Status']),
    format('  ----------------------------------------------------------------------~n'),
    (   forall(narrative_ontology:recommendation(RID, Summary),
               ( ( uke_dr_bridge:uke_status(RID, UKEStatus, Reasons) 
                 -> format('  - ~40w | ~12w~n', [Summary, UKEStatus]),
                    forall(member(R, Reasons), format('    > ~w~n', [R]))
                 ;  format('  - ~40w | ~12s~n', [Summary, 'DATA_MISSING'])
                 )
               ))
    ;   true
    ),
    
    % --- SECTION 6: KINETIC MAGNITUDE ---
    findall(Kappa, (config:level(L), coercion_projection:coercion_magnitude(L, Tn, Kappa)), Kappas),
    (   Kappas \= [] 
    ->  sum_list(Kappas, SumK), length(Kappas, NK), AvgK is SumK / NK,
        format('~nAggregate Magnitude (Kappa) at Tn: ~2f~n', [AvgK])
    ;   format('~nAggregate Magnitude (Kappa): DATA_INSUFFICIENT~n')
    ),
    
    % --- SECTION 7: PERSPECTIVAL GAP ANALYSIS ---
    format('~n[PERSPECTIVAL GAP ANALYSIS]~n'),
    (   forall(narrative_ontology:constraint_claim(CGap, _),
               perspectival_gap_audit(CGap))
    ;   true
    ),
    
    % --- SECTION 8: OMEGA GENERATION ---
    generate_omegas_from_gaps(IntervalID),

    % --- SECTION 8A: OMEGA TRIAGE ---
    generate_omega_triage,

    % --- SECTION 8B: OMEGA RESOLUTION SCENARIOS ---
    generate_omega_resolution_scenarios,

    format('====================================================~n').

/* ============================================================================
   2. OMEGA GENERATION
   ============================================================================ */

generate_omegas_from_gaps(IntervalID) :-
    format('~n[OMEGA GENERATION FROM PERSPECTIVAL GAPS: ~w]~n', [IntervalID]),
    findall(
        omega_entry(OmegaID, Type, Question, Gap),
        (   narrative_ontology:constraint_claim(C, _),  % Look at ALL claimed constraints
            detect_gap_pattern(C, Gap),
            omega_from_gap(C, Gap, OmegaID, Type, Question)
        ),
        OmegaEntries
    ),
    process_omega_entries(OmegaEntries).

process_omega_entries([]) :- 
    format('  No perspectival gaps detected requiring Ω tracking.~n').
process_omega_entries(OmegaEntries) :-
    OmegaEntries \= [],
    length(OmegaEntries, Count),
    format('  Generated ~w Omega variables from perspectival gaps:~n~n', [Count]),
    forall(member(omega_entry(OID, OType, OQuestion, OGap), OmegaEntries),
           (   format('  Ω: ~w (~w)~n', [OID, OType]),
               format('     Question: ~w~n', [OQuestion]),
               format('     Source: ~w~n~n', [OGap]),
               assert_omega_if_new(OID, OType, OQuestion)
           )).

% detect_gap_pattern and omega_from_gap logic remains unchanged...
% [Included below for completeness in your file]

% Pattern 1: Snare masked as Rope - MOST CRITICAL (extraction blindness)
detect_gap_pattern(C, gap(snare_masked_as_rope, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = snare, 
    TypeI = rope, 
    !.

% Pattern 2: Snare/Mountain confusion - CRITICAL (learned helplessness)
detect_gap_pattern(C, gap(snare_mountain_confusion, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = snare, 
    TypeI = mountain, 
    !.

% Pattern 3: Mountain/Rope confusion - REQUIRES SCAFFOLD (catastrophic cut risk)
detect_gap_pattern(C, gap(mountain_coordination_confusion, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP = mountain, 
    TypeI = rope, 
    !.

% Pattern 4: General catch-all - MUST BE LAST (any other mismatch)
detect_gap_pattern(C, gap(general_type_mismatch, TypeP, TypeI)) :-
    constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)),
    constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
    TypeP \= TypeI, 
    TypeP \= none, 
    TypeI \= none.

omega_from_gap(C, gap(snare_masked_as_rope, snare, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_extraction_blindness_~w', [C]),
    format(atom(Question), 'Constraint ~w appears extractive (Snare) to individuals but functional (Rope) to institutions...', [C]), !.

omega_from_gap(C, gap(mountain_coordination_confusion, mountain, rope), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_cut_safety_~w', [C]),
    format(atom(Question), 'Constraint ~w appears unchangeable (Mountain) to individuals but optional (Rope) to institutions...', [C]), !.

omega_from_gap(C, gap(snare_mountain_confusion, snare, mountain), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_learned_helplessness_~w', [C]),
    format(atom(Question), 'Constraint ~w appears extractive (Snare) to individuals but unchangeable (Mountain) to institutions...', [C]), !.

omega_from_gap(C, gap(general_type_mismatch, TypeP, TypeI), OmegaID, conceptual, Question) :-
    format(atom(OmegaID), 'omega_perspectival_~w', [C]),
    format(atom(Question), 'Constraint ~w appears as ~w to individuals but ~w to institutions...', [C, TypeP, TypeI]), !.

assert_omega_if_new(OmegaID, Type, Question) :-
    (   narrative_ontology:omega_variable(OmegaID, _, _)
    ->  true
    ;   assertz(narrative_ontology:omega_variable(OmegaID, Type, Question))
    ).

/* ============================================================================
   3. INDEXED REPORTING & AUDITS
   ============================================================================ */

perspectival_gap_audit(C) :-
    format('~n  Analysis for Constraint: ~w~n', [C]),
    (constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)) -> true ; TypeP = none),
    (constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)) -> true ; TypeI = none),
    (TypeP == mountain, TypeI == rope -> format('    ! GAP: Institutional "Rope" appears as "Mountain" to Powerless.~n') ; true),
    (TypeP == snare, TypeI == rope -> format('    ! ALERT: Extractive "Snare" is masked as functional "Rope".~n') ; true),
    % Display with chi power-scaling annotations
    format_perspective_line(C, powerless, 'Individual (Powerless)', TypeP),
    format_perspective_line(C, institutional, 'Institutional (Manager)', TypeI),
    % Display Mandatrophy gap if perspectives differ
    (   TypeP \= none, TypeI \= none, TypeP \= TypeI
    ->  format_mandatrophy_gap(C, powerless, institutional)
    ;   true
    ).

%% format_perspective_line(+C, +ContextPower, +Label, +Type)
%  Prints a perspective line with chi annotation if data available.
format_perspective_line(C, ContextPower, Label, Type) :-
    (   compute_chi(C, ContextPower, BaseE, Modifier, RawChi)
    ->  (   RawChi > 1.0
        ->  format(atom(Ann), ' [chi = ~2f x ~2f = ~2f -> capped 1.00]', [BaseE, Modifier, RawChi])
        ;   RawChi < 0
        ->  format(atom(Ann), ' [chi = ~2f x ~2f = ~2f -> net benefit]', [BaseE, Modifier, RawChi])
        ;   format(atom(Ann), ' [chi = ~2f x ~2f = ~2f]', [BaseE, Modifier, RawChi])
        )
    ;   Ann = ''
    ),
    format('    - ~w: ~w ~w~n', [Label, Type, Ann]).

%% compute_chi(+C, +ContextPower, -BaseE, -Modifier, -RawChi)
%  Computes raw chi = BaseE * Modifier for a given power position.
compute_chi(C, ContextPower, BaseE, Modifier, RawChi) :-
    context_power_to_modifier_key(ContextPower, ModKey),
    domain_priors:base_extractiveness(C, BaseE),
    constraint_indexing:power_modifier(ModKey, Modifier),
    RawChi is BaseE * Modifier.

%% format_mandatrophy_gap(+C, +PowerA, +PowerB)
%  Shows the extraction gap between two power positions.
format_mandatrophy_gap(C, PowerA, PowerB) :-
    (   compute_chi(C, PowerA, _, _, RawA),
        compute_chi(C, PowerB, _, _, RawB)
    ->  EffA is min(1.0, max(0.0, RawA)),
        EffB is RawB,
        DeltaChi is abs(EffA - EffB),
        (   DeltaChi > 1.0 -> Sev = critical
        ;   DeltaChi > 0.5 -> Sev = high
        ;   Sev = moderate
        ),
        format('    ! MANDATROPHY GAP: delta_chi = ~2f (~w)~n', [DeltaChi, Sev])
    ;   true
    ).

%% context_power_to_modifier_key(+ContextPower, -ModifierKey)
%  Maps context agent_power atoms to power_modifier/2 keys.
context_power_to_modifier_key(powerless, powerless).
context_power_to_modifier_key(individual_moderate, moderate).
context_power_to_modifier_key(powerful, powerful).
context_power_to_modifier_key(collective_organized, organized).
context_power_to_modifier_key(institutional, institutional).
context_power_to_modifier_key(analytical, analytical).

report_constraint_signature(C) :-
    drl_core:dr_signature(C, Signature),
    structural_signatures:signature_confidence(C, Signature, Confidence),
    structural_signatures:explain_signature(C, Signature, Explanation),
    format('  ~20w: ~20w (confidence: ~w)~n', [C, Signature, Confidence]),
    (Signature \= ambiguous -> format('    → ~w~n', [Explanation]) ; true).

% Remaining placeholders (generate_indexed_report, extract_constraints, generate_llm_feedback, sublist, etc.) 
% should be placed here as top-level predicates...

generate_indexed_report(Text, Context, Report) :-
    extract_constraints(Text, Constraints),
    maplist(classify_with_context(Context), Constraints, Classifications),
    format_indexed_report(Classifications, Context, Report).

classify_with_context(Context, Constraint, classification(Constraint, Type)) :-
    constraint_indexing:constraint_classification(Constraint, Type, Context).

extract_constraints(Text, Constraints) :-
    atom_codes(Text, Codes),
    findall(C, (constraint_keyword(C), atom_codes(C, CCode), sublist(CCode, Codes)), Cs),
    sort(Cs, Constraints).

constraint_keyword(catholic_church_1200).
constraint_keyword(property_rights_2025).

format_indexed_report(Classifications, Context, Report) :-
    Context = context(agent_power(Power), time_horizon(Time), exit_options(Exit), spatial_scope(Scope)),
    with_output_to(atom(Report),
        (format('~n[INDEXED CONSTRAINT ANALYSIS]~n'),
         format('Perspective: ~w / ~w / ~w / ~w~n~n', [Power, Time, Exit, Scope]),
         format('Classifications:~n'),
         forall(member(classification(C, T), Classifications), format('  ~w: ~w~n', [C, T])))).

generate_llm_feedback(IntervalID) :-
    format('~n### START LLM REFINEMENT MANIFEST: ~w ###~n', [IntervalID]),
    format('~n[PERSPECTIVAL_GAPS]~n'),
    (forall(narrative_ontology:constraint_claim(C, _),
           (constraint_indexing:constraint_classification(C, TypeP, context(agent_power(powerless), _, _, _)),
            constraint_indexing:constraint_classification(C, TypeI, context(agent_power(institutional), _, _, _)),
            TypeP \= TypeI, format('  - Constraint "~w": Individual sees ~w, but Institution sees ~w.~n', [C, TypeP, TypeI]))) ; true),
    format('~n[ONTOLOGICAL_MISMATCHES]~n'),
    (setof((CM, Err, Sev), drl_core:dr_mismatch(CM, Err, Sev), Errors) -> forall(member((CM, Err, Sev), Errors), format('  - ~w: [~w] ~w detected.~n', [CM, Sev, Err])) ; format('  - None detected.~n')),
    format('~n[UNRESOLVED_OMEGAS]~n'),
    (setof((OID, OTy, ODe), narrative_ontology:omega_variable(OID, OTy, ODe), Omegas) -> forall(member((OID, OTy, ODe), Omegas), format('  - ~w (~w): ~w~n', [OID, OTy, ODe])) ; format('  - None detected.~n')),
    format('~n### END REFINEMENT MANIFEST ###~n').

sublist([], _).
sublist([H|T], [H|T2]) :- !, sublist(T, T2).
sublist(Sub, [_|T]) :- sublist(Sub, T).

classify_interval(_IntervalID, stable, high).

% Ensure these are at the BOTTOM of report_generator.pl, NOT inside generate_full_report
generate_isomorphism_audit(IntervalID) :-
    format('~n[CROSS-DOMAIN ISOMORPHISM & RISK AUDIT: ~w]~n', [IntervalID]),
    (   setof(iso(C, Twin, Score, Type),
              (narrative_ontology:constraint_claim(C, _),  % Changed: use all constraints in current KB
               isomorphism_engine:find_high_risk_isomorphism(C, Twin, Score),
               drl_core:dr_type(C, Type)),
              Isos)
    ->  display_isomorphisms(Isos)
    ;   format('  No high-risk isomorphisms detected for current constraints.~n')
    ).

display_isomorphisms([]).
display_isomorphisms([iso(C, T, S, Ty)|Rest]) :-
    format('  ! ALERT: ~w (~w) is a Structural Twin to ~w (Score: ~2f)~n', [C, Ty, T, S]),
    format('    > Strategy: Search for ~w resolutions in KB.~n', [T]),
    display_isomorphisms(Rest).

/* ============================================================================
   4. ONTOLOGICAL FORENSIC AUDIT: FALSE MOUNTAINS
   ============================================================================ */

%% forensic_audit_false_mountains/0
%  Provides detailed analysis of constraints claiming "Mountain" status
%  but failing validation. Explains WHY each fails and recommends reclassification.
forensic_audit_false_mountains :-
    format('~n[ONTOLOGICAL FORENSIC AUDIT: FALSE MOUNTAINS]~n'),
    (   setof(C-Ctx, Sev^(drl_core:dr_mismatch(C, Ctx, type_1_false_mountain, Sev)),
              FalseMountains)
    ->  (length(FalseMountains, Count),
         format('  Detected ~w constraint(s) falsely claiming "Mountain" status:~n~n', [Count]),
         forall(member(C-Context, FalseMountains),
                forensic_explain_false_mountain(C, Context)))
    ;   format('  All mountains are structurally validated.~n')
    ).

%% forensic_explain_false_mountain(+Constraint, +Context)
%  Explains in detail why a constraint fails mountain validation.
%  Now using safe helpers for defensive programming.
forensic_explain_false_mountain(C, Context) :-
    format('  ┌─ CONSTRAINT: ~w~n', [C]),
    format('  │  Context: ~w~n', [Context]),
    format('  │~n', []),

    % Get metrics using safe helpers (with defaults and logging)
    utils:safe_get_metric(C, suppression_requirement, Supp, 0.0, false),
    (Supp = 0.0
    -> format('  │  Suppression Requirement: MISSING (using default 0.0)~n', [])
    ;  format('  │  Suppression Requirement: ~2f~n', [Supp])),

    % Get mountain ceiling safely
    utils:safe_get_config(mountain_suppression_ceiling, Ceil, 0.15),
    (Ceil = 0.15
    -> format('  │  Mountain Ceiling (threshold): ~2f (default)~n', [Ceil])
    ;  format('  │  Mountain Ceiling (threshold): ~2f~n', [Ceil])),

    % Analyze why it fails
    format('  │~n', []),
    format('  │  FAILURE ANALYSIS:~n', []),
    (Supp > Ceil
    -> format('  │  ✗ Requires active enforcement (suppression ~2f > ~2f threshold)~n', [Supp, Ceil])
    ;  format('  │  ? Suppression within range, checking other factors...~n', [])),

    % Get extractiveness safely
    utils:safe_get_extractiveness(C, Extr, 0.0, false),
    (Extr = 0.0
    -> format('  │  Base Extractiveness: MISSING (using default 0.0)~n', [])
    ;  (format('  │  Base Extractiveness: ~2f~n', [Extr]),
        (Extr > 0.35
        -> format('  │  ✗ Shows extractive pattern (E > 0.35)~n', [])
        ;  format('  │  ✓ Non-extractive pattern (E ≤ 0.35)~n', [])))),

    % Check resistance to change safely
    utils:safe_get_metric(C, resistance_to_change, Resist, 0.0, false),
    (Resist = 0.0
    -> format('  │  Resistance to Change: MISSING (using default 0.0)~n', [])
    ;  format('  │  Resistance to Change: ~2f~n', [Resist])),

    % Provide forensic verdict
    format('  │~n', []),
    format('  │  FORENSIC VERDICT:~n', []),
    determine_correct_classification(Supp, Extr, Ceil, Verdict, Rationale),
    format('  │  → Should be classified as: ~w~n', [Verdict]),
    format('  │  → Rationale: ~w~n', [Rationale]),

    % Check for mandatrophy (mountain that functions as trap)
    (Extr > 0.7
    -> format('  │  ⚠ WARNING: Possible MANDATROPHY detected~n', []),
       format('  │    (Genuinely unchangeable BUT highly extractive)~n', [])
    ;  true),

    format('  └─~n~n', []).

%% determine_correct_classification(+Supp, +Extr, +Ceil, -Verdict, -Rationale)
%  Logic to determine what a false mountain should actually be classified as.
determine_correct_classification(Supp, Extr, Ceil, Verdict, Rationale) :-
    (Supp > Ceil, Extr > 0.66
    -> (Verdict = 'SNARE',
        Rationale = 'High enforcement + high extraction = extractive trap')
    ; Supp > Ceil, Extr > 0.35
    -> (Verdict = 'TANGLED_ROPE',
        Rationale = 'Moderate enforcement + moderate extraction = complex coordination with extractive elements')
    ; Supp > Ceil
    -> (Verdict = 'ROPE',
        Rationale = 'Requires enforcement but not extractive = changeable rule')
    ; Extr > 0.66
    -> (Verdict = 'SNARE (check metrics)',
        Rationale = 'High extraction despite low suppression suggests misclassification or measurement error')
    ;  (Verdict = 'AMBIGUOUS (review data)',
        Rationale = 'Metrics inconclusive, manual review required')
    ).

/* ============================================================================
   5. OMEGA RESOLUTION SCENARIOS
   ============================================================================ */

%% generate_omega_resolution_scenarios/0
%  Generates actionable test scenarios for resolving each unresolved omega.
%  This drives scenario creation by providing specific resolution strategies.
generate_omega_resolution_scenarios :-
    format('~n[OMEGA RESOLUTION SCENARIO GENERATION]~n'),
    findall(omega_data(OID, OType, ODesc, Constraint, GapPattern),
            (narrative_ontology:omega_variable(OID, OType, ODesc),
             extract_constraint_from_omega_id(OID, Constraint),
             determine_gap_pattern(OID, Constraint, GapPattern)),
            Omegas),
    (Omegas = []
    -> format('  No unresolved Omegas. System is epistemically complete.~n')
    ;  (length(Omegas, N),
        format('  Generated ~w resolution scenario(s):~n~n', [N]),
        forall(member(omega_data(OID, OType, ODesc, C, Gap), Omegas),
               generate_scenario_for_omega(OID, OType, ODesc, C, Gap)))
    ).

%% extract_constraint_from_omega_id(+OmegaID, -Constraint)
%  Extracts the constraint name from omega IDs like omega_extraction_blindness_CONSTRAINT
extract_constraint_from_omega_id(OmegaID, Constraint) :-
    atom_string(OmegaID, OIDStr),
    (sub_string(OIDStr, _, _, _, "omega_extraction_blindness_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "extraction", "blindness"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_learned_helplessness_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "learned", "helplessness"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_cut_safety_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "cut", "safety"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ; sub_string(OIDStr, _, _, _, "omega_perspectival_")
    -> split_string(OIDStr, "_", "", Parts),
       append(["omega", "perspectival"], ConstraintParts, Parts),
       atomic_list_concat(ConstraintParts, '_', Constraint)
    ;  Constraint = unknown
    ).

%% determine_gap_pattern(+OmegaID, +Constraint, -Pattern)
%  Determines which gap pattern caused this omega
determine_gap_pattern(OmegaID, Constraint, Pattern) :-
    atom_string(OmegaID, OIDStr),
    (sub_string(OIDStr, _, _, _, "extraction_blindness")
    -> (Pattern = snare_masked_as_rope)
    ; sub_string(OIDStr, _, _, _, "learned_helplessness")
    -> (Pattern = snare_mountain_confusion)
    ; sub_string(OIDStr, _, _, _, "cut_safety")
    -> (Pattern = mountain_coordination_confusion)
    ;  (Constraint \= unknown,
        detect_gap_pattern(Constraint, gap(Pattern, _, _))
       -> true
       ;  Pattern = general_type_mismatch)
    ).

%% generate_scenario_for_omega(+OmegaID, +Type, +Description, +Constraint, +GapPattern)
%  Generates a specific resolution scenario based on omega type and gap pattern.
generate_scenario_for_omega(OID, empirical, Desc, C, _Gap) :-
    format('  ┌─ [~w] EMPIRICAL DATA COLLECTION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Design measurement protocol for ~w~n', [C]),
    format('  │  2. Collect data from N=30+ real-world instances~n', []),
    format('  │  3. Calculate empirical metrics:~n', []),
    format('  │     - suppression_requirement (enforcement needed)~n', []),
    format('  │     - resistance_to_change (pushback level)~n', []),
    format('  │     - base_extractiveness (asymmetric benefit flow)~n', []),
    format('  │  4. Update constraint_metric/3 declarations with data~n', []),
    format('  │  5. Re-run classification to resolve perspectival gap~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, snare_masked_as_rope) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  CRITICAL: Extraction Masking Detected~n', []),
    format('  │  Powerless see: SNARE (extractive trap)~n', []),
    format('  │  Institutions see: ROPE (functional rule)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Interview affected individuals (N=10+):~n', []),
    format('  │     - Who benefits from ~w?~n', [C]),
    format('  │     - Can you change/exit this constraint?~n', []),
    format('  │     - What would happen if you tried?~n', []),
    format('  │  2. Interview institutional actors (N=10+):~n', []),
    format('  │     - What function does ~w serve?~n', [C]),
    format('  │     - Who would object to removing it?~n', []),
    format('  │     - What alternatives exist?~n', []),
    format('  │  3. Document benefit flows:~n', []),
    format('  │     - Track who gains vs. who loses from status quo~n', []),
    format('  │     - Measure asymmetric benefit distribution~n', []),
    format('  │  4. Decision tree:~n', []),
    format('  │     IF extraction confirmed → Reclassify as SNARE~n', []),
    format('  │     IF functional & fair → Reclassify as ROPE~n', []),
    format('  │     IF context-dependent → Add indexical resolution~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, snare_mountain_confusion) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  CRITICAL: Learned Helplessness Pattern~n', []),
    format('  │  Powerless see: SNARE (extractive trap)~n', []),
    format('  │  Institutions see: MOUNTAIN (unchangeable law)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Test changeability:~n', []),
    format('  │     - Can institutions modify ~w?~n', [C]),
    format('  │     - What legal/political mechanisms exist?~n', []),
    format('  │     - Historical precedents of change?~n', []),
    format('  │  2. Test extraction:~n', []),
    format('  │     - Is benefit flow symmetric or asymmetric?~n', []),
    format('  │     - Who has veto power over changes?~n', []),
    format('  │  3. Decision tree:~n', []),
    format('  │     IF truly unchangeable + extractive → MANDATROPHY~n', []),
    format('  │     IF changeable + extractive → Correct to SNARE~n', []),
    format('  │     IF unchangeable + fair → Correct to MOUNTAIN~n', []),
    format('  │     IF institutions falsely claim necessity → SNARE + fraud flag~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, mountain_coordination_confusion) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  HIGH RISK: Coordination Cut Safety~n', []),
    format('  │  Powerless see: MOUNTAIN (unchangeable, survival-critical)~n', []),
    format('  │  Institutions see: ROPE (optional, changeable)~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. SAFETY ASSESSMENT (DO NOT SKIP):~n', []),
    format('  │     - If institutions cut ~w, do individuals have alternatives?~n', [C]),
    format('  │     - Is this their only survival mechanism?~n', []),
    format('  │     - What scaffolding exists for transition?~n', []),
    format('  │  2. Test institutional perception:~n', []),
    format('  │     - Can institutions unilaterally change this?~n', []),
    format('  │     - Do they understand downstream impacts?~n', []),
    format('  │     - Is their "optional" view empirically accurate?~n', []),
    format('  │  3. Decision tree:~n', []),
    format('  │     IF truly unchangeable → Correct institutional view to MOUNTAIN~n', []),
    format('  │     IF changeable + safe alternatives → Correct powerless view to ROPE~n', []),
    format('  │     IF changeable + NO alternatives → ADD SCAFFOLD before any change~n', []),
    format('  │     IF uncertainty → HALT changes until resolved~n', []),
    format('  │  4. CRITICAL: Never proceed with changes until safety verified~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, conceptual, Desc, C, general_type_mismatch) :-
    format('  ┌─ [~w] CONCEPTUAL CLARIFICATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Map stakeholder perspectives:~n', []),
    format('  │     - Document how different actors perceive ~w~n', [C]),
    format('  │     - Identify source of divergence~n', []),
    format('  │  2. Gather evidence:~n', []),
    format('  │     - Empirical metrics (suppression, extraction, resistance)~n', []),
    format('  │     - Historical behavior patterns~n', []),
    format('  │  3. Create indexical classification:~n', []),
    format('  │     - From powerless context: classify as X~n', []),
    format('  │     - From institutional context: classify as Y~n', []),
    format('  │     - Add explicit context annotations~n', []),
    format('  └─~n~n', []).

generate_scenario_for_omega(OID, preference, Desc, C, _Gap) :-
    format('  ┌─ [~w] VALUE ARBITRATION~n', [OID]),
    format('  │  Constraint: ~w~n', [C]),
    format('  │  Gap: ~w~n', [Desc]),
    format('  │~n', []),
    format('  │  NOTE: Not resolvable via data or logic alone~n', []),
    format('  │~n', []),
    format('  │  RESOLUTION STRATEGY:~n', []),
    format('  │  1. Document competing value frameworks:~n', []),
    format('  │     - What values support current ~w?~n', [C]),
    format('  │     - What values oppose it?~n', []),
    format('  │     - Are these incommensurable?~n', []),
    format('  │  2. Propose scaffolded solution:~n', []),
    format('  │     - Design mechanism respecting both value sets~n', []),
    format('  │     - Create exit options for dissenters~n', []),
    format('  │     - Allow preference-based sorting~n', []),
    format('  │  3. Accept unresolvability if necessary:~n', []),
    format('  │     - Some omegas represent genuine value pluralism~n', []),
    format('  │     - Solution: coexistence, not consensus~n', []),
    format('  └─~n~n', []).

/* ============================================================================
   6. OMEGA SEVERITY TRIAGE
   ============================================================================ */

%% omega_severity(+OmegaID, -Severity)
%  Prioritizes omegas by severity/urgency.
omega_severity(OID, critical) :-
    atom(OID),
    (sub_atom(OID, _, _, _, extraction_blindness)
    ; (narrative_ontology:omega_variable(OID, _, Desc),
       atom(Desc),
       (sub_atom(Desc, _, _, _, extraction)
       ; sub_atom(Desc, _, _, _, snare)
       ; sub_atom(Desc, _, _, _, 'Snare')
       ; sub_atom(Desc, _, _, _, trap)))
    ), !.

omega_severity(OID, high) :-
    atom(OID),
    (sub_atom(OID, _, _, _, learned_helplessness)
    ; sub_atom(OID, _, _, _, cut_safety)
    ; narrative_ontology:omega_variable(OID, conceptual, _)
    ), !.

omega_severity(OID, moderate) :-
    atom(OID),
    narrative_ontology:omega_variable(OID, empirical, _), !.

omega_severity(OID, low) :-
    atom(OID),
    narrative_ontology:omega_variable(OID, preference, _), !.

omega_severity(_, unknown).

%% generate_omega_triage/0
%  Displays omegas organized by severity level.
generate_omega_triage :-
    format('~n[OMEGA TRIAGE & PRIORITIZATION]~n'),
    % First collect all actual omegas
    findall(OID, narrative_ontology:omega_variable(OID, _, _), AllOmegas),
    (AllOmegas = []
    -> format('  No omegas to triage.~n')
    ;  % Then organize by severity
       forall(member(Sev, [critical, high, moderate, low]),
              (findall(OID,
                       (member(OID, AllOmegas), omega_severity(OID, Sev)),
                       OIDs),
               (OIDs \= []
               -> (length(OIDs, N),
                   format('~n  [~w] ~w omega(s):~n', [Sev, N]),
                   forall(member(OID, OIDs),
                          (narrative_ontology:omega_variable(OID, Type, Desc),
                           format('    - ~w (~w)~n      ~w~n', [OID, Type, Desc]))))
               ;  true)))
    ).

/* ============================================================================
   7. COMPREHENSIVE CROSS-DOMAIN AUDIT
   ============================================================================ */

%% cross_domain_audit/0
%  Scans ALL constraints in current KB and reports cross-domain structural twins.
%  This provides a comprehensive view of isomorphic patterns across different domains.
cross_domain_audit :-
    format('~n[COMPREHENSIVE CROSS-DOMAIN STRUCTURAL TWINS]~n'),
    findall(iso(C1, C2, Score, Cat1, Cat2),
            (narrative_ontology:constraint_claim(C1, _),
             domain_priors:category_of(C1, Cat1),
             isomorphism_engine:find_isomorphism(C1, C2, Score),
             domain_priors:category_of(C2, Cat2),
             Cat1 \= Cat2,  % Only cross-domain twins
             C1 @< C2),     % Prevent duplicate pairs (A,B) and (B,A)
            Isos),
    (Isos = []
    -> format('  No cross-domain isomorphisms detected.~n')
    ;  (length(Isos, N),
        format('  Found ~w cross-domain structural twins:~n~n', [N]),
        forall(member(iso(C1, C2, S, Cat1, Cat2), Isos),
               (format('  ~w (~w) ≈ ~w (~w)~n', [C1, Cat1, C2, Cat2]),
                format('    Similarity Score: ~2f~n', [S]),
                display_twin_rationale(C1, C2),
                nl)))
    ).

%% display_twin_rationale(+C1, +C2)
%  Explains why two constraints are considered structural twins.
display_twin_rationale(C1, C2) :-
    (structural_signatures:get_constraint_profile(C1, Profile1),
     structural_signatures:get_constraint_profile(C2, Profile2)
    -> (Profile1 = profile(A1, S1, R1, B1, Alt1, _, _),
        Profile2 = profile(A2, S2, R2, B2, Alt2, _, _),
        format('    Metrics: ', []),
        (abs(A1 - A2) < 0.15 -> format('Accum≈ ', []) ; true),
        (abs(S1 - S2) < 0.15 -> format('Supp≈ ', []) ; true),
        (abs(R1 - R2) < 0.15 -> format('Repr≈ ', []) ; true),
        (abs(B1 - B2) < 1.0 -> format('BenefΔ≈ ', []) ; true),
        (Alt1 = Alt2 -> format('AltMatch ', []) ; true),
        nl,
        format('    Implication: Solutions for ~w may inform ~w~n', [C1, C2]))
    ;  format('    (Profile data incomplete)~n')
    ).
:- module(scenario_manager, [
    clear_kb/0,
    load_and_run/2,
    list_active_intervals/0
]).

:- use_module(narrative_ontology).
:- use_module(test_harness).

% 1. FORCE DYNAMIC STATE
% This prevents "Redefined static procedure" errors even if the dataset 
% is generated without dynamic headers.
:- dynamic 
    narrative_ontology:entity/2, 
    narrative_ontology:interval/3, 
    narrative_ontology:event/4, 
    narrative_ontology:measurement/2, 
    narrative_ontology:constraint_claim/2, 
    narrative_ontology:constraint_metric/3, 
    narrative_ontology:omega_variable/3, 
    narrative_ontology:recommendation/2, 
    narrative_ontology:affects_constraint/2, 
    narrative_ontology:veto_actor/1, 
    narrative_ontology:veto_exposed/2,
    narrative_ontology:intent_fact/4.

/**
 * clear_kb
 * Forcefully retracts all facts.
 */
clear_kb :-
    format('~n[SCENARIO MANAGER] Clearing Knowledge Base...~n'),
    % Core Layers
    retractall(narrative_ontology:entity(_, _)),
    retractall(narrative_ontology:interval(_, _, _)),
    retractall(narrative_ontology:event(_, _, _, _)),
    retractall(narrative_ontology:measurement(_, _, _, _, _)),
    % Constraint Layer
    retractall(narrative_ontology:constraint_claim(_, _)),
    retractall(narrative_ontology:constraint_metric(_, _, _)),
    retractall(narrative_ontology:omega_variable(_,_,_)),
    retractall(narrative_ontology:recommendation(_, _)),
    retractall(narrative_ontology:affects_constraint(_, _)),
    retractall(narrative_ontology:veto_actor(_)),
    retractall(narrative_ontology:veto_exposed(_, _)),
    % Intent Layer
    retractall(narrative_ontology:intent_viable_alternative(_, _, _)),
    retractall(narrative_ontology:intent_alternative_rejected(_, _, _)),
    retractall(narrative_ontology:intent_beneficiary_class(_, _)),
    retractall(narrative_ontology:intent_power_change(_, _, _)),
    retractall(narrative_ontology:intent_suppression_level(_, _, _, _)),
    retractall(narrative_ontology:intent_resistance_level(_, _, _, _)),
    retractall(narrative_ontology:intent_norm_strength(_, _, _)),
    format('[OK] Knowledge Base is empty.~n').

% =============================================================================
% UPDATED Section 3: GLOBAL TEMPORAL SANITIZATION
% =============================================================================
% Iterate through EVERY interval in the KB to satisfy the Broad Auditor.
sanitize_all_intervals :-
    forall(narrative_ontology:interval(_ID, Start, End), (
        ensure_endpoint(Start),
        ensure_endpoint(End)
    )).

ensure_endpoint(T) :-
    narrative_ontology:measurement(T, _) -> true ; 
    % Impute neutral padding for any endpoint found in any interval.
    assertz(narrative_ontology:measurement(T, [0.5, 0.5, 0.5, 0.5])).

% 4. OMEGA ROUTER
% Routes Omega variables to appropriate resolution channels based 
% on the classification framework.
route_omega(ID) :-
    narrative_ontology:omega_variable(ID, Type, Desc),
    format('[OMEGA] Identified ~w (~w): ~w~n', [ID, Type, Desc]),
    (   Type == empirical  -> format(' -> Action: Design Measurement/Experiment.~n')
    ;   Type == conceptual -> format(' -> Action: Define Framework/Terms.~n')
    ;   Type == preference -> format(' -> Action: Escalate to Stakeholders.~n')
    ;   format(' -> Warning: Unknown Omega Type.~n')
    ). % Added missing closing parenthesis and period.

% =============================================================================
% UPDATED Section 5: TEST EXECUTION (Scenario Manager)
% =============================================================================
load_and_run(File, IntervalID) :-
    clear_kb,
    (   exists_file(File)
    ->  format('[SCENARIO MANAGER] Loading: ~w...~n', [File]),
        user:consult(File),

	% INJECT STRUCTURAL ANCHOR: Resolves [STEP 1] errors
        % This provides the audit suite with the interval it expects.
        assertz(narrative_ontology:interval(IntervalID, 0, 10)),
        inject_minimal_measurements(IntervalID),
	
        % FIX: Repair ALL intervals found in the KB, not just the primary one.
        format('[SCENARIO MANAGER] Performing Global Repair...~n'),
        forall(narrative_ontology:interval(ID, _, _), 
               data_repair:repair_interval(ID)),
        
        % Proceed with the standard test suite
        test_harness:run_all_tests(IntervalID)
    ;   format('[ERROR] File ~w not found.~n', [File]),
        fail
    ).

% 6. HELPER
list_active_intervals :-
    findall(ID, narrative_ontology:interval(ID, _, _), IDs),
    format('~nActive Intervals in KB: ~w~n', [IDs]).

% Helper to keep the main predicate clean
inject_minimal_measurements(ID) :-
    forall(member(T, [0, 10]),
        ( assertz(narrative_ontology:measurement(m_gen, ID, accessibility_collapse(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, stakes_inflation(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, suppression(structural), T, 0.5)),
          assertz(narrative_ontology:measurement(m_gen, ID, resistance(structural), T, 0.5))
        )).
/* ================================================================
   v3.2 STRUCTURAL SIGNATURE CONFIGURATION
   
   Add these parameters to config.pl to enable signature detection
   ================================================================ */

% NATURAL LAW SIGNATURE THRESHOLDS
% These identify constraints that are inherent properties of reality

param(natural_law_collapse_min, 0.85).
% Minimum accessibility collapse for natural law
% Natural laws affect everyone equally (high collapse)

param(natural_law_suppression_max, 0.15).
% Maximum suppression for natural law
% Natural laws don't require enforcement

param(natural_law_resistance_max, 0.15).
% Maximum resistance for natural law
% Natural laws cannot be effectively resisted

% COORDINATION SCAFFOLD SIGNATURE THRESHOLDS  
% These identify successful voluntary coordination standards

param(coordination_collapse_min, 0.85).
% Minimum accessibility collapse for coordination
% Successful standards achieve universal adoption

param(coordination_suppression_max, 0.15).
% Maximum suppression for coordination
% Coordination scaffolds are adopted voluntarily

param(coordination_resistance_max, 0.15).
% Maximum resistance for coordination
% Successful coordination faces minimal opposition

% CONSTRUCTED CONSTRAINT SIGNATURE THRESHOLDS
% These identify institutionally enforced rules

param(constructed_suppression_min, 0.20).
% Minimum suppression indicating institutional enforcement
% Constructed constraints require active maintenance

param(constructed_resistance_min, 0.20).
% Minimum resistance indicating opposition
% Constructed constraints face pushback

param(constructed_beneficiary_min, 2).
% Minimum beneficiary count for asymmetric gains
% Constructed constraints often benefit specific groups

/* ================================================================
   USAGE NOTES
   
   1. Natural Law vs Coordination Scaffold Distinction:
      Both have extreme collapse + minimal enforcement
      KEY DIFFERENCE: Coordination had viable alternatives
      
   2. Calibration Recommendations:
      - Start with these defaults
      - Monitor false positives in conceptual domains
      - Adjust collapse_min down if too restrictive
      - Adjust suppression_max up if missing constructs
      
   3. Integration with Existing System:
      - Structural signatures OVERRIDE modal classification
      - Use integrate_signature_with_modal/3 in report flow
      - Add signature explanations to audit output
   ================================================================ */
:- module(signature_mapper, [
    map_custom_pillar/3
]).

:- use_module(narrative_ontology).
:- use_module(structural_signatures).
:- use_module(config).

%% map_custom_pillar(+Constraint, +CustomType, -StandardType)
%  Maps non-standard terminology to v3.1 standard pillars based on metrics.
map_custom_pillar(_C, CustomType, StandardType) :-
    % If already standard, do nothing
    member(CustomType, [mountain, rope, tangled_rope, snare, scaffold, piton]),
    StandardType = CustomType, !.

map_custom_pillar(C, _CustomType, StandardType) :-
    % Analyze structural signature based on current metrics
    structural_signatures:constraint_signature(C, Signature),
    resolve_mapping(Signature, StandardType).

% Natural Laws and high-stability invariants are Mountains
resolve_mapping(natural_law, mountain).
% Successful voluntary coordination (like decentralized_governance) are Ropes
resolve_mapping(coordination_scaffold, rope).
% A scaffold that has decayed into a liability is a Piton
resolve_mapping(piton_signature, piton).
% Asymmetric, enforced, or extractive rules are Nooses
resolve_mapping(constructed_constraint, snare).
% Fallback for ambiguous data
resolve_mapping(ambiguous, rope).
:- module(stack, [
    initialize_system/0,
    run_scenario/2
]).

% 1. Load Core Knowledge Schema
:- use_module(narrative_ontology).      % Schema & Global Expansion
:- use_module(config).             % Grounded Weights & Thresholds

% 2. Load Data & Priors
:- use_module(domain_priors).
:- use_module(constraint_instances).

% 3. Load Core Logic
:- use_module(constraint_indexing).
:- use_module(structural_signatures).
:- use_module(drl_core).
:- use_module(drl_modal_logic, []).
:- use_module(drl_audit_core, []).

% 4. Load Management & Control (NEW)
:- use_module(scenario_manager, []).    % Lifecycle Controller

% 5. Load Functional Engines (Imported but silenced for namespace safety)
:- use_module(coercion_projection, []).
:- use_module(data_repair, []).
:- use_module(data_verification, []).
:- use_module(pattern_analysis, []).
:- use_module(intent_engine, []).
:- use_module(drl_lifecycle, []).       % Drift event detection & lifecycle analysis

% 4. Load Diagnostic & UI
:- use_module(constraint_bridge, []).
:- use_module(uke_dr_bridge, []).
:- use_module(report_generator, []).
:- use_module(test_harness, []).

% Add the directory of this file to the library search path
:- prolog_load_context(directory, Dir),
   asserta(user:file_search_path(library, Dir)).

/* ================================================================
   SCENARIO ALIASES
   ================================================================ */

%% run_scenario(+File, +IntervalID)
%  Convenience alias for the Scenario Manager's load_and_run predicate.
run_scenario(File, IntervalID) :-
    scenario_manager:load_and_run(File, IntervalID).

/* ================================================================
   INITIALIZATION
   ================================================================ */

initialize_system :-
    format('~n====================================================~n'),
    format('   STRUCTURAL ANALYSIS STACK INITIALIZED             ~n'),
    format('====================================================~n'),
    format('Control:    Scenario Manager Active~n'),
    format('Usage:      run_scenario(\'file.pl\', interval_id).~n'),
    format('====================================================~n').

:- initialize_system.
:- module(structural_signatures, [
    constraint_signature/2,
    signature_confidence/3,
    explain_signature/3,
    integrate_signature_with_modal/3
]).

:- use_module(library(lists)).
:- use_module(narrative_ontology).
:- use_module(config).

/* ================================================================
   STRUCTURAL SIGNATURE DETECTION v3.2
   
   Problem Statement (from Copilot's analysis):
   "Your classifier sees MAGNITUDE but not TYPE."
   
   The current DRL classifier uses only metric thresholds:
   - suppression > 0.1 → not a mountain
   - extractiveness > 0.7 → snare
   
   This causes misclassification of conceptual constraints:
   - Chaitin's Ω: collapse=1.0, suppression=0.0 → classified as mountain
   - Special Relativity: collapse=1.0, suppression=0.0 → classified as mountain
   - Arrow's Theorem: collapse=0.9, suppression=0.1 → fraud detection fires
   
   But these are STRUCTURALLY DIFFERENT:
   - Chaitin's Ω = NATURAL LAW (inherent impossibility)
   - Special Relativity = COORDINATION SCAFFOLD (successful standard)
   - Arrow's Theorem = NATURAL LAW (mathematical impossibility)
   
   Solution: Add STRUCTURAL SIGNATURES that detect constraint ORIGIN
   rather than just constraint METRICS.
   
   Three Core Signatures:
   1. Natural Law - empirical invariant, no alternatives possible
   2. Coordination Scaffold - voluntary equilibrium, alternatives existed
   3. Constructed Constraint - enforced rule, power asymmetries
   ================================================================ */

%% constraint_signature(+ConstraintID, -Signature)
%  Main entry point: classifies structural signature
%  Returns: natural_law | coordination_scaffold | constructed_constraint | ambiguous
constraint_signature(C, Signature) :-
    get_constraint_profile(C, Profile),
    classify_by_signature(Profile, Signature).

/* ================================================================
   PROFILE EXTRACTION
   
   Extracts 7 key features for signature classification:
   1. Accessibility Collapse (avg across time)
   2. Suppression Requirement (avg across time)
   3. Resistance Level (avg across time)
   4. Beneficiary Count (how many asymmetric winners)
   5. Has Viable Alternatives (were there choices?)
   6. Temporal Stability (does it evolve or remain constant?)
   7. Coordination Success (high access + low enforcement)
   ================================================================ */

get_constraint_profile(C, 
                      profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives, 
                             TemporalStability, CoordinationSuccess)) :-
    
    config:param(suppression_metric_name, SuppMetricName),
    
    % Get averaged metrics across all levels
    get_metric_average(C, accessibility_collapse, AccessCollapse),
    get_metric_average(C, SuppMetricName, Suppression),
    get_metric_average(C, resistance, Resistance),
    
    % Count asymmetric beneficiaries
    count_power_beneficiaries(C, BeneficiaryCount),
    
    % Check for viable alternatives
    has_viable_alternatives(C, HasAlternatives),
    
    % Compute temporal stability
    compute_temporal_stability(C, SuppMetricName, TemporalStability),
    
    % Check coordination success pattern
    CoordinationSuccess = (AccessCollapse > 0.8, Suppression < 0.2).

%% get_metric_average(+Constraint, +MetricType, -Average)
%  Averages a metric across all levels (structural, organizational, class, individual)
get_metric_average(C, MetricType, Average) :-
    findall(Val, narrative_ontology:constraint_metric(C, MetricType, Val), Vals),
    (   Vals \= []
    ->  sum_list(Vals, Sum),
        length(Vals, N),
        Average is Sum / N
    ;   Average = 0.5  % Default if no data
    ).

%% count_power_beneficiaries(+Constraint, -Count)
%  Counts distinct classes with positive power changes
count_power_beneficiaries(C, Count) :-
    % Find intervals affecting this constraint
    findall(Class, (
        narrative_ontology:affects_constraint(I, C),
        narrative_ontology:intent_power_change(I, Class, Delta),
        Delta > 0.1  % Meaningful gain threshold
    ), Beneficiaries),
    sort(Beneficiaries, UniqueBeneficiaries),
    length(UniqueBeneficiaries, Count).

%% has_viable_alternatives(+Constraint, -HasAlternatives)
%  Checks if viable alternatives were considered (indicates choice vs necessity)
has_viable_alternatives(C, true) :-
    narrative_ontology:affects_constraint(I, C),
    narrative_ontology:intent_viable_alternative(I, _, _), !.
has_viable_alternatives(_, false).

%% compute_temporal_stability(+Constraint, -Stability)
%  Measures whether constraint metrics remain stable over time
%  Returns: stable | evolving
compute_temporal_stability(C, MetricName, Stability) :-
    % Get suppression values at different time points for this constraint
    findall(Val, 
            narrative_ontology:constraint_metric(C, MetricName, Val),
            Vals),
    (   Vals = []
    ->  Stability = unknown
    ;   Vals = [_SingleVal]
    ->  Stability = stable  % Only one measurement
    ;   compute_variance(Vals, Variance),
        (   Variance < 0.05
        ->  Stability = stable
        ;   Stability = evolving
        )
    ).

compute_variance(Vals, Variance) :-
    length(Vals, N),
    N > 0,
    sum_list(Vals, Sum),
    Mean is Sum / N,
    findall(SqDiff, (member(V, Vals), SqDiff is (V - Mean) * (V - Mean)), SqDiffs),
    sum_list(SqDiffs, SumSqDiffs),
    Variance is SumSqDiffs / N.

/* ================================================================
   SIGNATURE CLASSIFICATION LOGIC
   
   Decision Tree:
   
   1. Check Natural Law signature FIRST (most specific)
      - Extreme collapse + minimal enforcement + no alternatives
      - Examples: Chaitin's Ω, Heisenberg, Arrow's Theorem
      
   2. Check Coordination Scaffold SECOND
      - Extreme collapse + minimal enforcement + HAS alternatives
      - Examples: Special Relativity, SI Units, ISO Standards
      
   3. Check Constructed Constraint LAST (most general)
      - Positive enforcement OR beneficiary asymmetries
      - Examples: 26 USC §469, GS1 Barcodes, Hammurabi's Code
      
   4. Otherwise: ambiguous
   ================================================================ */

classify_by_signature(Profile, natural_law) :-
    natural_law_signature(Profile), !.

classify_by_signature(Profile, coordination_scaffold) :-
    coordination_scaffold_signature(Profile), !.

classify_by_signature(Profile, piton_signature) :-
    piton_signature(Profile), !.

classify_by_signature(Profile, constructed_constraint) :-
    constructed_constraint_signature(Profile), !.

classify_by_signature(_, ambiguous).

/* ================================================================
   SIGNATURE 1: NATURAL LAW
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero beneficiaries (no asymmetric winners)
   ✓ No viable alternatives (not a choice)
   ✓ Temporally stable (doesn't evolve)
   
   Interpretation:
   This is an INHERENT PROPERTY of the system, not a human choice.
   It cannot be changed by coordination or enforcement.
   
   Examples:
   - Chaitin's Omega (algorithmic information limit)
   - Heisenberg Uncertainty (quantum measurement limit)
   - Arrow's Impossibility (social choice limit)
   - Second Law of Thermodynamics (entropy increase)
   ================================================================ */

natural_law_signature(profile(AccessCollapse, Suppression, Resistance,
                             BeneficiaryCount, HasAlternatives,
                             TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions
    config:param(natural_law_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    config:param(natural_law_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    config:param(natural_law_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (CRITICAL for distinguishing from coordination)
    BeneficiaryCount == 0,  % No asymmetric winners
    HasAlternatives == false,  % Not a choice
    TemporalStability == stable.  % Doesn't evolve

/* ================================================================
   SIGNATURE 2: COORDINATION SCAFFOLD
   
   Diagnostic Pattern:
   ✓ Extreme accessibility collapse (≥ 0.85)
   ✓ Minimal suppression (≤ 0.15)
   ✓ Minimal resistance (≤ 0.15)
   ✓ Zero or few beneficiaries (symmetric benefits)
   ✓ HAS viable alternatives (WAS a choice)
   ✓ May be stable or evolving (can be refined)
   
   KEY DISTINCTION from Natural Law:
   - Alternatives EXISTED → this was a COORDINATION CHOICE
   - Success is CONTINGENT → depends on continued acceptance
   - Could theoretically be replaced → not inherent to reality
   
   Interpretation:
   This is a SUCCESSFUL VOLUNTARY STANDARD that everyone adopted
   because it provides symmetric coordination benefits.
   
   Examples:
   - Special Relativity (replaced Newtonian mechanics)
   - SI Metric System (replaced imperial units)
   - UTC Time Standard (replaced local solar time)
   - IP Protocol (replaced other network protocols)
   ================================================================ */

coordination_scaffold_signature(profile(AccessCollapse, Suppression, Resistance,
                                       BeneficiaryCount, HasAlternatives,
                                       _TemporalStability, _CoordinationSuccess)) :-
    
    % Metric conditions (same as natural law)
    config:param(coordination_collapse_min, CollapseMin),
    AccessCollapse >= CollapseMin,  % Default: 0.85
    
    config:param(coordination_suppression_max, SuppMax),
    Suppression =< SuppMax,  % Default: 0.15
    
    config:param(coordination_resistance_max, ResMax),
    Resistance =< ResMax,  % Default: 0.15
    
    % Structural conditions (DIFFERENT from natural law)
    BeneficiaryCount =< 1,  % Symmetric or near-symmetric
    HasAlternatives == true.  % KEY: This WAS a choice

/* ================================================================
   SIGNATURE 3: PITON
   
   Diagnostic Pattern:
   ✓ Variable accessibility collapse
   ✓ Low suppression (≤ 0.2) - persists through inertia, not force
   ✓ Positive resistance (> 0.2) - it's now causing friction
   ✓ Had viable alternatives - it was originally a choice
   ✓ Temporally evolving - it got worse over time
   
   Interpretation:
   This was once a useful coordination scaffold (a Rope), but has since
   ossified and now creates more problems than it solves. It persists
   due to high switching costs and institutional inertia. It is a Piton
   stuck in the mountain.
   
   Examples:
   - QWERTY Keyboard Layout
   - Legacy software monoliths
   ================================================================ */

piton_signature(profile(_AccessCollapse, Suppression, Resistance,
                                   _BeneficiaryCount, HasAlternatives,
                                   TemporalStability, _CoordinationSuccess)) :-
    Suppression =< 0.2,       % Low active enforcement
    Resistance > 0.2,         % But people are pushing back
    HasAlternatives == true,  % It was a choice
    TemporalStability == evolving. % It has decayed or gotten worse

/* ================================================================
   SIGNATURE 4: CONSTRUCTED CONSTRAINT
   
   Diagnostic Pattern:
   ✓ Variable accessibility collapse
   ✓ Positive suppression (> 0.2) OR
   ✓ Positive resistance (> 0.2) OR
   ✓ Multiple beneficiaries (asymmetric gains)
   
   Interpretation:
   This is an INSTITUTIONALLY ENFORCED RULE that requires
   active maintenance and produces asymmetric outcomes.
   
   Examples:
   - 26 USC §469 (passive loss limitation)
   - GS1 Barcode System (licensing monopoly)
   - Hammurabi's Code (benefice system)
   - Lehman's Repo 105 (accounting fiction)
   ================================================================ */

constructed_constraint_signature(profile(_AccessCollapse, Suppression, Resistance,
                                        BeneficiaryCount, _HasAlternatives,
                                        _TemporalStability, _CoordinationSuccess)) :-
    
    % At least one indicator of constructed constraint
    (   Suppression > 0.2        % Requires enforcement
    ;   Resistance > 0.2         % Faces opposition  
    ;   BeneficiaryCount > 1     % Asymmetric benefits
    ).

/* ================================================================
   CONFIDENCE SCORING
   
   Returns confidence level based on how strongly the signature
   pattern matches the classification.
   ================================================================ */

%% signature_confidence(+ConstraintID, +Signature, -Confidence)
%  Returns: high | medium | low
signature_confidence(C, Signature, Confidence) :-
    get_constraint_profile(C, Profile),
    compute_signature_confidence(Profile, Signature, Confidence).

compute_signature_confidence(Profile, natural_law, Confidence) :-
    Profile = profile(AccessCollapse, Suppression, Resistance, _, _, _, _),
    
    % Count strong indicators
    findall(1, (
        (AccessCollapse > 0.95);
        (Suppression < 0.05);
        (Resistance < 0.05)
    ), Indicators),
    length(Indicators, Count),
    
    (   Count >= 3 -> Confidence = high
    ;   Count >= 2 -> Confidence = medium
    ;   Confidence = low
    ).

compute_signature_confidence(Profile, coordination_scaffold, Confidence) :-

    Profile = profile(AccessCollapse, Suppression, _, _, HasAlternatives, _, _),

    

    % Strong indicators

    findall(1, (

        (AccessCollapse > 0.95);

        (Suppression < 0.05);

        (HasAlternatives == true)  % Critical for coordination

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 3 -> Confidence = high

    ;   Count >= 2 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(Profile, piton_signature, Confidence) :-

    Profile = profile(_, Suppression, Resistance, _, HasAlternatives, TemporalStability, _),

    

    % Count strong indicators for a piton

    findall(1, (

        (Suppression =< 0.2);

        (Resistance > 0.5);

        (HasAlternatives == true);

        (TemporalStability == evolving)

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 3 -> Confidence = high

    ;   Count >= 2 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(Profile, constructed_constraint, Confidence) :-

    Profile = profile(_, Suppression, Resistance, BeneficiaryCount, _, _, _),

    

    % Count enforcement indicators

    findall(1, (

        (Suppression > 0.5);

        (Resistance > 0.5);

        (BeneficiaryCount > 2)

    ), Indicators),

    length(Indicators, Count),

    

    (   Count >= 2 -> Confidence = high

    ;   Count >= 1 -> Confidence = medium

    ;   Confidence = low

    ).



compute_signature_confidence(_, ambiguous, low).

/* ================================================================
   EXPLANATION GENERATION
   ================================================================ */

%% explain_signature(+ConstraintID, +Signature, -Explanation)
explain_signature(C, natural_law, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, R, _, _, _, _),
    format(atom(Explanation),
           'NATURAL LAW signature for ~w: Extreme inaccessibility (collapse=~2f) with minimal enforcement (suppression=~2f, resistance=~2f). No viable alternatives exist. This represents an inherent property of the system, not a coordination choice. Cannot be changed by policy.',
           [C, AC, S, R]).

explain_signature(C, coordination_scaffold, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(AC, S, _, _, _, _, _),
    format(atom(Explanation),
           'COORDINATION SCAFFOLD signature for ~w: Extreme accessibility (collapse=~2f) with minimal enforcement (suppression=~2f). Viable alternatives existed historically, indicating this is a successful coordination standard rather than a natural law. Maintains adoption through symmetric benefits.',
           [C, AC, S]).

explain_signature(C, piton_signature, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(_, S, R, _, _, _, _),
    format(atom(Explanation),
           'PITON signature for ~w: Persists through inertia (suppression=~2f) but faces user friction (resistance=~2f). Was once a choice, but has now become an ossified liability. This is a Piton.',
           [C, S, R]).

explain_signature(C, constructed_constraint, Explanation) :-
    get_constraint_profile(C, Profile),
    Profile = profile(_, S, R, BC, _, _, _),
    format(atom(Explanation),
           'CONSTRUCTED CONSTRAINT signature for ~w: Active enforcement detected (suppression=~2f, resistance=~2f) with ~d asymmetric beneficiaries. This is an institutionally maintained rule requiring ongoing suppression energy.',
           [C, S, R, BC]).

explain_signature(C, ambiguous, Explanation) :-
    format(atom(Explanation),
           'AMBIGUOUS signature for ~w: Insufficient structural differentiation to classify. Consider gathering more data on alternatives, beneficiaries, and temporal evolution.',
           [C]).

/* ================================================================
   INTEGRATION WITH MODAL CLASSIFICATION
   
   This is the key integration point: structural signatures
   OVERRIDE modal classification when there's a mismatch.
   
   Example: Special Relativity
   - Modal classifier says: "mountain" (suppression=0, snapback=0)
   - Signature detector says: "coordination_scaffold"
   - Integrated result: "rope" with note about coordination success
   ================================================================ */

%% integrate_signature_with_modal(+Constraint, +ModalType, -AdjustedType)
%  Adjusts modal classification based on structural signature
integrate_signature_with_modal(C, ModalType, AdjustedType) :-
    constraint_signature(C, Signature),
    resolve_modal_signature_conflict(ModalType, Signature, AdjustedType).

% Natural laws stay as mountains (correct classification)
resolve_modal_signature_conflict(mountain, natural_law, mountain) :- !.

% Coordination scaffolds should be ROPES not mountains
resolve_modal_signature_conflict(mountain, coordination_scaffold, rope) :- !.

% Constructed constraints override mountain classification
resolve_modal_signature_conflict(mountain, constructed_constraint, tangled_rope) :- !.

% No conflict - keep original classification
resolve_modal_signature_conflict(ModalType, _, ModalType).
% ============================================================================ 
% REFERENCE IMPLEMENTATIONS: Tangled Rope Category 
% ============================================================================ 
% Purpose: Canonical examples validated by corpus analysis 
% Added: January 2026 (based on empirical validation of 467 constraints) 
% Empirical finding: 168/467 constraints (36%) show hybrid coordination/extraction pattern 
% 
% NOTE: This file is a collection of examples and not a standard constraint story. 
% ============================================================================ 

:- module(tangled_rope_examples, []). 

:- use_module(constraint_indexing). 
:- use_module(domain_priors). 
:- use_module(narrative_ontology). 

% Multifile declarations for predicates defined across test files 
:- multifile 
    domain_priors:base_extractiveness/2, 
    domain_priors:suppression_score/2, 
    domain_priors:requires_active_enforcement/1, 
    constraint_indexing:constraint_classification/3, 
    constraint_beneficiary/2, 
    constraint_victim/2. 

% Discontiguous declarations for predicates defined in multiple places 
:- discontiguous 
    domain_priors:base_extractiveness/2, 
    domain_priors:suppression_score/2, 
    domain_priors:requires_active_enforcement/1, 
    constraint_beneficiary/2, 
    constraint_victim/2. 

/* ========================================================================== 
   EXAMPLE 1: Carbon Credit Trading (Canonical Tangled Rope) 
   ========================================================================== */ 

/** 
 * CANONICAL TANGLED ROPE EXAMPLE 
 * 
 * Coordination function (ROPE properties): 
 * - Creates price signal for emissions reduction 
 * - Enables market-based climate action 
 * - Coordinates international climate policy 
 * 
 * Extractive function (NOOSE properties): 
 * - Financial intermediation extracts from real economy 
 * - Offset fraud and greenwashing enable extraction 
 * - Compliance costs hit small businesses harder 
 * 
 * Why tangled_rope classification matters: 
 * - "Just remove it" → loses coordination (price signal) 
 * - "Just maintain it" → perpetuates extraction 
 * - Reform path: Preserve price mechanism, reduce financial extraction 
 * 
 * Empirical metrics from corpus analysis: 
 * - Extraction: 0.55 (mid-range) 
 * - Suppression: 0.60 (requires enforcement) 
 * - Has both beneficiaries AND victims 
 */ 

% Core Constraint Declaration 
narrative_ontology:interval(carbon_market_era, 2000, 2026). 
narrative_ontology:constraint_claim(carbon_credit_trading_canonical, tangled_rope). 

% Base Metrics 
domain_priors:base_extractiveness(carbon_credit_trading_canonical, 0.55). 
domain_priors:suppression_score(carbon_credit_trading_canonical, 0.60). 
domain_priors:requires_active_enforcement(carbon_credit_trading_canonical). 

% Metrics for Executive Summary 
narrative_ontology:constraint_metric(carbon_credit_trading_canonical, extractiveness, 0.55). 
narrative_ontology:constraint_metric(carbon_credit_trading_canonical, suppression_requirement, 0.60). 

% Beneficiaries & Victims (demonstrates hybridity) 
constraint_beneficiary(carbon_credit_trading_canonical, multinational_corporations). 
constraint_beneficiary(carbon_credit_trading_canonical, financial_sector). 
constraint_beneficiary(carbon_credit_trading_canonical, climate_policy_coordination). 
constraint_victim(carbon_credit_trading_canonical, small_businesses). 
constraint_victim(carbon_credit_trading_canonical, offset_sellers). 
constraint_victim(carbon_credit_trading_canonical, greenwashing_targets). 

% Index-dependent classifications 
constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    rope, 
    context( 
        agent_power(institutional), 
        time_horizon(generational), 
        exit_options(mobile), 
        spatial_scope(global) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    tangled_rope, 
    context( 
        agent_power(analytical), 
        time_horizon(historical), 
        exit_options(analytical), 
        spatial_scope(global) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    snare, 
    context( 
        agent_power(individual_moderate), 
        time_horizon(biographical), 
        exit_options(constrained), 
        spatial_scope(national) 
    ) 
) :- !. 

constraint_indexing:constraint_classification( 
    carbon_credit_trading_canonical, 
    snare, 
    context( 
        agent_power(powerless), 
        time_horizon(biographical), 
        exit_options(trapped), 
        spatial_scope(local) 
    ) 
) :- !. 


/* ========================================================================== 
   EXAMPLE 2: Academic Tenure System (From Existing Corpus) 
   ========================================================================== */ 

/** 
 * ACADEMIC TENURE AS TANGLED ROPE 
 * 
 * Coordination function (ROPE properties): 
 * - Protects academic freedom 
 * - Enables long-term research projects 
 * - Coordinates faculty stability 
 * 
 * Extractive function (NOOSE properties): 
 * - Extracts hyper-productivity from pre-tenure faculty 
 * - Excludes adjuncts from security 
 * - Concentrates benefits in senior faculty 
 * 
 * Reclassified from corpus analysis: 
 * - Previously: rope (claimed type) 
 * - Empirical: extraction 0.75, suppression 0.60 
 * - New classification: tangled_rope 
 */ 

% Note: academic_tenure_system.pl already exists in testsets/ 
% This would be updated to claim tangled_rope instead of rope 

/* ========================================================================== 
   EXAMPLE 3: Platform Network Effects (Generic Template) 
   ========================================================================== */ 

/** 
 * PLATFORM MONOPOLIES AS TANGLED ROPE 
 * 
 * Coordination function (ROPE properties): 
 * - Coordinates user connections (network effects) 
 * - Enables communication and commerce 
 * - Provides standardized interface 
 * 
 * Extractive function (NOOSE properties): 
 * - Monopoly power extracts through pricing 
 * - Data harvesting and surveillance 
 * - Lock-in effects trap users 
 * 
 * Reform strategy: 
 * - Preserve network coordination (interoperability) 
 * - Cut extraction (data portability, competition) 
 */ 

narrative_ontology:constraint_claim(platform_network_monopoly_canonical, tangled_rope). 

domain_priors:base_extractiveness(platform_network_monopoly_canonical, 0.65). 
domain_priors:suppression_score(platform_network_monopoly_canonical, 0.55). 
domain_priors:requires_active_enforcement(platform_network_monopoly_canonical). 

narrative_ontology:constraint_metric(platform_network_monopoly_canonical, extractiveness, 0.65). 
narrative_ontology:constraint_metric(platform_network_monopoly_canonical, suppression_requirement, 0.55). 

constraint_beneficiary(platform_network_monopoly_canonical, platform_owners). 
constraint_beneficiary(platform_network_monopoly_canonical, advertisers). 
constraint_beneficiary(platform_network_monopoly_canonical, network_coordination). 
constraint_victim(platform_network_monopoly_canonical, users_privacy). 
constraint_victim(platform_network_monopoly_canonical, small_competitors). 
constraint_victim(platform_network_monopoly_canonical, innovation_potential). 

/* ========================================================================== 
   USAGE NOTES 
   ========================================================================== */ 

/** 
 * HOW TO IDENTIFY TANGLED ROPE CONSTRAINTS 
 * 
 * 1. Check metrics: 
 *    - base_extractiveness: 0.40-0.90 
 *    - suppression_score: >= 0.50 
 *    - requires_active_enforcement: true 
 * 
 * 2. Verify hybridity: 
 *    - Has coordination function: multiple beneficiaries or network effects 
 *    - Has asymmetric extraction: has victims or concentrated benefits 
 * 
 * 3. Test strategic implications: 
 *    - "Just remove it" → loses something valuable (coordination) 
 *    - "Just maintain it" → perpetuates harm (extraction) 
 *    - Reform approach → surgical separation possible 
 * 
 * EXAMPLES FROM CORPUS REQUIRING RECLASSIFICATION: 
 * - academic_tenure_system.pl (claimed: rope, should be: tangled_rope) 
 * - carbon_credit_markets_2026.pl (claimed: rope, should be: tangled_rope) 
 * - regulatory_capture.pl (claimed: snare, should be: tangled_rope) 
 * - gig_economy_algorithmic_managment.pl (check metrics) 
 * 
 * GREP SEARCH TO FIND CANDIDATES: 
 * Find files with extraction 0.40-0.90 AND suppression > 0.50: 
 * 
 * grep -l "base_extractiveness.*0\.[4-9]" testsets/*.pl | \ 
 * xargs grep -l "suppression_score.*0\.[5-9]" 
 */
*/:- module(test_harness, [
    load_scenario/1,
    run_all_tests/0,    % New: One-button alias
    run_all_tests/1,
    run_all_tests/2,
    quick_check/1
]).

:- use_module(narrative_ontology).
:- use_module(config).
:- use_module(coercion_projection).
:- use_module(data_repair).
:- use_module(data_verification).
:- use_module(pattern_analysis).
:- use_module(intent_engine).
:- use_module(constraint_bridge).
:- use_module(constraint_indexing).
:- use_module(drl_core).
:- use_module(drl_lifecycle).
:- use_module(report_generator).

% Run all registered test cases from validation_suite, or fall back to single ID
run_all_tests :-
    (   current_predicate(validation_suite:test_case/4)
    ->  findall(ID, validation_suite:test_case(_, ID, _, _), IDs),
        sort(IDs, UniqueIDs),
        length(UniqueIDs, N),
        format('~n>>> Running ~w registered test intervals~n', [N]),
        forall(member(IntervalID, UniqueIDs),
               (   catch(run_all_tests(IntervalID), E,
                         format('[ERROR] ~w failed: ~w~n', [IntervalID, E]))
               ))
    ;   format('~n>>> No validation_suite loaded, running default interval~n'),
        run_all_tests('tax_code_section_469')
    ).

run_all_tests(IntervalID) :-
    constraint_indexing:default_context(Ctx),
    run_all_tests(IntervalID, Ctx).

run_all_tests(IntervalID, Context) :-
    format('~n>>> INITIATING DR-AUDIT SUITE: ~w~n', [IntervalID]),
    
    % Step 1: Data Repair
    data_repair:repair_interval(IntervalID),

    % Step 2: Verification Gate
    (   data_verification:verify_all,
        data_verification:check_paired_measurements
    ->  format('[OK] Verification passed.~n')
    ;   format('[FAIL] Verification failed for ~w.~n', [IntervalID]), fail),

    % Step 3: Indexical Audit
    forall(narrative_ontology:constraint_claim(C, _),
           constraint_indexing:compare_perspectives(C, Context)),

    % Step 4: Intent and Reporting
    intent_engine:analyze_intent(IntervalID),
    constraint_bridge:dr_diagnostic_report(IntervalID),

    % Step 5: Lifecycle Drift Analysis
    format('~n--- LIFECYCLE DRIFT ANALYSIS ---~n'),
    drl_lifecycle:generate_drift_report,

    % Step 6: System Insights
    format('~n--- SYSTEM INSIGHTS ---~n'),
    narrative_ontology:count_unresolved_omegas(OmegaCount),
    format('  Omegas Identified: ~w~n', [OmegaCount]),
    report_generator:generate_full_report(IntervalID).

% Ensure quick_check uses the predicates from the authoritative module
quick_check(IntervalID) :-
    format('--- Diagnostic: ~w ---~n', [IntervalID]),
    (   drl_core:base_extractiveness(Name, E), E > 0.8
    ->  format('CRITICAL EXTRACTIVENESS: ~w (~2f)~n', [Name, E])
    ;   format('No critical extractiveness detected.~n')).

%% load_scenario(+Path)
load_scenario(Path) :-
    exists_file(Path),
    consult(Path),
    format('~n[SCENARIO] Successfully loaded: ~w~n', [Path]).
load_scenario(Path) :-
    \+ exists_file(Path), 
    format('~n[ERROR] Scenario file not found: ~w~n', [Path]),
    fail.
:- module(uke_dr_bridge, [
    uke_status/3
]).

:- use_module(drl_core).
:- use_module(narrative_ontology).
:- use_module(constraint_bridge).
:- use_module(config).

% Map Feasibility + DRL Type to UKE Status
uke_status(RecID, Status, Reasons) :-
    narrative_ontology:recommendation(RecID, _), % CRITICAL: Verify RecID is actually a recommendation
    narrative_ontology:affects_constraint(RecID, C),
    drl_core:dr_type(C, Type),
    constraint_bridge:recommendation_feasibility(RecID, Feas, Vetoes),
    determine_status(C, Type, Feas, Vetoes, Status, Reasons). % Passed C here

% --- Status Routing ---

determine_status(_, mountain, _, _, fantasy, 
    ['Recommendation attempts to modify a natural constraint (Mountain).']).

% Fixed: Uses C to check load-bearing status
determine_status(C, snare, _, _, blocked, 
    ['CRITICAL: Load-bearing Snare removal attempted without Scaffold.']) :-
    is_load_bearing(C),
    \+ narrative_ontology:entity(_, scaffold).

determine_status(_, Type, viable, [], viable, 
    ['No structural or political vetoes detected.']) :-
    member(Type, [rope, snare, piton]).

determine_status(_, tangled_rope, _, _, aspirational, 
    ['System is Tangled: Extraction is rising. Coordination remains, but Reform is required.']).

% Fallback for unclassified constraints
determine_status(_, unknown, _, _, investigate, 
    ['Structural audit incomplete: Constraint metrics do not match known types.']).

determine_status(_, _, blocked_by_veto, Vetoes, blocked, [Msg]) :-
    format(string(Msg), 'Vetoed by: ~w', [Vetoes]).

% Helper
is_load_bearing(C) :- 
    drl_core:dr_type(C, snare),
    config:param(snare_load_bearing_threshold, T),
    narrative_ontology:constraint_metric(C, extractiveness, X), 
    X > T.
:- module(utils, [
    safe_get_metric/4,
    safe_get_metric/5,
    safe_get_category/3,
    safe_call/2,
    safe_call/3,
    log/3,
    set_log_level/1,
    get_log_level/1,
    require_metric/3,
    validate_metric_value/2
]).

:- use_module(narrative_ontology).
:- use_module(domain_priors).
:- use_module(config).

/* ============================================================================
   DEFENSIVE PROGRAMMING UTILITIES
   ============================================================================

   This module provides safe wrappers for common operations that might fail,
   enabling defensive programming practices across the codebase.

   Key features:
   - Safe metric retrieval with defaults
   - Exception handling wrappers
   - Configurable logging
   - Validation helpers

   ============================================================================ */

:- dynamic log_level/1.
log_level(info).  % Default log level: debug, info, warn, error

/* ============================================================================
   1. SAFE METRIC RETRIEVAL
   ============================================================================ */

%% safe_get_metric(+Constraint, +Metric, -Value, +Default)
%  Retrieves a metric value, using default if missing.
%  Does NOT log warnings (silent fallback).
safe_get_metric(Constraint, Metric, Value, Default) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, V)
    -> Value = V
    ;  Value = Default).

%% safe_get_metric(+Constraint, +Metric, -Value, +Default, +LogWarning)
%  Retrieves a metric value, using default if missing.
%  Logs warning if LogWarning = true and metric is missing.
safe_get_metric(Constraint, Metric, Value, Default, LogWarning) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, V)
    -> Value = V
    ;  (Value = Default,
        (LogWarning = true
        -> log(warn, 'Missing metric ~w for ~w, using default ~w',
               [Metric, Constraint, Default])
        ;  true))).

%% safe_get_category(+Constraint, -Category, +Default)
%  Retrieves domain category, using default if missing.
safe_get_category(Constraint, Category, Default) :-
    (domain_priors:category_of(Constraint, Cat)
    -> (Cat \= unknown, Cat \= unknown_novel
       -> Category = Cat
       ;  (Category = Default,
           log(warn, 'Unknown category for ~w, using default ~w',
               [Constraint, Default])))
    ;  (Category = Default,
        log(warn, 'No category for ~w, using default ~w',
            [Constraint, Default]))).

%% require_metric(+Constraint, +Metric, -Value)
%  Retrieves a metric value, FAILING if missing (strict mode).
%  Use this when a metric is truly required for correctness.
require_metric(Constraint, Metric, Value) :-
    (narrative_ontology:constraint_metric(Constraint, Metric, Value)
    -> true
    ;  (log(error, 'REQUIRED metric ~w missing for ~w',
            [Metric, Constraint]),
        fail)).

%% validate_metric_value(+Metric, +Value)
%  Validates that a metric value is in acceptable range.
validate_metric_value(_Metric, Value) :-
    number(Value),
    Value >= 0.0,
    Value =< 1.0.

/* ============================================================================
   2. SAFE CALL WRAPPERS
   ============================================================================ */

%% safe_call(+Goal, +ErrorMessage)
%  Executes Goal with exception handling.
%  Logs error and fails gracefully if exception occurs.
safe_call(Goal, ErrorMessage) :-
    catch(Goal,
          Error,
          (log(error, '~w: ~w', [ErrorMessage, Error]),
           fail)).

%% safe_call(+Goal, +ErrorMessage, +Default)
%  Executes Goal with exception handling.
%  Returns Default if Goal fails or throws exception.
safe_call(Goal, _ErrorMessage, _Default) :-
    catch(Goal, _, fail),
    !.
safe_call(_Goal, ErrorMessage, Default) :-
    log(warn, '~w, using default: ~w', [ErrorMessage, Default]),
    Default = Default.

/* ============================================================================
   3. LOGGING INFRASTRUCTURE
   ============================================================================ */

%% set_log_level(+Level)
%  Sets the logging level.
%  Levels: debug < info < warn < error
set_log_level(Level) :-
    member(Level, [debug, info, warn, error]),
    retractall(log_level(_)),
    assertz(log_level(Level)).

%% get_log_level(-Level)
%  Gets the current logging level.
get_log_level(Level) :-
    log_level(Level).

%% log(+Level, +Format, +Args)
%  Logs a message at the specified level.
%  Only logs if current log level permits.
log(Level, Format, Args) :-
    log_level(CurrentLevel),
    level_priority(Level, LP),
    level_priority(CurrentLevel, CP),
    (LP >= CP
    -> format_log_message(Level, Format, Args)
    ;  true).

%% level_priority(+Level, -Priority)
%  Maps log levels to numeric priorities.
level_priority(debug, 0).
level_priority(info, 1).
level_priority(warn, 2).
level_priority(error, 3).

%% format_log_message(+Level, +Format, +Args)
%  Formats and displays a log message.
format_log_message(Level, Format, Args) :-
    level_prefix(Level, Prefix),
    format('[~w] ', [Prefix]),
    format(Format, Args),
    nl.

%% level_prefix(+Level, -Prefix)
%  Maps log levels to display prefixes.
level_prefix(debug, 'DEBUG').
level_prefix(info, 'INFO').
level_prefix(warn, 'WARN').
level_prefix(error, 'ERROR').

/* ============================================================================
   4. ENHANCED METRIC RETRIEVAL WITH VALIDATION
   ============================================================================ */

%% safe_get_extractiveness(+Constraint, -Extractiveness)
%  Safe retrieval of base extractiveness with validation.
safe_get_extractiveness(Constraint, Extractiveness) :-
    safe_get_extractiveness(Constraint, Extractiveness, 0.0, true).

%% safe_get_extractiveness(+Constraint, -Extractiveness, +Default, +Warn)
safe_get_extractiveness(Constraint, Extractiveness, Default, Warn) :-
    (domain_priors:base_extractiveness(Constraint, E)
    -> (validate_metric_value(extractiveness, E)
       -> Extractiveness = E
       ;  (log(error, 'Invalid extractiveness ~w for ~w (must be 0.0-1.0)',
                [E, Constraint]),
           Extractiveness = Default))
    ;  (Extractiveness = Default,
        (Warn = true
        -> log(warn, 'Missing extractiveness for ~w, using default ~w',
               [Constraint, Default])
        ;  true))).

%% safe_get_suppression(+Constraint, -Suppression)
%  Safe retrieval of suppression requirement with validation.
safe_get_suppression(Constraint, Suppression) :-
    safe_get_suppression(Constraint, Suppression, 0.0, true).

%% safe_get_suppression(+Constraint, -Suppression, +Default, +Warn)
safe_get_suppression(Constraint, Suppression, Default, Warn) :-
    safe_get_metric(Constraint, suppression_requirement, Suppression, Default, Warn).

/* ============================================================================
   5. BATCH OPERATIONS WITH SAFE RETRIEVAL
   ============================================================================ */

%% safe_get_all_metrics(+Constraint, -Metrics)
%  Retrieves all standard metrics for a constraint.
%  Returns metrics(Extr, Supp, Resist, Category) structure.
safe_get_all_metrics(Constraint, metrics(Extr, Supp, Resist, Category)) :-
    safe_get_extractiveness(Constraint, Extr, 0.0, false),
    safe_get_suppression(Constraint, Supp, 0.0, false),
    safe_get_metric(Constraint, resistance_to_change, Resist, 0.0, false),
    safe_get_category(Constraint, Category, unknown).

%% safe_get_profile_components(+Constraint, -Components)
%  Safely retrieves all components needed for structural signature.
safe_get_profile_components(Constraint, components(Accum, Supp, Resist, BenefDelta, AltPresent)) :-
    safe_get_metric(Constraint, accumulation_speed, Accum, 0.0, false),
    safe_get_metric(Constraint, suppression_requirement, Supp, 0.0, false),
    safe_get_metric(Constraint, resistance_to_change, Resist, 0.0, false),

    % Calculate beneficiary delta safely
    (findall(B, narrative_ontology:veto_actor(B), Beneficiaries)
    -> length(Beneficiaries, BenefDelta)
    ;  BenefDelta = 0),

    % Check for alternatives safely
    (narrative_ontology:intent_viable_alternative(_, _, _)
    -> AltPresent = present
    ;  AltPresent = absent).

/* ============================================================================
   6. DEFENSIVE CONFIG RETRIEVAL
   ============================================================================ */

%% safe_get_config(+ParamName, -Value, +Default)
%  Safely retrieves configuration parameter.
safe_get_config(ParamName, Value, Default) :-
    (config:param(ParamName, V)
    -> Value = V
    ;  (Value = Default,
        log(warn, 'Missing config parameter ~w, using default ~w',
            [ParamName, Default]))).

%% require_config(+ParamName, -Value)
%  Retrieves config parameter, failing if missing (strict mode).
require_config(ParamName, Value) :-
    (config:param(ParamName, Value)
    -> true
    ;  (log(error, 'REQUIRED config parameter ~w is missing', [ParamName]),
        fail)).

/* ============================================================================
   7. SAFE LIST OPERATIONS
   ============================================================================ */

%% safe_member(+Element, +List, +Default)
%  Checks membership, returning Default if List is not a list.
safe_member(Element, List, Default) :-
    (is_list(List)
    -> member(Element, List)
    ;  (log(warn, 'Expected list but got ~w, using default ~w',
            [List, Default]),
        Element = Default)).

%% safe_length(+List, -Length)
%  Gets list length, returning 0 if not a list.
safe_length(List, Length) :-
    (is_list(List)
    -> length(List, Length)
    ;  (log(warn, 'Expected list but got ~w, returning length 0', [List]),
        Length = 0)).

/* ============================================================================
   8. CONSTRAINT EXISTENCE CHECKS
   ============================================================================ */

%% constraint_exists(+Constraint)
%  Checks if a constraint is defined in the knowledge base.
constraint_exists(Constraint) :-
    narrative_ontology:constraint_claim(Constraint, _).

%% require_constraint(+Constraint)
%  Requires that a constraint exists, failing with error if not.
require_constraint(Constraint) :-
    (constraint_exists(Constraint)
    -> true
    ;  (log(error, 'Constraint ~w does not exist in knowledge base', [Constraint]),
        fail)).

/* ============================================================================
   9. NUMERIC SAFETY HELPERS
   ============================================================================ */

%% safe_divide(+Numerator, +Denominator, -Result, +Default)
%  Safe division with zero-denominator handling.
safe_divide(Num, Denom, Result, Default) :-
    (Denom =\= 0
    -> Result is Num / Denom
    ;  (Result = Default,
        log(warn, 'Division by zero: ~w / ~w, using default ~w',
            [Num, Denom, Default]))).

%% safe_sqrt(+Value, -Result, +Default)
%  Safe square root with negative value handling.
safe_sqrt(Value, Result, Default) :-
    (Value >= 0
    -> Result is sqrt(Value)
    ;  (Result = Default,
        log(warn, 'Square root of negative value ~w, using default ~w',
            [Value, Default]))).

%% clamp(+Value, +Min, +Max, -ClampedValue)
%  Clamps a value to [Min, Max] range.
clamp(Value, Min, Max, ClampedValue) :-
    (Value < Min
    -> (ClampedValue = Min,
        log(debug, 'Value ~w clamped to minimum ~w', [Value, Min]))
    ; Value > Max
    -> (ClampedValue = Max,
        log(debug, 'Value ~w clamped to maximum ~w', [Value, Max]))
    ;  ClampedValue = Value).

/* ============================================================================
   10. DEBUGGING HELPERS
   ============================================================================ */

%% debug_constraint(+Constraint)
%  Prints all available information about a constraint for debugging.
debug_constraint(Constraint) :-
    format('~n=== DEBUG INFO: ~w ===~n', [Constraint]),

    % Check existence
    (constraint_exists(Constraint)
    -> format('  Status: EXISTS~n')
    ;  format('  Status: NOT FOUND~n')),

    % Show claimed type
    (narrative_ontology:constraint_claim(Constraint, Type)
    -> format('  Claimed Type: ~w~n', [Type])
    ;  format('  Claimed Type: NONE~n')),

    % Show metrics
    format('  Metrics:~n'),
    (narrative_ontology:constraint_metric(Constraint, extractiveness, E)
    -> format('    extractiveness: ~2f~n', [E])
    ;  format('    extractiveness: MISSING~n')),

    (narrative_ontology:constraint_metric(Constraint, suppression_requirement, S)
    -> format('    suppression_requirement: ~2f~n', [S])
    ;  format('    suppression_requirement: MISSING~n')),

    (narrative_ontology:constraint_metric(Constraint, resistance_to_change, R)
    -> format('    resistance_to_change: ~2f~n', [R])
    ;  format('    resistance_to_change: MISSING~n')),

    % Show category
    (domain_priors:category_of(Constraint, Cat)
    -> format('  Category: ~w~n', [Cat])
    ;  format('  Category: MISSING~n')),

    format('=================~n~n').

%% trace_metric_retrieval(+Constraint, +Metric)
%  Traces all attempts to retrieve a metric for debugging.
trace_metric_retrieval(Constraint, Metric) :-
    format('~n=== TRACING: ~w.~w ===~n', [Constraint, Metric]),

    (narrative_ontology:constraint_metric(Constraint, Metric, Value)
    -> format('  ✓ Found: ~w~n', [Value])
    ;  format('  ✗ Not found~n')),

    format('  All metrics for ~w:~n', [Constraint]),
    forall(narrative_ontology:constraint_metric(Constraint, M, V),
           format('    ~w: ~w~n', [M, V])),

    format('=================~n~n').
:- module(validation_suite, [run_dynamic_suite/0]).
:- use_module(library(prolog_stack)).
:- use_module(scenario_manager).
:- use_module(data_validation).
:- use_module(report_generator).

:- chdir('../prolog').

:- dynamic test_passed/1, test_failed/3, test_case/4.

% --- Test Case Definitions ---
test_case('testsets/26usc469.pl', '26usc469', '26USC469', 1).
test_case('testsets/26usc469_real_estate_exemption.pl', '26usc469_real_estate_exemption', '26USC469_REAL_ESTATE_EXEMPTION', 2).
test_case('testsets/abstraction_boundary_overrun.pl', 'abstraction_boundary_overrun', 'ABSTRACTION_BOUNDARY_OVERRUN', 3).
test_case('testsets/abstraction_leakage.pl', 'abstraction_leakage', 'ABSTRACTION_LEAKAGE', 4).
test_case('testsets/academic_peer_review_gatekeeping.pl', 'academic_peer_review_gatekeeping', 'ACADEMIC_PEER_REVIEW_GATEKEEPING', 5).
test_case('testsets/academic_tenure_system.pl', 'academic_tenure_system', 'ACADEMIC_TENURE_SYSTEM', 6).
test_case('testsets/ad_fus_coordination.pl', 'ad_fus_coordination', 'AD_FUS_COORDINATION', 7).
test_case('testsets/ad_synaptic_deficit.pl', 'ad_synaptic_deficit', 'AD_SYNAPTIC_DEFICIT', 8).
test_case('testsets/adaptive_lag_trap.pl', 'adaptive_lag_trap', 'ADAPTIVE_LAG_TRAP', 9).
test_case('testsets/adversarial_surface_inflation.pl', 'adversarial_surface_inflation', 'ADVERSARIAL_SURFACE_INFLATION', 10).
test_case('testsets/adversarial_truth_decay.pl', 'adversarial_truth_decay', 'ADVERSARIAL_TRUTH_DECAY', 11).
test_case('testsets/adverse_possession.pl', 'adverse_possession_interval', 'ADVERSE_POSSESSION', 12).
test_case('testsets/advice_as_dangerous_gift.pl', 'advice_as_dangerous_gift', 'ADVICE_AS_DANGEROUS_GIFT', 13).
test_case('testsets/agency_atrophy.pl', 'agency_atrophy', 'AGENCY_ATROPHY', 14).
test_case('testsets/aging_well_assessment.pl', 'aging_longevity_tests', 'AGING_WELL_ASSESSMENT', 15).
test_case('testsets/ai_auditability_gap.pl', 'ai_auditability_gap', 'AI_AUDITABILITY_GAP', 16).
test_case('testsets/ai_cognitive_diversity_arbitrage.pl', 'ai_cognitive_diversity_arbitrage', 'AI_COGNITIVE_DIVERSITY_ARBITRAGE', 17).
test_case('testsets/ai_driven_surveillance_sensor_layer.pl', 'ai_driven_surveillance_sensor_layer', 'AI_DRIVEN_SURVEILLANCE_SENSOR_LAYER', 18).
test_case('testsets/ai_edu_decentralization.pl', 'ai_edu_decentralization', 'AI_EDU_DECENTRALIZATION', 19).
test_case('testsets/ai_evaluators_matching.pl', 'ai_evaluators_matching', 'AI_EVALUATORS_MATCHING', 20).
test_case('testsets/ai_professional_displacement.pl', 'ai_professional_displacement', 'AI_PROFESSIONAL_DISPLACEMENT', 21).
test_case('testsets/ai_task_horizon_reliability.pl', 'ai_task_horizon_reliability', 'AI_TASK_HORIZON_RELIABILITY', 22).
test_case('testsets/algorithmic_bias.pl', 'algorithmic_bias', 'ALGORITHMIC_BIAS', 23).
test_case('testsets/algorithmic_epistemic_capture.pl', 'algorithmic_epistemic_capture', 'ALGORITHMIC_EPISTEMIC_CAPTURE', 24).
test_case('testsets/alignment_tax_tradeoff.pl', 'alignment_tax_tradeoff', 'ALIGNMENT_TAX_TRADEOFF', 25).
test_case('testsets/alternative_sovereignty_scaffold.pl', 'alternative_sovereignty_scaffold', 'ALTERNATIVE_SOVEREIGNTY_SCAFFOLD', 26).
test_case('testsets/amish_technological_renunciation.pl', 'amish_technological_renunciation', 'AMISH_TECHNOLOGICAL_RENUNCIATION', 27).
test_case('testsets/ancestral_pueblo_hydrology.pl', 'ancestral_pueblo_hydrology', 'ANCESTRAL_PUEBLO_HYDROLOGY', 28).
test_case('testsets/ancient_grudge_verona.pl', 'ancient_grudge_verona', 'ANCIENT_GRUDGE_VERONA', 29).
test_case('testsets/anticipatory_capacity_failure.pl', 'anticipatory_capacity_failure', 'ANTICIPATORY_CAPACITY_FAILURE', 30).
test_case('testsets/antifragility.pl', 'antifragility', 'ANTIFRAGILITY', 31).
test_case('testsets/apartheid_nuclear_program.pl', 'apartheid_nuclear_program', 'APARTHEID_NUCLEAR_PROGRAM', 32).
test_case('testsets/arctic_geopolitical_flashpoint.pl', 'arctic_geopolitical_flashpoint', 'ARCTIC_GEOPOLITICAL_FLASHPOINT', 33).
test_case('testsets/arrows_impossibility_theorem.pl', 'arrows_era', 'ARROWS_IMPOSSIBILITY_THEOREM', 34).
test_case('testsets/artificial_scarcity_scaffold.pl', 'artificial_scarcity_scaffold', 'ARTIFICIAL_SCARCITY_SCAFFOLD', 35).
test_case('testsets/asce_7_22_seismic_design.pl', 'asce_cycle_22', 'ASCE_7_22_SEISMIC_DESIGN', 36).
test_case('testsets/asshole_filter_2015.pl', 'asshole_filter_2015', 'ASSHOLE_FILTER_2015', 37).
test_case('testsets/astm_d638_tensile_testing.pl', 'industrial_testing_regime', 'ASTM_D638_TENSILE_TESTING', 38).
test_case('testsets/asymmetric_burden_distribution.pl', 'asymmetric_burden_distribution', 'ASYMMETRIC_BURDEN_DISTRIBUTION', 39).
test_case('testsets/asymmetric_computational_difficulty.pl', 'asymmetric_computational_difficulty', 'ASYMMETRIC_COMPUTATIONAL_DIFFICULTY', 40).
test_case('testsets/atrophied_optimization_piton.pl', 'atrophied_optimization_piton', 'ATROPHIED_OPTIMIZATION_PITON', 41).
test_case('testsets/attention_as_bottleneck_resource.pl', 'attention_as_bottleneck_resource', 'ATTENTION_AS_BOTTLENECK_RESOURCE', 42).
test_case('testsets/attention_market_cannibalization.pl', 'attention_market_cannibalization', 'ATTENTION_MARKET_CANNIBALIZATION', 43).
test_case('testsets/authoritarian_power_paradox.pl', 'authoritarian_power_paradox', 'AUTHORITARIAN_POWER_PARADOX', 44).
test_case('testsets/automatic_enrollment_defaults.pl', 'automatic_enrollment_defaults', 'AUTOMATIC_ENROLLMENT_DEFAULTS', 45).
test_case('testsets/autonomous_toolchain_sprawl.pl', 'autonomous_toolchain_sprawl', 'AUTONOMOUS_TOOLCHAIN_SPRAWL', 46).
test_case('testsets/availability_heuristic.pl', 'availability_heuristic', 'AVAILABILITY_HEURISTIC', 47).
test_case('testsets/awareness_without_leverage.pl', 'awareness_without_leverage', 'AWARENESS_WITHOUT_LEVERAGE', 48).
test_case('testsets/axiom_of_choice_determinacy.pl', 'ac_era', 'AXIOM_OF_CHOICE_DETERMINACY', 49).
test_case('testsets/banach_fixed_point.pl', 'banach_era', 'BANACH_FIXED_POINT', 50).
test_case('testsets/banach_tarski_paradox.pl', 'banach_tarski_era', 'BANACH_TARSKI_PARADOX', 51).
test_case('testsets/bangladesh_july_national_charter.pl', 'bangladesh_july_national_charter', 'BANGLADESH_JULY_NATIONAL_CHARTER', 52).
test_case('testsets/bap_of_pigs_operational_silo.pl', 'operation_zapata_timeline', 'BAP_OF_PIGS_OPERATIONAL_SILO', 53).
test_case('testsets/base_pair_complementarity.pl', 'dna_structure_discovery', 'BASE_PAIR_COMPLEMENTARITY', 54).
test_case('testsets/basel_problem_convergence.pl', 'basel_era', 'BASEL_PROBLEM_CONVERGENCE', 55).
test_case('testsets/bedouin_sedentary_transition.pl', 'bedouin_sedentary_transition', 'BEDOUIN_SEDENTARY_TRANSITION', 56).
test_case('testsets/beief_argument_conclusion.pl', 'belief_argument_conclusion_interval', 'BEIEF_ARGUMENT_CONCLUSION', 57).
test_case('testsets/berkshire_compounding_culture.pl', 'berkshire_compounding_culture', 'BERKSHIRE_COMPOUNDING_CULTURE', 58).
test_case('testsets/big_data_astrophysics_arbitrage.pl', 'big_data_astrophysics_arbitrage', 'BIG_DATA_ASTROPHYSICS_ARBITRAGE', 59).
test_case('testsets/biological_curiosity.pl', 'biological_curiosity', 'BIOLOGICAL_CURIOSITY', 60).
test_case('testsets/bip_narrative_illusion.pl', 'bip_narrative_illusion_interval', 'BIP_NARRATIVE_ILLUSION', 61).
test_case('testsets/birthday_paradox_collison.pl', 'birthday_era', 'BIRTHDAY_PARADOX_COLLISON', 62).
test_case('testsets/blackstone_carried_interest_taxation.pl', 'blackstone_ipo_restructuring', 'BLACKSTONE_CARRIED_INTEREST_TAXATION', 63).
test_case('testsets/blackstone_conflicts_of_interest.pl', 'blackstone_conflict_era', 'BLACKSTONE_CONFLICTS_OF_INTEREST', 64).
test_case('testsets/blackstone_smd_control.pl', 'blackstone_smd_control', 'BLACKSTONE_SMD_CONTROL', 65).
test_case('testsets/blackstone_tax_receiveable_agreement.pl', 'blackstone_tra_life', 'BLACKSTONE_TAX_RECEIVEABLE_AGREEMENT', 66).
test_case('testsets/boundary_dissolution_risk.pl', 'boundary_dissolution_risk', 'BOUNDARY_DISSOLUTION_RISK', 67).
test_case('testsets/brain_network_paradigm_2026.pl', 'brain_network_paradigm_2026', 'BRAIN_NETWORK_PARADIGM_2026', 68).
test_case('testsets/brazil_2026_general_elections.pl', 'brazil_2026_general_elections', 'BRAZIL_2026_GENERAL_ELECTIONS', 69).
test_case('testsets/broke_vs_poor_grocery_math.pl', 'broke_vs_poor_grocery_math', 'BROKE_VS_POOR_GROCERY_MATH', 70).
test_case('testsets/brouwer_fixed_point.pl', 'brouwer_era', 'BROUWER_FIXED_POINT', 71).
test_case('testsets/buffons_needle_pi_estimation.pl', 'buffon_era', 'BUFFONS_NEEDLE_PI_ESTIMATION', 72).
test_case('testsets/burali_forte_paradox.pl', 'burali_forti_interval', 'BURALI_FORTE_PARADOX', 73).
test_case('testsets/burden_of_proof_engineering_safety.pl', 'challenger_launch_decision', 'BURDEN_OF_PROOF_ENGINEERING_SAFETY', 74).
test_case('testsets/burden_of_proof_legal_criminal.pl', 'criminal_trial_sequence', 'BURDEN_OF_PROOF_LEGAL_CRIMINAL', 75).
test_case('testsets/burden_of_proof_scientific_empirical.pl', 'scientific_revolution_current', 'BURDEN_OF_PROOF_SCIENTIFIC_EMPIRICAL', 76).
test_case('testsets/bureaucratic_legibility_collapse.pl', 'bureaucratic_legibility_collapse', 'BUREAUCRATIC_LEGIBILITY_COLLAPSE', 77).
test_case('testsets/bureaucratic_self_preservation.pl', 'bureaucratic_self_preservation', 'BUREAUCRATIC_SELF_PRESERVATION', 78).
test_case('testsets/bushman_money_magic.pl', 'bushman_money_magic_interval', 'BUSHMAN_MONEY_MAGIC', 79).
test_case('testsets/busy_beaver_noncomputability.pl', 'busy_beaver_era', 'BUSY_BEAVER_NONCOMPUTABILITY', 80).
test_case('testsets/c_physical_blue_wavelength.pl', 'c_physical_blue_wavelength', 'C_PHYSICAL_BLUE_WAVELENGTH', 81).
test_case('testsets/cantor_set_topology.pl', 'cantor_set_topology', 'CANTOR_SET_TOPOLOGY', 82).
test_case('testsets/cap_theorem.pl', 'cap_theorem_interval', 'CAP_THEOREM', 83).
test_case('testsets/capability_eval_overhang.pl', 'capability_eval_overhang', 'CAPABILITY_EVAL_OVERHANG', 84).
test_case('testsets/capital_misallocation_spiral.pl', 'capital_misallocation_spiral', 'CAPITAL_MISALLOCATION_SPIRAL', 85).
test_case('testsets/carbon_credit_markets_2026.pl', 'carbon_credit_markets_2026_int', 'CARBON_CREDIT_MARKETS_2026', 86).
test_case('testsets/carrying_capacity.pl', 'carrying_capacity_interval', 'CARRYING_CAPACITY', 87).
test_case('testsets/cascading_constraint_failure.pl', 'cascading_constraint_failure', 'CASCADING_CONSTRAINT_FAILURE', 88).
test_case('testsets/castration_longevity_choice.pl', 'castration_longevity_choice', 'CASTRATION_LONGEVITY_CHOICE', 89).
test_case('testsets/cbdc_implementation.pl', 'cbdc_deployment', 'CBDC_IMPLEMENTATION', 90).
test_case('testsets/central_limit_theorem_convergence.pl', 'clt_era', 'CENTRAL_LIMIT_THEOREM_CONVERGENCE', 91).
test_case('testsets/chaitins_omega_undecidability.pl', 'chaitin_era', 'CHAITINS_OMEGA_UNDECIDABILITY', 92).
test_case('testsets/challenger_o_ring_integrity.pl', 'challenger_o_ring_integrity', 'CHALLENGER_O_RING_INTEGRITY', 93).
test_case('testsets/china_critical_mineral_chokepoint.pl', 'china_critical_mineral_chokepoint', 'CHINA_CRITICAL_MINERAL_CHOKEPOINT', 94).
test_case('testsets/china_taiwan_reunification_mandate.pl', 'rejuvenation_centenary_cycle', 'CHINA_TAIWAN_REUNIFICATION_MANDATE', 95).
test_case('testsets/choice_architecture_design.pl', 'rope_design', 'CHOICE_ARCHITECTURE_DESIGN', 96).
test_case('testsets/church_turing_thesis.pl', 'church_turing_era', 'CHURCH_TURING_THESIS', 97).
test_case('testsets/cia_fbi_legal_wall.pl', 'pre_911_silo_regime', 'CIA_FBI_LEGAL_WALL', 98).
test_case('testsets/cinderella_midnight_deadline.pl', 'midnight_deadline_period', 'CINDERELLA_MIDNIGHT_DEADLINE', 99).
test_case('testsets/circadian_decoupling_arbitrage.pl', 'circadian_decoupling_arbitrage', 'CIRCADIAN_DECOUPLING_ARBITRAGE', 100).
test_case('testsets/citation_collapse_dynamics.pl', 'citation_collapse_dynamics', 'CITATION_COLLAPSE_DYNAMICS', 101).
test_case('testsets/civilizational_maintenance_debt.pl', 'civilizational_maintenance_debt', 'CIVILIZATIONAL_MAINTENANCE_DEBT', 102).
test_case('testsets/click_chemistry_paradigm_2026.pl', 'click_chemistry_paradigm_2026', 'CLICK_CHEMISTRY_PARADIGM_2026', 103).
test_case('testsets/climate_attribution_2026.pl', 'climate_attribution_2026', 'CLIMATE_ATTRIBUTION_2026', 104).
test_case('testsets/climate_target_one_point_five.pl', 'climate_target_one_point_five', 'CLIMATE_TARGET_ONE_POINT_FIVE', 105).
test_case('testsets/cloudflare_dual_class_asymmetry.pl', 'cloudflare_dual_class_asymmetry', 'CLOUDFLARE_DUAL_CLASS_ASYMMETRY', 106).
test_case('testsets/cobra_effect.pl', 'cobra_effect', 'COBRA_EFFECT', 107).
test_case('testsets/cognitive_diversity_arbitrage.pl', 'cognitive_diversity_arbitrage', 'COGNITIVE_DIVERSITY_ARBITRAGE', 108).
test_case('testsets/cognitive_energy_budget.pl', 'cognitive_energy_budget', 'COGNITIVE_ENERGY_BUDGET', 109).
test_case('testsets/cognitive_induction_gap.pl', 'cognitive_induction_gap', 'COGNITIVE_INDUCTION_GAP', 110).
test_case('testsets/cognitive_mimicry_arbitrage.pl', 'cognitive_mimicry_arbitrage', 'COGNITIVE_MIMICRY_ARBITRAGE', 111).
test_case('testsets/cognitive_surrender_to_system_3.pl', 'system_3_emergence', 'COGNITIVE_SURRENDER_TO_SYSTEM_3', 112).
test_case('testsets/coinbase_crypto_volatility.pl', 'coinbase_ipo_window', 'COINBASE_CRYPTO_VOLATILITY', 113).
test_case('testsets/coinbase_regulatory_uncertainty.pl', 'coinbase_regulatory_uncertainty', 'COINBASE_REGULATORY_UNCERTAINTY', 114).
test_case('testsets/collatz_conjecture_determinism.pl', 'collatz_era', 'COLLATZ_CONJECTURE_DETERMINISM', 115).
test_case('testsets/collective_action_deadlock.pl', 'collective_action_deadlock', 'COLLECTIVE_ACTION_DEADLOCK', 116).
test_case('testsets/college_admissions_market.pl', 'college_admissions_market', 'COLLEGE_ADMISSIONS_MARKET', 117).
test_case('testsets/colorado_sbe_decentralization_friction.pl', 'colorado_sbe_decentralization_friction', 'COLORADO_SBE_DECENTRALIZATION_FRICTION', 118).
test_case('testsets/columbia_2026_elections.pl', 'colombia_2026_presidential_election', 'COLUMBIA_2026_ELECTIONS', 119).
test_case('testsets/comitatus_bond.pl', 'comitatus_era', 'COMITATUS_BOND', 120).
test_case('testsets/complexity_debt.pl', 'complexity_debt', 'COMPLEXITY_DEBT', 121).
test_case('testsets/compounding_logic.pl', 'compounding_logic', 'COMPOUNDING_LOGIC', 122).
test_case('testsets/confirmation_bias.pl', 'confirmation_bias_interval', 'CONFIRMATION_BIAS', 123).
test_case('testsets/consensus_without_truth.pl', 'consensus_without_truth', 'CONSENSUS_WITHOUT_TRUTH', 124).
test_case('testsets/constitutional_consecration.pl', 'gettysburg_address_analysis', 'CONSTITUTIONAL_CONSECRATION', 125).
test_case('testsets/constitutional_supremacy.pl', 'constitutional_supremacy', 'CONSTITUTIONAL_SUPREMACY', 126).
test_case('testsets/constraint_interaction_explosion.pl', 'constraint_interaction_explosion', 'CONSTRAINT_INTERACTION_EXPLOSION', 127).
test_case('testsets/container_capacity_mismatch.pl', 'container_capacity_mismatch', 'CONTAINER_CAPACITY_MISMATCH', 128).
test_case('testsets/continuum_hypothesis_undecidability.pl', 'continuum_era', 'CONTINUUM_HYPOTHESIS_UNDECIDABILITY', 129).
test_case('testsets/conversational_dogmas_interuption.pl', 'conversational_dogmas_interruption', 'CONVERSATIONAL_DOGMAS_INTERUPTION', 130).
test_case('testsets/conways_game_of_life_dynamics.pl', 'conway_era', 'CONWAYS_GAME_OF_LIFE_DYNAMICS', 131).
test_case('testsets/coordination_attack_vulnerability.pl', 'coordination_attack_vulnerability', 'COORDINATION_ATTACK_VULNERABILITY', 132).
test_case('testsets/coordination_fatigue.pl', 'coordination_fatigue', 'COORDINATION_FATIGUE', 133).
test_case('testsets/coordination_threshold_failure.pl', 'coordination_threshold_failure', 'COORDINATION_THRESHOLD_FAILURE', 134).
test_case('testsets/copyleft_viral_licensing.pl', 'copyleft_viral_licensing', 'COPYLEFT_VIRAL_LICENSING', 135).
test_case('testsets/copyright_protection.pl', 'copyright_protection', 'COPYRIGHT_PROTECTION', 136).
test_case('testsets/cost_of_observation.pl', 'evolutionary_pressure_01', 'COST_OF_OBSERVATION', 137).
test_case('testsets/countable_infinity_cardinality.pl', 'countable_infinity_cardinality', 'COUNTABLE_INFINITY_CARDINALITY', 138).
test_case('testsets/couples_residency_match.pl', 'couples_residency_match', 'COUPLES_RESIDENCY_MATCH', 139).
test_case('testsets/cow_field_poop.pl', 'cow_field_poop', 'COW_FIELD_POOP', 140).
test_case('testsets/creative_commons_licensing.pl', 'creative_commons_licensing', 'CREATIVE_COMMONS_LICENSING', 141).
test_case('testsets/credibility_inflation.pl', 'credibility_inflation', 'CREDIBILITY_INFLATION', 142).
test_case('testsets/crisis_signal_saturation.pl', 'crisis_signal_saturation', 'CRISIS_SIGNAL_SATURATION', 143).
test_case('testsets/crispr_genomic_rewrite_2026.pl', 'crispr_genomic_rewrite_2026', 'CRISPR_GENOMIC_REWRITE_2026', 144).
test_case('testsets/critical_actor_overcentralization.pl', 'critical_actor_overcentralization', 'CRITICAL_ACTOR_OVERCENTRALIZATION', 145).
test_case('testsets/cross_domain_coupling_spiral.pl', 'cross_domain_coupling_spiral', 'CROSS_DOMAIN_COUPLING_SPIRAL', 146).
test_case('testsets/cuba_mandatrophic_collapse.pl', 'cuba_blackout_cycle', 'CUBA_MANDATROPHIC_COLLAPSE', 147).
test_case('testsets/cuban_missile_crisis_excomm_delibration.pl', 'thirteen_days_crisis', 'CUBAN_MISSILE_CRISIS_EXCOMM_DELIBRATION', 148).
test_case('testsets/cultural_memory_decay.pl', 'cultural_memory_decay', 'CULTURAL_MEMORY_DECAY', 149).
test_case('testsets/currys_paradox.pl', 'currys_paradox_interval', 'CURRYS_PARADOX', 150).
test_case('testsets/damped_harmonics.pl', 'damped_harmonics', 'DAMPED_HARMONICS', 151).
test_case('testsets/dark_patterns_manipulation.pl', 'dark_patterns_manipulation', 'DARK_PATTERNS_MANIPULATION', 152).
test_case('testsets/data_laundering_pipeline.pl', 'data_laundering_pipeline', 'DATA_LAUNDERING_PIPELINE', 153).
test_case('testsets/dead_sea_effect.pl', 'dead_sea_effect', 'DEAD_SEA_EFFECT', 154).
test_case('testsets/decision_latency_mismatch.pl', 'decision_latency_mismatch', 'DECISION_LATENCY_MISMATCH', 155).
test_case('testsets/deferential_realism_core.pl', 'dr_recursive_int', 'DEFERENTIAL_REALISM_CORE', 156).
test_case('testsets/deferred_risk_realization.pl', 'deferred_risk_realization', 'DEFERRED_RISK_REALIZATION', 157).
test_case('testsets/delayed_feedback_instability.pl', 'delayed_feedback_instability', 'DELAYED_FEEDBACK_INSTABILITY', 158).
test_case('testsets/demographic_inertia_trap.pl', 'demographic_inertia_trap', 'DEMOGRAPHIC_INERTIA_TRAP', 159).
test_case('testsets/digital_credentialing_verification.pl', 'credentialing_shift_2026', 'DIGITAL_CREDENTIALING_VERIFICATION', 160).
test_case('testsets/digital_identity_tether.pl', 'digital_identity_tether', 'DIGITAL_IDENTITY_TETHER', 161).
test_case('testsets/dionysaic_frenzy.pl', 'dionysiac_frenzy_interval', 'DIONYSAIC_FRENZY', 162).
test_case('testsets/dldr_information_policy.pl', 'dldr_policy_interval', 'DLDR_INFORMATION_POLICY', 163).
test_case('testsets/dunbars_number.pl', 'dunbar_interval', 'DUNBARS_NUMBER', 164).
test_case('testsets/dunning_kruger_effect.pl', 'dunning_kruger_effect', 'DUNNING_KRUGER_EFFECT', 165).
test_case('testsets/e2ee_digital_privacy_2026.pl', 'e2ee_digital_privacy_2026', 'E2EE_DIGITAL_PRIVACY_2026', 166).
test_case('testsets/educational_unbundling_implementation.pl', 'implementation_window_2026', 'EDUCATIONAL_UNBUNDLING_IMPLEMENTATION', 167).
test_case('testsets/electrification_scale_2026.pl', 'electrification_scale_2026', 'ELECTRIFICATION_SCALE_2026', 168).
test_case('testsets/elencher_identity_transformation.pl', 'elencher_identity_transformation', 'ELENCHER_IDENTITY_TRANSFORMATION', 169).
test_case('testsets/elite_overproduction_instability.pl', 'elite_overproduction_instability', 'ELITE_OVERPRODUCTION_INSTABILITY', 170).
test_case('testsets/emergency_deployment_scaffold.pl', 'emergency_bridge_scaffold', 'EMERGENCY_DEPLOYMENT_SCAFFOLD', 171).
test_case('testsets/emergency_mode_lock_in.pl', 'emergency_mode_lock_in', 'EMERGENCY_MODE_LOCK_IN', 172).
test_case('testsets/emergency_oversight_bureau.pl', 'emergency_oversight_bureau', 'EMERGENCY_OVERSIGHT_BUREAU', 173).
test_case('testsets/emergency_powers_ratchet.pl', 'emergency_powers_ratchet', 'EMERGENCY_POWERS_RATCHET', 174).
test_case('testsets/emergent_goal_misalignment.pl', 'emergent_goal_misalignment', 'EMERGENT_GOAL_MISALIGNMENT', 175).
test_case('testsets/empty_tomb_transformation.pl', 'empty_tomb_transformation', 'EMPTY_TOMB_TRANSFORMATION', 176).
test_case('testsets/emrgency_medicine_clinical_guidelines.pl', 'em_practice_v2', 'EMRGENCY_MEDICINE_CLINICAL_GUIDELINES', 177).
test_case('testsets/endocrine_disruption_society.pl', 'endocrine_disruption_society', 'ENDOCRINE_DISRUPTION_SOCIETY', 178).
test_case('testsets/endowment_effect.pl', 'endowment_interval', 'ENDOWMENT_EFFECT', 179).
test_case('testsets/epigenetics_complexity_2026.pl', 'epigenetics_complexity_2026', 'EPIGENETICS_COMPLEXITY_2026', 180).
test_case('testsets/epistemic_free_rider_problem.pl', 'epistemic_free_rider_problem', 'EPISTEMIC_FREE_RIDER_PROBLEM', 181).
test_case('testsets/epistemic_overload_collapse.pl', 'epistemic_overload_collapse', 'EPISTEMIC_OVERLOAD_COLLAPSE', 182).
test_case('testsets/ergo_autolykos_asic_resistance.pl', 'ergo_autolykos_asic_resistance', 'ERGO_AUTOLYKOS_ASIC_RESISTANCE', 183).
test_case('testsets/ergo_dexy_gold_protocol.pl', 'dexy_gold_interval', 'ERGO_DEXY_GOLD_PROTOCOL', 184).
test_case('testsets/ergo_lets_protocol.pl', 'ergo_lets_interval', 'ERGO_LETS_PROTOCOL', 185).
test_case('testsets/ergo_mixer_protocol.pl', 'ergo_mixer_protocol', 'ERGO_MIXER_PROTOCOL', 186).
test_case('testsets/ergo_nipopows.pl', 'ergo_nipopows', 'ERGO_NIPOPOWS', 187).
test_case('testsets/ergo_rosen_bridge_protocol.pl', 'rosen_bridge_interval', 'ERGO_ROSEN_BRIDGE_PROTOCOL', 188).
test_case('testsets/ergo_sig_usd_protocol.pl', 'sig_usd_interval', 'ERGO_SIG_USD_PROTOCOL', 189).
test_case('testsets/ergo_storage_rent.pl', 'ergo_storage_rent', 'ERGO_STORAGE_RENT', 190).
test_case('testsets/ergo_storage_rent_mechanism.pl', 'ergo_storage_rent_mechanism', 'ERGO_STORAGE_RENT_MECHANISM', 191).
test_case('testsets/ergodic_theorems.pl', 'ergodic_interval', 'ERGODIC_THEOREMS', 192).
test_case('testsets/ergot_grain_poisoning.pl', 'ergot_grain_poisoning_interval', 'ERGOT_GRAIN_POISONING', 193).
test_case('testsets/euler_characteristic_topology.pl', 'euler_era', 'EULER_CHARACTERISTIC_TOPOLOGY', 194).
test_case('testsets/evidence_half_life.pl', 'evidence_half_life', 'EVIDENCE_HALF_LIFE', 195).
test_case('testsets/evolutionary_knowledge.pl', 'evolutionary_knowledge', 'EVOLUTIONARY_KNOWLEDGE', 196).
test_case('testsets/evolutionary_mismatch_load.pl', 'evolutionary_mismatch_load', 'EVOLUTIONARY_MISMATCH_LOAD', 197).
test_case('testsets/exoplanet_habitability_arbitrage.pl', 'exoplanetary_habitability_arbitrage', 'EXOPLANET_HABITABILITY_ARBITRAGE', 198).
test_case('testsets/expert_disempowerment.pl', 'expert_disempowerment', 'EXPERT_DISEMPOWERMENT', 199).
test_case('testsets/exploration_vs_exploitation.pl', 'exploration_vs_exploitation', 'EXPLORATION_VS_EXPLOITATION', 200).
test_case('testsets/extraordinary_narrative_shift.pl', 'extraordinary_narrative_shift', 'EXTRAORDINARY_NARRATIVE_SHIFT', 201).
test_case('testsets/factional_instability.pl', 'federalist_10_analysis', 'FACTIONAL_INSTABILITY', 202).
test_case('testsets/faint_blue_neural_bifurcation.pl', 'faint_blue_neural_bifurcation', 'FAINT_BLUE_NEURAL_BIFURCATION', 203).
test_case('testsets/fair_use_doctrine.pl', 'fair_use_doctrine', 'FAIR_USE_DOCTRINE', 204).
test_case('testsets/family_estrangement_ratio.pl', 'family_estrangement_ratio', 'FAMILY_ESTRANGEMENT_RATIO', 205).
test_case('testsets/family_succession_and_decadence.pl', 'atsumono_period', 'FAMILY_SUCCESSION_AND_DECADENCE', 206).
test_case('testsets/fast_growing_hierarchy.pl', 'fast_growing_hierarchy', 'FAST_GROWING_HIERARCHY', 207).
test_case('testsets/feedback_loop_desynchronization.pl', 'feedback_loop_desynchronization', 'FEEDBACK_LOOP_DESYNCHRONIZATION', 208).
test_case('testsets/feigenbaum_universality.pl', 'feigenbaum_universality', 'FEIGENBAUM_UNIVERSALITY', 209).
test_case('testsets/financialization_drag.pl', 'financial_drag', 'FINANCIALIZATION_DRAG', 210).
test_case('testsets/finite_pool_of_worry.pl', 'finite_pool_of_worry_interval', 'FINITE_POOL_OF_WORRY', 211).
test_case('testsets/finite_simple_groups_classification.pl', 'cfsg_era', 'FINITE_SIMPLE_GROUPS_CLASSIFICATION', 212).
test_case('testsets/fiscal_dominance_trap.pl', 'fiscal_dominance_trap', 'FISCAL_DOMINANCE_TRAP', 213).
test_case('testsets/fittss_law.pl', 'fittss_law_interval', 'FITTSS_LAW', 214).
test_case('testsets/fmeca_procedures_1980.pl', 'fmeca_standard_era', 'FMECA_PROCEDURES_1980', 215).
test_case('testsets/four_color_theorem_topological_bound.pl', 'four_color_era', 'FOUR_COLOR_THEOREM_TOPOLOGICAL_BOUND', 216).
test_case('testsets/fragile_middle_layer_collapse.pl', 'fragile_middle_layer_collapse', 'FRAGILE_MIDDLE_LAYER_COLLAPSE', 217).
test_case('testsets/framing_effect.pl', 'framing_effect_interval', 'FRAMING_EFFECT', 218).
test_case('testsets/france_2027_presidential_election.pl', 'france_2027_presidential_election', 'FRANCE_2027_PRESIDENTIAL_ELECTION', 219).
test_case('testsets/france_cordon_sanitaire_2026.pl', 'france_cordon_sanitaire_2026', 'FRANCE_CORDON_SANITAIRE_2026', 220).
test_case('testsets/frankenstein_creation_hubris.pl', 'frankenstein_creation_hubris', 'FRANKENSTEIN_CREATION_HUBRIS', 221).
test_case('testsets/french_local_elections_march_2026.pl', 'france_local_elections_march_2026', 'FRENCH_LOCAL_ELECTIONS_MARCH_2026', 222).
test_case('testsets/fundamental_theorem_of_algebra.pl', 'fta_era', 'FUNDAMENTAL_THEOREM_OF_ALGEBRA', 223).
test_case('testsets/gale_shapley.pl', 'gale_shapley', 'GALE_SHAPLEY', 224).
test_case('testsets/galois_theory_symmetry.pl', 'galois_era', 'GALOIS_THEORY_SYMMETRY', 225).
test_case('testsets/gamblers_ruin_stochastic_extinction.pl', 'ruin_era', 'GAMBLERS_RUIN_STOCHASTIC_EXTINCTION', 226).
test_case('testsets/gauss_bonnet_topology.pl', 'gauss_bonnet_era', 'GAUSS_BONNET_TOPOLOGY', 227).
test_case('testsets/generational_replacement_inertia.pl', 'generational_replacement_inertia', 'GENERATIONAL_REPLACEMENT_INERTIA', 228).
test_case('testsets/genetic_algorithms_evolution.pl', 'genetic_algorithms_evolution', 'GENETIC_ALGORITHMS_EVOLUTION', 229).
test_case('testsets/genetic_predisposition.pl', 'genetic_predisposition_interval', 'GENETIC_PREDISPOSITION', 230).
test_case('testsets/germline_regulation_threshold_2026.pl', 'germline_regulation_threshold_2026', 'GERMLINE_REGULATION_THRESHOLD_2026', 231).
test_case('testsets/gig_economy_algorithmic_managment.pl', 'platform_labor_epoch', 'GIG_ECONOMY_ALGORITHMIC_MANAGMENT', 232).
test_case('testsets/gilgamesh_mortality_limit.pl', 'gilgamesh_epic_cycle', 'GILGAMESH_MORTALITY_LIMIT', 233).
test_case('testsets/gita_kurukshetra.pl', 'gita_kurukshetra', 'GITA_KURUKSHETRA', 234).
test_case('testsets/global_protocol_entrenchment.pl', 'global_protocol_entrenchment', 'GLOBAL_PROTOCOL_ENTRENCHMENT', 235).
test_case('testsets/global_stimulus_spree.pl', 'global_stimulus_spree', 'GLOBAL_STIMULUS_SPREE', 236).
test_case('testsets/global_water_bankruptcy.pl', 'global_water_bankruptcy', 'GLOBAL_WATER_BANKRUPTCY', 237).
test_case('testsets/glp1_payload_efficiency_pivot.pl', 'glp1_market_impact_2026', 'GLP1_PAYLOAD_EFFICIENCY_PIVOT', 238).
test_case('testsets/goal_boundary_poisoning.pl', 'goal_boundary_poisoning', 'GOAL_BOUNDARY_POISONING', 239).
test_case('testsets/godels_incompleteness_theorems.pl', 'goedel_era', 'GODELS_INCOMPLETENESS_THEOREMS', 240).
test_case('testsets/goldbach_conjecture.pl', 'goldbach_era', 'GOLDBACH_CONJECTURE', 241).
test_case('testsets/golden_handcuffs.pl', 'golden_handcuffs', 'GOLDEN_HANDCUFFS', 242).
test_case('testsets/goodharts_law.pl', 'goodharts_law_interval', 'GOODHARTS_LAW', 243).
test_case('testsets/governance_latency_gap.pl', 'governance_latency_gap', 'GOVERNANCE_LATENCY_GAP', 244).
test_case('testsets/governance_overfitting.pl', 'governance_overfitting', 'GOVERNANCE_OVERFITTING', 245).
test_case('testsets/gradient_descent_optimization.pl', 'gradient_descent_optimization', 'GRADIENT_DESCENT_OPTIMIZATION', 246).
test_case('testsets/graph_coloring_complexity.pl', 'graph_coloring_interval', 'GRAPH_COLORING_COMPLEXITY', 247).
test_case('testsets/greenland_seizure_trade_war.pl', 'greenland_crisis_2026', 'GREENLAND_SEIZURE_TRADE_WAR', 248).
test_case('testsets/greshams_law.pl', 'greshams_law', 'GRESHAMS_LAW', 249).
test_case('testsets/grete_samsa_transition.pl', 'grete_samsa_transition', 'GRETE_SAMSA_TRANSITION', 250).
test_case('testsets/grievance_stack_overflow.pl', 'grievance_stack_overflow', 'GRIEVANCE_STACK_OVERFLOW', 251).
test_case('testsets/gs1_gln_identification.pl', 'gln_standard_lifecycle', 'GS1_GLN_IDENTIFICATION', 252).
test_case('testsets/gs1_standardized_identification.pl', 'gs1_spec_v25', 'GS1_STANDARDIZED_IDENTIFICATION', 253).
test_case('testsets/halting_problem_undecidability.pl', 'halting_era', 'HALTING_PROBLEM_UNDECIDABILITY', 254).
test_case('testsets/hamiltonian_path_complexity.pl', 'hamiltonian_path_complexity', 'HAMILTONIAN_PATH_COMPLEXITY', 255).
test_case('testsets/hammurabi.pl', 'hammurabi_lex_talionis', 'HAMMURABI', 256).
test_case('testsets/hanlons_razor.pl', 'hanlons_razor', 'HANLONS_RAZOR', 257).
test_case('testsets/happiness_of_others.pl', 'happiness_of_others', 'HAPPINESS_OF_OTHERS', 258).
test_case('testsets/harm_principle_liberty.pl', 'on_liberty_analysis', 'HARM_PRINCIPLE_LIBERTY', 259).
test_case('testsets/harry_potter_liberalism.pl', 'hp_liberalism', 'HARRY_POTTER_LIBERALISM', 260).
test_case('testsets/hawthorne_effect.pl', 'hawthorne_interval', 'HAWTHORNE_EFFECT', 261).
test_case('testsets/hedonic_adaptation_baseline.pl', 'hedonic_adaptation_baseline', 'HEDONIC_ADAPTATION_BASELINE', 262).
test_case('testsets/heisenberg_uncertainty.pl', 'heisenberg_interval', 'HEISENBERG_UNCERTAINTY', 263).
test_case('testsets/helsinki_bus_theory.pl', 'helsinki_bus_theory', 'HELSINKI_BUS_THEORY', 264).
test_case('testsets/heuristic_optimization.pl', 'heuristic_optimization', 'HEURISTIC_OPTIMIZATION', 265).
test_case('testsets/hidden_interdependency_risk.pl', 'hidden_interdependency_risk', 'HIDDEN_INTERDEPENDENCY_RISK', 266).
test_case('testsets/hilberts_hotel_infinity.pl', 'hilberts_hotel_infinity', 'HILBERTS_HOTEL_INFINITY', 267).
test_case('testsets/hiv_prep_prevention_2026.pl', 'hiv_prep_prevention_2026', 'HIV_PREP_PREVENTION_2026', 268).
test_case('testsets/hoa_covenants.pl', 'hoa_interval', 'HOA_COVENANTS', 269).
test_case('testsets/hollow_state_syndrome.pl', 'hollow_state_syndrome', 'HOLLOW_STATE_SYNDROME', 270).
test_case('testsets/hominin_evolutionary_bottleneck.pl', 'hominin_evolutionary_bottleneck', 'HOMININ_EVOLUTIONARY_BOTTLENECK', 271).
test_case('testsets/hu_2026_electoral_parity.pl', 'hu_2026_election_rules', 'HU_2026_ELECTORAL_PARITY', 272).
test_case('testsets/hydra_game.pl', 'hydra_interval', 'HYDRA_GAME', 273).
test_case('testsets/hypercompression_of_time_horizons.pl', 'milliseconds', 'HYPERCOMPRESSION_OF_TIME_HORIZONS', 274).
test_case('testsets/hypernormie_equilibrium.pl', 'hypernormie_equilibrium', 'HYPERNORMIE_EQUILIBRIUM', 275).
test_case('testsets/identity_stack_incompatibility.pl', 'identity_stack_incompatibility', 'IDENTITY_STACK_INCOMPATIBILITY', 276).
test_case('testsets/incentive_surface_warping.pl', 'incentive_surface_warping', 'INCENTIVE_SURFACE_WARPING', 277).
test_case('testsets/indexical_relativity_core.pl', 'meta_logic_01', 'INDEXICAL_RELATIVITY_CORE', 278).
test_case('testsets/individual_revolution_autonomy.pl', 'individual_revolution_autonomy', 'INDIVIDUAL_REVOLUTION_AUTONOMY', 279).
test_case('testsets/inference_cost_scaling_law.pl', 'inference_cost_scaling_law', 'INFERENCE_COST_SCALING_LAW', 280).
test_case('testsets/information_foraging_theory.pl', 'information_foraging_theory', 'INFORMATION_FORAGING_THEORY', 281).
test_case('testsets/infrastructure_decay_piton.pl', 'infrastructure_decay_piton', 'INFRASTRUCTURE_DECAY_PITON', 282).
test_case('testsets/infrastructure_interoperability_decay.pl', 'infrastructure_interoperability_decay', 'INFRASTRUCTURE_INTEROPERABILITY_DECAY', 283).
test_case('testsets/inner_model_theory_constraints.pl', 'inner_model_era', 'INNER_MODEL_THEORY_CONSTRAINTS', 284).
test_case('testsets/innovators_dilemma.pl', 'innovators_dilemma_interval', 'INNOVATORS_DILEMMA', 285).
test_case('testsets/institutional_inertia_lock.pl', 'institutional_inertia_lock', 'INSTITUTIONAL_INERTIA_LOCK', 286).
test_case('testsets/institutional_memory_loss.pl', 'institutional_memory_loss', 'INSTITUTIONAL_MEMORY_LOSS', 287).
test_case('testsets/institutional_mutation_domestication.pl', 'institutional_mutation_domestication', 'INSTITUTIONAL_MUTATION_DOMESTICATION', 288).
test_case('testsets/institutional_mutation_without_selection.pl', 'institutional_mutation_without_selection', 'INSTITUTIONAL_MUTATION_WITHOUT_SELECTION', 289).
test_case('testsets/institutional_trust_decay.pl', 'institutional_trust_decay', 'INSTITUTIONAL_TRUST_DECAY', 290).
test_case('testsets/insult_wisdom_training.pl', 'insult_wisdom_interval', 'INSULT_WISDOM_TRAINING', 291).
test_case('testsets/integrated_digital_governance_stack.pl', 'meta_stack_convergence', 'INTEGRATED_DIGITAL_GOVERNANCE_STACK', 292).
test_case('testsets/interface_contract_breakdown.pl', 'interface_contract_breakdown', 'INTERFACE_CONTRACT_BREAKDOWN', 293).
test_case('testsets/internet_archive_preservation.pl', 'ia_digital_preservation', 'INTERNET_ARCHIVE_PRESERVATION', 294).
test_case('testsets/interpretive_frame_fragmentation.pl', 'interpretive_frame_fragmentation', 'INTERPRETIVE_FRAME_FRAGMENTATION', 295).
test_case('testsets/intertemporal_responsibility_gap.pl', 'intertemporal_responsibility_gap', 'INTERTEMPORAL_RESPONSIBILITY_GAP', 296).
test_case('testsets/invisible_infrastructure_dependency.pl', 'invisible_infrastructure_dependency', 'INVISIBLE_INFRASTRUCTURE_DEPENDENCY', 297).
test_case('testsets/iran_mandatrophic_collapse.pl', 'iran_unrest_2025', 'IRAN_MANDATROPHIC_COLLAPSE', 298).
test_case('testsets/iron_law_of_oligarchy.pl', 'oligarchy_interval', 'IRON_LAW_OF_OLIGARCHY', 299).
test_case('testsets/irreversible_policy_commitment.pl', 'irreversible_policy_commitment', 'IRREVERSIBLE_POLICY_COMMITMENT', 300).
test_case('testsets/isa_education_scaffold.pl', 'isa_education_scaffold', 'ISA_EDUCATION_SCAFFOLD', 301).
test_case('testsets/israel_electoral_threshold.pl', 'israel_electoral_threshold', 'ISRAEL_ELECTORAL_THRESHOLD', 302).
test_case('testsets/israel_norwegian_law.pl', 'israel_norwegian_law', 'ISRAEL_NORWEGIAN_LAW', 303).
test_case('testsets/israel_override_clause.pl', 'israel_override_clause', 'ISRAEL_OVERRIDE_CLAUSE', 304).
test_case('testsets/israel_surplus_vote_agreements.pl', 'israel_surplus_vote_agreements', 'ISRAEL_SURPLUS_VOTE_AGREEMENTS', 305).
test_case('testsets/japanese_energy_scaffold_2025.pl', 'japan_gx_transition', 'JAPANESE_ENERGY_SCAFFOLD_2025', 306).
test_case('testsets/jevons_paradox.pl', 'jevons_interval', 'JEVONS_PARADOX', 307).
test_case('testsets/job_hunt_volume_system_2026.pl', 'job_hunt_volume_system_2026', 'JOB_HUNT_VOLUME_SYSTEM_2026', 308).
test_case('testsets/keltner_relationship_evaluation.pl', 'keltner_relationship_evaluation', 'KELTNER_RELATIONSHIP_EVALUATION', 309).
test_case('testsets/khantivadin_radical_patience.pl', 'khantivadin_patience_interval', 'KHANTIVADIN_RADICAL_PATIENCE', 310).
test_case('testsets/kidney_exchange_market.pl', 'kidney_exchange_market', 'KIDNEY_EXCHANGE_MARKET', 311).
test_case('testsets/kirby_paris_theorem.pl', 'kirby_paris_interval', 'KIRBY_PARIS_THEOREM', 312).
test_case('testsets/kjv_great_awakening.pl', 'kjv_great_awakening', 'KJV_GREAT_AWAKENING', 313).
test_case('testsets/kjv_linguistic_residue.pl', 'kjv_linguistic_residue', 'KJV_LINGUISTIC_RESIDUE', 314).
test_case('testsets/kjv_puritan_new_world_exit.pl', 'kjv_puritan_new_world_exit', 'KJV_PURITAN_NEW_WORLD_EXIT', 315).
test_case('testsets/kjv_textual_authority.pl', 'kjv_textual_authority', 'KJV_TEXTUAL_AUTHORITY', 316).
test_case('testsets/kleene_recursion_theorem.pl', 'kleene_era', 'KLEENE_RECURSION_THEOREM', 317).
test_case('testsets/knowledge_action_gap.pl', 'knowledge_action_gap', 'KNOWLEDGE_ACTION_GAP', 318).
test_case('testsets/landscape_of_fear_2026.pl', 'landscape_of_fear_2026', 'LANDSCAPE_OF_FEAR_2026', 319).
test_case('testsets/large_cardinals_foundations.pl', 'large_cardinal_era', 'LARGE_CARDINALS_FOUNDATIONS', 320).
test_case('testsets/latent_goal_activation.pl', 'latent_goal_activation', 'LATENT_GOAL_ACTIVATION', 321).
test_case('testsets/latent_regulatory_bomb.pl', 'latent_regulatory_bomb', 'LATENT_REGULATORY_BOMB', 322).
test_case('testsets/law_of_diminishing_returns.pl', 'diminishing_returns_interval', 'LAW_OF_DIMINISHING_RETURNS', 323).
test_case('testsets/layered_brain_processing.pl', 'layered_brain_processing', 'LAYERED_BRAIN_PROCESSING', 324).
test_case('testsets/legacy_system_technical_debt.pl', 'software_lifecycle_r7', 'LEGACY_SYSTEM_TECHNICAL_DEBT', 325).
test_case('testsets/legal_formalism_overhang.pl', 'legal_formalism_overhang', 'LEGAL_FORMALISM_OVERHANG', 326).
test_case('testsets/legibility_trap.pl', 'legibility_trap', 'LEGIBILITY_TRAP', 327).
test_case('testsets/legitimacy_without_capacity.pl', 'legitimacy_without_capacity', 'LEGITIMACY_WITHOUT_CAPACITY', 328).
test_case('testsets/legitimacy_without_effectiveness.pl', 'legitimacy_without_effectiveness', 'LEGITIMACY_WITHOUT_EFFECTIVENESS', 329).
test_case('testsets/lehman_repo_105.pl', 'lehman_repo_105', 'LEHMAN_REPO_105', 330).
test_case('testsets/liar_paradox.pl', 'liar_paradox_interval', 'LIAR_PARADOX', 331).
test_case('testsets/lindy_effect.pl', 'lindy_effect', 'LINDY_EFFECT', 332).
test_case('testsets/liquidity_illusion.pl', 'liquidity_illusion', 'LIQUIDITY_ILLUSION', 333).
test_case('testsets/litany_of_the_real.pl', 'litany_of_the_real', 'LITANY_OF_THE_REAL', 334).
test_case('testsets/lln_convergence.pl', 'lln_era', 'LLN_CONVERGENCE', 335).
test_case('testsets/lobs_theorem.pl', 'lobs_theorem_interval', 'LOBS_THEOREM', 336).
test_case('testsets/local_vs_global_optima.pl', 'local_vs_global_optima', 'LOCAL_VS_GLOBAL_OPTIMA', 337).
test_case('testsets/logistic_map_dynamics.pl', 'logistic_map_era', 'LOGISTIC_MAP_DYNAMICS', 338).
test_case('testsets/lorenz_attractor_dynamics.pl', 'lorenz_era', 'LORENZ_ATTRACTOR_DYNAMICS', 339).
test_case('testsets/lowenheim_skolem_theorem.pl', 'lowenheim_skolem_interval', 'LOWENHEIM_SKOLEM_THEOREM', 340).
test_case('testsets/lsd_microdosing_professional_openness.pl', 'lsd_microdosing_professional_openness', 'LSD_MICRODOSING_PROFESSIONAL_OPENNESS', 341).
test_case('testsets/lula_hemisphere_2026.pl', 'lula_hemisphere_2026', 'LULA_HEMISPHERE_2026', 342).
test_case('testsets/magna_carta_liberties.pl', 'magna_carta_liberties', 'MAGNA_CARTA_LIBERTIES', 343).
test_case('testsets/maintenance_capacity_shortfall.pl', 'maintenance_capacity_shortfall', 'MAINTENANCE_CAPACITY_SHORTFALL', 344).
test_case('testsets/maladaptive_selection_process.pl', 'maladaptive_selection_process', 'MALADAPTIVE_SELECTION_PROCESS', 345).
test_case('testsets/mandatrophic_margin_collapse.pl', 'mandatrophy_cycle', 'MANDATROPHIC_MARGIN_COLLAPSE', 346).
test_case('testsets/mandatrophic_margin_collapse_diagnostic.pl', 'mandatrophy_lifecycle', 'MANDATROPHIC_MARGIN_COLLAPSE_DIAGNOSTIC', 347).
test_case('testsets/marriage_problem.pl', 'optimal_stopping_marriage', 'MARRIAGE_PROBLEM', 348).
test_case('testsets/mars_rovers_navigational_autonomy.pl', 'mars_autonomy_evolution', 'MARS_ROVERS_NAVIGATIONAL_AUTONOMY', 349).
test_case('testsets/martian_signal_latency.pl', 'mariner_to_msl_era', 'MARTIAN_SIGNAL_LATENCY', 350).
test_case('testsets/matching_markets_general.pl', 'matching_markets_general', 'MATCHING_MARKETS_GENERAL', 351).
test_case('testsets/material_tensile_strength.pl', 'tensile_strength_interval', 'MATERIAL_TENSILE_STRENGTH', 352).
test_case('testsets/max_flow.pl', 'max_flow_min_cut', 'MAX_FLOW', 353).
test_case('testsets/mco_unit_system_discontinuity.pl', 'mco_failure_trajectory', 'MCO_UNIT_SYSTEM_DISCONTINUITY', 354).
test_case('testsets/med_diet_consensus_2026.pl', 'med_diet_consensus_2026', 'MED_DIET_CONSENSUS_2026', 355).
test_case('testsets/medical_residency_match.pl', 'medical_residency_match', 'MEDICAL_RESIDENCY_MATCH', 356).
test_case('testsets/medieval_church_hegomony.pl', 'medieval_church_hegemony', 'MEDIEVAL_CHURCH_HEGOMONY', 357).
test_case('testsets/memetic_fitness_vs_truth.pl', 'memetic_fitness_vs_truth', 'MEMETIC_FITNESS_VS_TRUTH', 358).
test_case('testsets/meta_governance_overload.pl', 'meta_governance_overload', 'META_GOVERNANCE_OVERLOAD', 359).
test_case('testsets/meta_model_lock_in.pl', 'meta_model_lock_in', 'META_MODEL_LOCK_IN', 360).
test_case('testsets/metabolic_constraint_cognition.pl', 'metabolic_constraint_cognition', 'METABOLIC_CONSTRAINT_COGNITION', 361).
test_case('testsets/metamorphosis_samsa.pl', 'samsa_transformation_period', 'METAMORPHOSIS_SAMSA', 362).
test_case('testsets/micro_robot_electronics_integration.pl', 'ek_robot_integration_cycle', 'MICRO_ROBOT_ELECTRONICS_INTEGRATION', 363).
test_case('testsets/microbiome_symbiosis.pl', 'microbiome_symbiosis', 'MICROBIOME_SYMBIOSIS', 364).
test_case('testsets/mil_std_461g_emi_control.pl', 'mil_std_461g_era', 'MIL_STD_461G_EMI_CONTROL', 365).
test_case('testsets/mil_std_810f_tailoring.pl', 'mil_std_810f_era', 'MIL_STD_810F_TAILORING', 366).
test_case('testsets/minimax_decision_rule.pl', 'minimax_era', 'MINIMAX_DECISION_RULE', 367).
test_case('testsets/mirror_of_erised_expectation.pl', 'erised_expectation', 'MIRROR_OF_ERISED_EXPECTATION', 368).
test_case('testsets/misunderstanding_as_mismatch.pl', 'misunderstanding_as_mismatch', 'MISUNDERSTANDING_AS_MISMATCH', 369).
test_case('testsets/model_autonomy_creep.pl', 'model_autonomy_creep', 'MODEL_AUTONOMY_CREEP', 370).
test_case('testsets/model_collapse_feedback_loop.pl', 'model_collapse_feedback_loop', 'MODEL_COLLAPSE_FEEDBACK_LOOP', 371).
test_case('testsets/model_of_models_regression.pl', 'model_of_models_regression', 'MODEL_OF_MODELS_REGRESSION', 372).
test_case('testsets/monetary_regime_transition.pl', 'nixon_shock_1971', 'MONETARY_REGIME_TRANSITION', 373).
test_case('testsets/monty_hall_conditional_probability.pl', 'probability_paradox_era', 'MONTY_HALL_CONDITIONAL_PROBABILITY', 374).
test_case('testsets/moores_law.pl', 'moores_law_interval', 'MOORES_LAW', 375).
test_case('testsets/moral_outsourcing.pl', 'moral_outsourcing', 'MORAL_OUTSOURCING', 376).
test_case('testsets/multi_agent_reward_hacking.pl', 'multi_agent_reward_hacking', 'MULTI_AGENT_REWARD_HACKING', 377).
test_case('testsets/multi_planetary_latency_lock.pl', 'multi_planetary_latency_lock', 'MULTI_PLANETARY_LATENCY_LOCK', 378).
test_case('testsets/mutual_defection_equilibrium.pl', 'mutual_defection_equilibrium', 'MUTUAL_DEFECTION_EQUILIBRIUM', 379).
test_case('testsets/naming_as_control.pl', 'naming_as_control', 'NAMING_AS_CONTROL', 380).
test_case('testsets/narrative_capacity_exhaustion.pl', 'narrative_capacity_exhaustion', 'NARRATIVE_CAPACITY_EXHAUSTION', 381).
test_case('testsets/narrative_overfitting.pl', 'narrative_overfitting', 'NARRATIVE_OVERFITTING', 382).
test_case('testsets/nasa_faster_better_cheaper.pl', 'fbc_era_operations', 'NASA_FASTER_BETTER_CHEAPER', 383).
test_case('testsets/nash_equilibrium_coordination.pl', 'nash_era', 'NASH_EQUILIBRIUM_COORDINATION', 384).
test_case('testsets/necessary_day_job.pl', 'necessary_day_job', 'NECESSARY_DAY_JOB', 385).
test_case('testsets/negative_emissions_arbitrage.pl', 'negative_emissions_arbitrage', 'NEGATIVE_EMISSIONS_ARBITRAGE', 386).
test_case('testsets/net_zero_stabilization.pl', 'net_zero_stabilization', 'NET_ZERO_STABILIZATION', 387).
test_case('testsets/network_effects.pl', 'network_effects', 'NETWORK_EFFECTS', 388).
test_case('testsets/neural_interoperability.pl', 'neural_interoperability', 'NEURAL_INTEROPERABILITY', 389).
test_case('testsets/neurodiversity_spectrum.pl', 'neurodiversity_spectrum', 'NEURODIVERSITY_SPECTRUM', 390).
test_case('testsets/neuroplasticity_plateau.pl', 'neuroplasticity_plateau', 'NEUROPLASTICITY_PLATEAU', 391).
test_case('testsets/new_civilizational_rope.pl', 'decentralized_infrastructure_rope', 'NEW_CIVILIZATIONAL_ROPE', 392).
test_case('testsets/newtons_method_convergence.pl', 'newton_era', 'NEWTONS_METHOD_CONVERGENCE', 393).
test_case('testsets/nine_day_buffer.pl', 'nine_day_buffer', 'NINE_DAY_BUFFER', 394).
test_case('testsets/no_cloning_theorem.pl', 'no_cloning_interval', 'NO_CLONING_THEOREM', 395).
test_case('testsets/noethers_theorem_symmetry.pl', 'noether_era', 'NOETHERS_THEOREM_SYMMETRY', 396).
test_case('testsets/non_compete_agreements.pl', 'non_compete_agreements', 'NON_COMPETE_AGREEMENTS', 397).
test_case('testsets/nonstandard_arithmetic_models.pl', 'skolem_era', 'NONSTANDARD_ARITHMETIC_MODELS', 398).
test_case('testsets/norm_erosion_threshold.pl', 'norm_erosion_threshold', 'NORM_EROSION_THRESHOLD', 399).
test_case('testsets/north_korea_songun_mandatrophy.pl', 'dprk_songun_cycle', 'NORTH_KOREA_SONGUN_MANDATROPHY', 400).
test_case('testsets/notary_ink_dependency.pl', 'notary_ink_dependency', 'NOTARY_INK_DEPENDENCY', 401).
test_case('testsets/omelet_perfection_complexity.pl', 'omelet_perfection_interval', 'OMELET_PERFECTION_COMPLEXITY', 402).
test_case('testsets/openbsd_netiquette_protocol.pl', 'openbsd_netiquette_protocol', 'OPENBSD_NETIQUETTE_PROTOCOL', 403).
test_case('testsets/optimization_fragility.pl', 'optimization_fragility', 'OPTIMIZATION_FRAGILITY', 404).
test_case('testsets/overfitting_to_frameworks.pl', 'overfitting_to_frameworks', 'OVERFITTING_TO_FRAMEWORKS', 405).
test_case('testsets/overton_window.pl', 'overton_interval', 'OVERTON_WINDOW', 406).
test_case('testsets/p_vs_np.pl', 'p_vs_np_interval', 'P_VS_NP', 407).
test_case('testsets/parable_fish_turtle.pl', 'parable_fish_turtle', 'PARABLE_FISH_TURTLE', 408).
test_case('testsets/pareto_principle.pl', 'pareto_principle', 'PARETO_PRINCIPLE', 409).
test_case('testsets/paris_municipal_reform_2026.pl', 'paris_municipal_reform_2026', 'PARIS_MUNICIPAL_REFORM_2026', 410).
test_case('testsets/parkinsons_law.pl', 'parkinson_interval', 'PARKINSONS_LAW', 411).
test_case('testsets/path_dependence_lock_in.pl', 'path_dependence_lock_in', 'PATH_DEPENDENCE_LOCK_IN', 412).
test_case('testsets/peano_curve_mapping.pl', 'peano_era', 'PEANO_CURVE_MAPPING', 413).
test_case('testsets/permissive_software_licensing.pl', 'permissive_software_licensing', 'PERMISSIVE_SOFTWARE_LICENSING', 414).
test_case('testsets/perovskite_self_etching.pl', 'perovskite_self_etching', 'PEROVSKITE_SELF_ETCHING', 415).
test_case('testsets/personalized_nutritional_arbitrage.pl', 'personalized_nutritional_arbitrage', 'PERSONALIZED_NUTRITIONAL_ARBITRAGE', 416).
test_case('testsets/peter_principle.pl', 'peter_principle', 'PETER_PRINCIPLE', 417).
test_case('testsets/planetary_boundaries.pl', 'planetary_boundaries', 'PLANETARY_BOUNDARIES', 418).
test_case('testsets/planetary_diet_constraint_2026.pl', 'planetary_diet_constraint_2026', 'PLANETARY_DIET_CONSTRAINT_2026', 419).
test_case('testsets/planning_fallacy.pl', 'planning_fallacy_interval', 'PLANNING_FALLACY', 420).
test_case('testsets/platform_cooperativism_governance.pl', 'platform_cooperativism_governance', 'PLATFORM_COOPERATIVISM_GOVERNANCE', 421).
test_case('testsets/platonic_coparenting_decoupling.pl', 'platonic_coparenting', 'PLATONIC_COPARENTING_DECOUPLING', 422).
test_case('testsets/poetic_verse_and_past.pl', 'poetic_verse_and_past', 'POETIC_VERSE_AND_PAST', 423).
test_case('testsets/poincare_conjucture.pl', 'poincare_era', 'POINCARE_CONJUCTURE', 424).
test_case('testsets/policy_lag_catastrophe.pl', 'policy_lag_catastrophe', 'POLICY_LAG_CATASTROPHE', 425).
test_case('testsets/politeness_face_negotiation.pl', 'politeness_face_negotiation', 'POLITENESS_FACE_NEGOTIATION', 426).
test_case('testsets/portugal_government_stability_ad.pl', 'portugal_ad_stability_2026', 'PORTUGAL_GOVERNMENT_STABILITY_AD', 427).
test_case('testsets/portugal_polarization_threshold_2026.pl', 'portugal_polarization_threshold_2026', 'PORTUGAL_POLARIZATION_THRESHOLD_2026', 428).
test_case('testsets/portuguese_presidential_term_limits.pl', 'portuguese_presidential_term_limits', 'PORTUGUESE_PRESIDENTIAL_TERM_LIMITS', 429).
test_case('testsets/postman_survival_protocol.pl', 'postman_survival_interval', 'POSTMAN_SURVIVAL_PROTOCOL', 430).
test_case('testsets/power_without_responsibility.pl', 'power_without_responsibility', 'POWER_WITHOUT_RESPONSIBILITY', 431).
test_case('testsets/prestige_signal_inflation.pl', 'prestige_signal_inflation', 'PRESTIGE_SIGNAL_INFLATION', 432).
test_case('testsets/price_signal_corruption.pl', 'price_signal_corruption', 'PRICE_SIGNAL_CORRUPTION', 433).
test_case('testsets/prime_number_theorem.pl', 'pnt_era', 'PRIME_NUMBER_THEOREM', 434).
test_case('testsets/prisoners_dilemma_equilibrium.pl', 'game_theory_era', 'PRISONERS_DILEMMA_EQUILIBRIUM', 435).
test_case('testsets/private_identity_integration.pl', 'private_identity_integration', 'PRIVATE_IDENTITY_INTEGRATION', 436).
test_case('testsets/procedural_compliance_theater.pl', 'procedural_compliance_theater', 'PROCEDURAL_COMPLIANCE_THEATER', 437).
test_case('testsets/procedural_legitimacy_decay.pl', 'procedural_legitimacy_decay', 'PROCEDURAL_LEGITIMACY_DECAY', 438).
test_case('testsets/proof_of_work_consensus.pl', 'proof_of_work_consensus', 'PROOF_OF_WORK_CONSENSUS', 439).
test_case('testsets/protocol_capture_tangled_rope.pl', 'protocol_capture_eee', 'PROTOCOL_CAPTURE_TANGLED_ROPE', 440).
test_case('testsets/protocol_drift_accumulation.pl', 'protocol_drift_accumulation', 'PROTOCOL_DRIFT_ACCUMULATION', 441).
test_case('testsets/public_domain_commons.pl', 'public_domain_commons', 'PUBLIC_DOMAIN_COMMONS', 442).
test_case('testsets/pythagorean_theorem_geometric_constancy.pl', 'pythagorean_era', 'PYTHAGOREAN_THEOREM_GEOMETRIC_CONSTANCY', 443).
test_case('testsets/qualified_immunity.pl', 'qi_interval', 'QUALIFIED_IMMUNITY', 444).
test_case('testsets/quantam_decryption_risk_2026.pl', 'quantum_decryption_risk_2026', 'QUANTAM_DECRYPTION_RISK_2026', 445).
test_case('testsets/quantum_entanglement_protocol.pl', 'interstellar_quantum_link', 'QUANTUM_ENTANGLEMENT_PROTOCOL', 446).
test_case('testsets/quantum_nonlocality_2026.pl', 'quantum_nonlocality_2026', 'QUANTUM_NONLOCALITY_2026', 447).
test_case('testsets/quellcrist_falconer_justice.pl', 'quellcrist_falconer_justice', 'QUELLCRIST_FALCONER_JUSTICE', 448).
test_case('testsets/quine_self_replication.pl', 'quine_era', 'QUINE_SELF_REPLICATION', 449).
test_case('testsets/qwerty_vs_dvorak.pl', 'qwerty_lockin_interval', 'QWERTY_VS_DVORAK', 450).
test_case('testsets/radiologic_diagnostic_threshold.pl', 'radiology_r7', 'RADIOLOGIC_DIAGNOSTIC_THRESHOLD', 451).
test_case('testsets/railway_gauge_standard.pl', 'railway_gauge_standard', 'RAILWAY_GAUGE_STANDARD', 452).
test_case('testsets/rational_inertia_trap.pl', 'rational_inertia_trap', 'RATIONAL_INERTIA_TRAP', 453).
test_case('testsets/recipe_scaling_ai.pl', 'recipe_scaling_ai', 'RECIPE_SCALING_AI', 454).
test_case('testsets/reciprocity_laws_math.pl', 'reciprocity_laws_math', 'RECIPROCITY_LAWS_MATH', 455).
test_case('testsets/regulatory_capture.pl', 'capture_interval', 'REGULATORY_CAPTURE', 456).
test_case('testsets/relativity_of_simultaneity.pl', 'relativity_of_simultaneity', 'RELATIVITY_OF_SIMULTANEITY', 457).
test_case('testsets/relativity_physical_invariance.pl', 'relativity_physical_invariance', 'RELATIVITY_PHYSICAL_INVARIANCE', 458).
test_case('testsets/rent_seeking_equilibrium.pl', 'rent_seeking_equilibrium', 'RENT_SEEKING_EQUILIBRIUM', 459).
test_case('testsets/reputational_cascade_failure.pl', 'reputational_cascade_failure', 'REPUTATIONAL_CASCADE_FAILURE', 460).
test_case('testsets/responsibility_dilution.pl', 'responsibility_dilution', 'RESPONSIBILITY_DILUTION', 461).
test_case('testsets/responsibility_without_power.pl', 'responsibility_without_power', 'RESPONSIBILITY_WITHOUT_POWER', 462).
test_case('testsets/rfc9293_interoperability.pl', 'tcp_rfc9293_interoperability', 'RFC9293_INTEROPERABILITY', 463).
test_case('testsets/rfc9293_state_machine.pl', 'rfc9293_state_machine', 'RFC9293_STATE_MACHINE', 464).
test_case('testsets/rices_theorem_undecidability.pl', 'rices_era', 'RICES_THEOREM_UNDECIDABILITY', 465).
test_case('testsets/risk_socialization_threshold.pl', 'risk_socialization_threshold', 'RISK_SOCIALIZATION_THRESHOLD', 466).
test_case('testsets/ritual_without_belief.pl', 'ritual_without_belief', 'RITUAL_WITHOUT_BELIEF', 467).
test_case('testsets/ritualistic_transition_scaffold.pl', 'ritual_transition_scaffold', 'RITUALISTIC_TRANSITION_SCAFFOLD', 468).
test_case('testsets/robustness_vs_efficiency_tradeoff.pl', 'robustness_vs_efficiency_tradeoff', 'ROBUSTNESS_VS_EFFICIENCY_TRADEOFF', 469).
test_case('testsets/rogers_commission_institutional_analysis.pl', 'challenger_post_mortem', 'ROGERS_COMMISSION_INSTITUTIONAL_ANALYSIS', 470).
test_case('testsets/rotation_seven_black_soil.pl', 'rotation_seven_black_soil', 'ROTATION_SEVEN_BLACK_SOIL', 471).
test_case('testsets/rotation_seven_isolation.pl', 'rotation_seven_isolation', 'ROTATION_SEVEN_ISOLATION', 472).
test_case('testsets/rotation_seven_kubo_ranking.pl', 'rotation_seven_kubo_ranking', 'ROTATION_SEVEN_KUBO_RANKING', 473).
test_case('testsets/rotmigration_decision_threshold.pl', 'migration_theory_review', 'ROTMIGRATION_DECISION_THRESHOLD', 474).
test_case('testsets/royal_navy_middle_east_withdrawal.pl', 'rn_withdrawal_cycle', 'ROYAL_NAVY_MIDDLE_EAST_WITHDRAWAL', 475).
test_case('testsets/rule_update_failure.pl', 'rule_update_failure', 'RULE_UPDATE_FAILURE', 476).
test_case('testsets/rules_based_international_order.pl', 'rules_based_international_order', 'RULES_BASED_INTERNATIONAL_ORDER', 477).
test_case('testsets/russells_paradox_self_reference.pl', 'russell_era', 'RUSSELLS_PARADOX_SELF_REFERENCE', 478).
test_case('testsets/russian_war_cannibalization.pl', 'russia_cannibalization_cycle', 'RUSSIAN_WAR_CANNIBALIZATION', 479).
test_case('testsets/s1_airbnb.pl', 'airbnb_ipo_era', 'S1_AIRBNB', 480).
test_case('testsets/s1_visa.pl', 'visa_ipo_window', 'S1_VISA', 481).
test_case('testsets/s1_visa_judgment_sharing_agreement.pl', 'visa_litigation_ringfencing', 'S1_VISA_JUDGMENT_SHARING_AGREEMENT', 482).
test_case('testsets/sadhu_integrity_protocol.pl', 'sadhu_integrity_protocol', 'SADHU_INTEGRITY_PROTOCOL', 483).
test_case('testsets/sapir_whorf_hypothesis.pl', 'sapir_whorf_interval', 'SAPIR_WHORF_HYPOTHESIS', 484).
test_case('testsets/sat_csp_complexity.pl', 'sat_csp_interval', 'SAT_CSP_COMPLEXITY', 485).
test_case('testsets/scurvy_maritime_extraction.pl', 'scurvy_maritime_interval', 'SCURVY_MARITIME_EXTRACTION', 486).
test_case('testsets/second_order_unintended_consequences.pl', 'second_order_unintended_consequences', 'SECOND_ORDER_UNINTENDED_CONSEQUENCES', 487).
test_case('testsets/self_surpassing_superman.pl', 'zarathustra_hazar', 'SELF_SURPASSING_SUPERMAN', 488).
test_case('testsets/semantic_attack_surface.pl', 'semantic_attack_surface', 'SEMANTIC_ATTACK_SURFACE', 489).
test_case('testsets/semantic_overload_friction.pl', 'semantic_overload_friction', 'SEMANTIC_OVERLOAD_FRICTION', 490).
test_case('testsets/shadow_pricing_failure.pl', 'shadow_pricing_failure', 'SHADOW_PRICING_FAILURE', 491).
test_case('testsets/shannon_entropy_limit.pl', 'shannon_entropy_limit', 'SHANNON_ENTROPY_LIMIT', 492).
test_case('testsets/shitty_feedback_handling.pl', 'shitty_feedback_handling', 'SHITTY_FEEDBACK_HANDLING', 493).
test_case('testsets/shobies_existential_commitment.pl', 'shobies_existential_commitment', 'SHOBIES_EXISTENTIAL_COMMITMENT', 494).
test_case('testsets/shock_propagation_asymmetry.pl', 'shock_propagation_asymmetry', 'SHOCK_PROPAGATION_ASYMMETRY', 495).
test_case('testsets/signal_without_control.pl', 'signal_without_control', 'SIGNAL_WITHOUT_CONTROL', 496).
test_case('testsets/silent_dependency_activation.pl', 'silent_dependency_activation', 'SILENT_DEPENDENCY_ACTIVATION', 497).
test_case('testsets/silicon_lexicon_overload.pl', 'silicon_lexicon_overload', 'SILICON_LEXICON_OVERLOAD', 498).
test_case('testsets/skills_based_hiring.pl', 'skills_based_hiring', 'SKILLS_BASED_HIRING', 499).
test_case('testsets/skolems_paradox.pl', 'skolems_paradox_interval', 'SKOLEMS_PARADOX', 500).
test_case('testsets/sleep_debt_externality.pl', 'sleep_debt_externality', 'SLEEP_DEBT_EXTERNALITY', 501).
test_case('testsets/slow_crisis_invisibility.pl', 'slow_crisis_invisibility', 'SLOW_CRISIS_INVISIBILITY', 502).
test_case('testsets/sludge_bureaucratic_friction.pl', 'sludge_bureaucratic_friction', 'SLUDGE_BUREAUCRATIC_FRICTION', 503).
test_case('testsets/smartphone_ubiquity.pl', 'smartphone_ubiquity', 'SMARTPHONE_UBIQUITY', 504).
test_case('testsets/social_credit_architecture.pl', 'scs_operational_2026', 'SOCIAL_CREDIT_ARCHITECTURE', 505).
test_case('testsets/social_loafing.pl', 'social_loafing_interval', 'SOCIAL_LOAFING', 506).
test_case('testsets/social_media_participation_threshold.pl', 'social_media_2025_cycle', 'SOCIAL_MEDIA_PARTICIPATION_THRESHOLD', 507).
test_case('testsets/social_narrative_casting.pl', 'social_narrative_casting', 'SOCIAL_NARRATIVE_CASTING', 508).
test_case('testsets/soft_authoritarian_drift.pl', 'soft_authoritarian_drift', 'SOFT_AUTHORITARIAN_DRIFT', 509).
test_case('testsets/solar_system_weirdness.pl', 'solar_system_weirdness', 'SOLAR_SYSTEM_WEIRDNESS', 510).
test_case('testsets/somatic_focusing_awareness.pl', 'somatic_focusing_awareness', 'SOMATIC_FOCUSING_AWARENESS', 511).
test_case('testsets/sorites_paradox.pl', 'sorites_interval', 'SORITES_PARADOX', 512).
test_case('testsets/south_china_sea_arbitration_2016_2026.pl', 'scs_legal_era', 'SOUTH_CHINA_SEA_ARBITRATION_2016_2026', 513).
test_case('testsets/spv_variations_us_cold.pl', 'spv_variations', 'SPV_VARIATIONS_US_COLD', 514).
test_case('testsets/square_cube_law.pl', 'square_cube_interval', 'SQUARE_CUBE_LAW', 515).
test_case('testsets/st_petersburg_paradox.pl', 'st_petersburg_era', 'ST_PETERSBURG_PARADOX', 516).
test_case('testsets/stable_marriage_coordination.pl', 'matching_theory_era', 'STABLE_MARRIAGE_COORDINATION', 517).
test_case('testsets/starwars_evolutionary_mutation.pl', 'galactic_selection_event', 'STARWARS_EVOLUTIONARY_MUTATION', 518).
test_case('testsets/statecraft_virtu.pl', 'statecraft_virtu_analysis', 'STATECRAFT_VIRTU', 519).
test_case('testsets/status_flattening_effect.pl', 'status_flattening_effect', 'STATUS_FLATTENING_EFFECT', 520).
test_case('testsets/steinmetz_valuation_asymmetry.pl', 'steinmetz_valuation_asymmetry', 'STEINMETZ_VALUATION_ASYMMETRY', 521).
test_case('testsets/stoic_logos_governance.pl', 'stoic_logos_governance', 'STOIC_LOGOS_GOVERNANCE', 522).
test_case('testsets/straight_coercion_2025.pl', 'strait_coercion_2025', 'STRAIGHT_COERCION_2025', 523).
test_case('testsets/strange_attractor_dynamics.pl', 'strange_attractor_dynamics', 'STRANGE_ATTRACTOR_DYNAMICS', 524).
test_case('testsets/structural_extraction_without_actor.pl', 'structural_extraction_without_actor', 'STRUCTURAL_EXTRACTION_WITHOUT_ACTOR', 525).
test_case('testsets/sts86_ascent_checklist.pl', 'sts86_ascent_checklist', 'STS86_ASCENT_CHECKLIST', 526).
test_case('testsets/sturgeons_law.pl', 'sturgeon_interval', 'STURGEONS_LAW', 527).
test_case('testsets/suanne_coup_of_peace.pl', 'suanne_coup_of_peace', 'SUANNE_COUP_OF_PEACE', 528).
test_case('testsets/suanne_face_restoration.pl', 'suanne_face_restoration', 'SUANNE_FACE_RESTORATION', 529).
test_case('testsets/sunk_cost_fallacy.pl', 'sunk_cost_interval', 'SUNK_COST_FALLACY', 530).
test_case('testsets/suslin_hypothesis_undecidability.pl', 'suslin_era', 'SUSLIN_HYPOTHESIS_UNDECIDABILITY', 531).
test_case('testsets/swift_legacy_piton.pl', 'swift_legacy_piton', 'SWIFT_LEGACY_PITON', 532).
test_case('testsets/swift_piton_snap.pl', 'swift_piton_snap', 'SWIFT_PITON_SNAP', 533).
test_case('testsets/sylow_theorems_group_theory.pl', 'sylow_era', 'SYLOW_THEOREMS_GROUP_THEORY', 534).
test_case('testsets/synthetic_data_feedback_loop.pl', 'synthetic_data_feedback_loop', 'SYNTHETIC_DATA_FEEDBACK_LOOP', 535).
test_case('testsets/systemic_blindspot.pl', 'systemic_blindspot', 'SYSTEMIC_BLINDSPOT', 536).
test_case('testsets/tail_risk_compression.pl', 'tail_risk_compression', 'TAIL_RISK_COMPRESSION', 537).
test_case('testsets/taiwan_existential_sovereignty.pl', 'taiwan_status_quo_cycle', 'TAIWAN_EXISTENTIAL_SOVEREIGNTY', 538).
test_case('testsets/taiwan_grand_bargain.pl', 'taiwan_grand_bargain', 'TAIWAN_GRAND_BARGAIN', 539).
test_case('testsets/taiwan_storm_2026.pl', 'taiwan_storm_2026', 'TAIWAN_STORM_2026', 540).
test_case('testsets/taiwan_strait_hegemony_shift.pl', 'hegemony_transition_window', 'TAIWAN_STRAIT_HEGEMONY_SHIFT', 541).
test_case('testsets/tarski_undefinability.pl', 'tarski_interval', 'TARSKI_UNDEFINABILITY', 542).
test_case('testsets/taxonomy_drift.pl', 'taxonomy_drift', 'TAXONOMY_DRIFT', 543).
test_case('testsets/teaching_horses_to_sing.pl', 'teaching_horses_to_sing_interval', 'TEACHING_HORSES_TO_SING', 544).
test_case('testsets/technocratic_overreach.pl', 'technocratic_overreach', 'TECHNOCRATIC_OVERREACH', 545).
test_case('testsets/technological_point_of_no_return.pl', 'technological_point_of_no_return', 'TECHNOLOGICAL_POINT_OF_NO_RETURN', 546).
test_case('testsets/technological_provenance_arbitrage.pl', 'technological_provenance_arbitrage', 'TECHNOLOGICAL_PROVENANCE_ARBITRAGE', 547).
test_case('testsets/tehran_water_bankruptcy.pl', 'tehran_water_bankruptcy', 'TEHRAN_WATER_BANKRUPTCY', 548).
test_case('testsets/temporal_resolution_mismatch.pl', 'temporal_resolution_mismatch', 'TEMPORAL_RESOLUTION_MISMATCH', 549).
test_case('testsets/temporal_scale_arbitrage.pl', 'temporal_scale_arbitrage', 'TEMPORAL_SCALE_ARBITRAGE', 550).
test_case('testsets/texas_hispanic_political_pivot.pl', 'tx_pivot_window_2026', 'TEXAS_HISPANIC_POLITICAL_PIVOT', 551).
test_case('testsets/thai_article_112_mountain.pl', 'thai_article_112_mountain', 'THAI_ARTICLE_112_MOUNTAIN', 552).
test_case('testsets/thai_senate_veto_2026.pl', 'thai_senate_veto_2026', 'THAI_SENATE_VETO_2026', 553).
test_case('testsets/thailand_2017_constitution.pl', 'thailand_2017_constitution', 'THAILAND_2017_CONSTITUTION', 554).
test_case('testsets/the_bacchae_madness_protocol.pl', 'theban_dionysian_conflict', 'THE_BACCHAE_MADNESS_PROTOCOL', 555).
test_case('testsets/the_calm_protocol_suppression.pl', 'the_calm_expedition_window', 'THE_CALM_PROTOCOL_SUPPRESSION', 556).
test_case('testsets/the_churn_systemic_upheaval.pl', 'the_churn_systemic_upheaval', 'THE_CHURN_SYSTEMIC_UPHEAVAL', 557).
test_case('testsets/the_novelty_gradient.pl', 'the_novelty_gradient', 'THE_NOVELTY_GRADIENT', 558).
test_case('testsets/the_stochastic_snare.pl', 'the_stochastic_snare', 'THE_STOCHASTIC_SNARE', 559).
test_case('testsets/the_wall_procedural_barrier.pl', 'the_wall_procedural_barrier', 'THE_WALL_PROCEDURAL_BARRIER', 560).
test_case('testsets/theory_of_visitors.pl', 'theory_of_visitors', 'THEORY_OF_VISITORS', 561).
test_case('testsets/thermodynamics_entropy.pl', 'thermodynamics_entropy_interval', 'THERMODYNAMICS_ENTROPY', 562).
test_case('testsets/three_body_unpredicability.pl', 'celestial_mechanics_era', 'THREE_BODY_UNPREDICABILITY', 563).
test_case('testsets/threshold_effect_miscalibration.pl', 'threshold_effect_miscalibration', 'THRESHOLD_EFFECT_MISCALIBRATION', 564).
test_case('testsets/too_big_to_manage.pl', 'too_big_to_manage', 'TOO_BIG_TO_MANAGE', 565).
test_case('testsets/tool_use_delegation_risk.pl', 'tool_use_delegation_risk', 'TOOL_USE_DELEGATION_RISK', 566).
test_case('testsets/toxic_social_infection.pl', 'toxic_social_infection_interval', 'TOXIC_SOCIAL_INFECTION', 567).
test_case('testsets/tractarian_logic_limit.pl', 'tractarian_logic_limit', 'TRACTARIAN_LOGIC_LIMIT', 568).
test_case('testsets/trade_secret_law.pl', 'trade_secret_law', 'TRADE_SECRET_LAW', 569).
test_case('testsets/tragedy_of_the_commons.pl', 'tragedy_of_the_commons', 'TRAGEDY_OF_THE_COMMONS', 570).
test_case('testsets/transformer_self_attention.pl', 'transformer_self_attention', 'TRANSFORMER_SELF_ATTENTION', 571).
test_case('testsets/transient_event_detection.pl', 'transient_event_detection', 'TRANSIENT_EVENT_DETECTION', 572).
test_case('testsets/transitional_utility_bridge.pl', 'transitional_utility_bridge', 'TRANSITIONAL_UTILITY_BRIDGE', 573).
test_case('testsets/traveling_salesperson_problem.pl', 'traveling_salesperson_problem', 'TRAVELING_SALESPERSON_PROBLEM', 574).
test_case('testsets/trojan_war_spoils.pl', 'trojan_collapse_interval', 'TROJAN_WAR_SPOILS', 575).
test_case('testsets/trump_making_china_great_2026.pl', 'post_trump_return', 'TRUMP_MAKING_CHINA_GREAT_2026', 576).
test_case('testsets/trumps_second_term_authoritarianism_2026.pl', 'trump_ii_year_one', 'TRUMPS_SECOND_TERM_AUTHORITARIANISM_2026', 577).
test_case('testsets/truth_by_repetition_effect.pl', 'truth_by_repetition_effect', 'TRUTH_BY_REPETITION_EFFECT', 578).
test_case('testsets/udhr_1946.pl', 'un_era', 'UDHR_1946', 579).
test_case('testsets/ulysses_chp01.pl', 'telemachus_morning', 'ULYSSES_CHP01', 580).
test_case('testsets/ulysses_chp02.pl', 'nestor_afternoon', 'ULYSSES_CHP02', 581).
test_case('testsets/ulysses_chp03.pl', 'proteus_strand_walk', 'ULYSSES_CHP03', 582).
test_case('testsets/ulysses_chp04.pl', 'bloom_kosher_transgression', 'ULYSSES_CHP04', 583).
test_case('testsets/ulysses_chp05.pl', 'bloom_secret_correspondence', 'ULYSSES_CHP05', 584).
test_case('testsets/ulysses_chp06.pl', 'bloom_exclusion_interval', 'ULYSSES_CHP06', 585).
test_case('testsets/ulysses_chp07.pl', 'bloom_aeolus_interval', 'ULYSSES_CHP07', 586).
test_case('testsets/ulysses_chp08.pl', 'lestrygonian_metabolism_chp8_interval', 'ULYSSES_CHP08', 587).
test_case('testsets/ulysses_chp09.pl', 'stephen_shakespeare_ghost', 'ULYSSES_CHP09', 588).
test_case('testsets/ulysses_chp10.pl', 'the_viceregal_cavalcade', 'ULYSSES_CHP10', 589).
test_case('testsets/ulysses_chp11.pl', 'bloom_sirens_interval', 'ULYSSES_CHP11', 590).
test_case('testsets/ulysses_chp12.pl', 'bloom_exclusion_id', 'ULYSSES_CHP12', 591).
test_case('testsets/ulysses_chp13.pl', 'gerty_bloom_interval', 'ULYSSES_CHP13', 592).
test_case('testsets/ulysses_chp14.pl', 'gestation_wombfruit_id', 'ULYSSES_CHP14', 593).
test_case('testsets/ulysses_chp15.pl', 'nighttown_vigil_id', 'ULYSSES_CHP15', 594).
test_case('testsets/ulysses_chp16.pl', 'bloom_samaritan_id', 'ULYSSES_CHP16', 595).
test_case('testsets/ulysses_chp17.pl', 'bloom_ithaca_interval', 'ULYSSES_CHP17', 596).
test_case('testsets/ulysses_chp18.pl', 'molly_affirmation_id', 'ULYSSES_CHP18', 597).
test_case('testsets/unclos_2026.pl', 'unclos_era', 'UNCLOS_2026', 598).
test_case('testsets/union_protection_underperformance.pl', 'labor_management_conflict_r1', 'UNION_PROTECTION_UNDERPERFORMANCE', 599).
test_case('testsets/universal_mathematics_communication.pl', 'scientific_consensus_period', 'UNIVERSAL_MATHEMATICS_COMMUNICATION', 600).
test_case('testsets/us_congress_2026_midterms.pl', 'gerrymandering_incumbency_2026', 'US_CONGRESS_2026_MIDTERMS', 601).
test_case('testsets/us_hydrological_debt.pl', 'us_hydrological_debt', 'US_HYDROLOGICAL_DEBT', 602).
test_case('testsets/us_suburban_zoning_2025.pl', 'us_suburban_zoning_2025', 'US_SUBURBAN_ZONING_2025', 603).
test_case('testsets/us_two_party_duopoly.pl', 'us_two_party_duopoly', 'US_TWO_PARTY_DUOPOLY', 604).
test_case('testsets/utopia_apocalypse_fragility.pl', 'utopia_apocalypse_fragility', 'UTOPIA_APOCALYPSE_FRAGILITY', 605).
test_case('testsets/value_alignment_drift.pl', 'value_alignment_drift', 'VALUE_ALIGNMENT_DRIFT', 606).
test_case('testsets/value_extraction_plateau.pl', 'value_extraction_plateau', 'VALUE_EXTRACTION_PLATEAU', 607).
test_case('testsets/value_learning_instability.pl', 'value_learning_instability', 'VALUE_LEARNING_INSTABILITY', 608).
test_case('testsets/van_der_waerden_theorem.pl', 'van_der_waerden_interval', 'VAN_DER_WAERDEN_THEOREM', 609).
test_case('testsets/viral_transmission_rates.pl', 'viral_transmission_rates', 'VIRAL_TRANSMISSION_RATES', 610).
test_case('testsets/visibility_bias_governance.pl', 'visibility_bias_governance', 'VISIBILITY_BIAS_GOVERNANCE', 611).
test_case('testsets/weber_fechner_law.pl', 'weber_fechner_law', 'WEBER_FECHNER_LAW', 612).
test_case('testsets/whitehead_problem_undecidability.pl', 'whitehead_era', 'WHITEHEAD_PROBLEM_UNDECIDABILITY', 613).
test_case('testsets/wikipedia_crowdsourcing_2026.pl', 'wikipedia_crowdsourcing_2026', 'WIKIPEDIA_CROWDSOURCING_2026', 614).
test_case('testsets/wikipedia_notability_requirement_2026.pl', 'wikipedia_notability_requirement_2026', 'WIKIPEDIA_NOTABILITY_REQUIREMENT_2026', 615).
test_case('testsets/winners_curse.pl', 'winners_curse', 'WINNERS_CURSE', 616).
test_case('testsets/xi_mao_ideological_centralization.pl', 'xi_mao_ideological_centralization', 'XI_MAO_IDEOLOGICAL_CENTRALIZATION', 617).
test_case('testsets/zipfs_law.pl', 'zipfs_law', 'ZIPFS_LAW', 618).

% --- Test Suite Runner ---
run_dynamic_suite :-
    retractall(test_passed(_)),
    retractall(test_failed(_, _, _)),
    writeln('--- STARTING DYNAMIC VALIDATION ---'),
    forall(test_case(Path, ID, Label, N), run_single_test(Path, ID, Label, N)),
    count_and_report,
    % Call validate_all directly from data_validation module
    data_validation:validate_all.

% --- Single Test Executor ---
run_single_test(Path, ID, _Label, N) :-
    format('~n[~w] EXECUTING: ~w~n', [N, Path]),
    catch_with_backtrace(
        ( load_and_run(Path, ID) ->
            assertz(test_passed(Path)),
            format('[PASS] ~w~n', [Path])
        ;   assertz(test_failed(Path, audit_failed, 'load_and_run returned false')),
            format('[AUDIT FAIL] ~w~n', [Path])
        ),
        E,
        (   assertz(test_failed(Path, exception, E)),
            format('[FAIL] Exception for ~w: ~w~n', [Path, E]),
            print_prolog_backtrace(current_output, E)
        )
    ),
    report_generator:generate_llm_feedback(ID).

% --- Result Counter & Reporter ---
count_and_report :-
    findall(P, test_passed(P), Ps), length(Ps, PC),
    findall(F, test_failed(F,_,_), Fs), length(Fs, FC),
    writeln(''),
    writeln('=================================================='),
    writeln('           TEST SUITE SUMMARY'),
    writeln('=================================================='),
    format('Passed: ~w~n', [PC]),
    format('Failed: ~w~n', [FC]),
    (FC > 0 -> report_failures ; true),
    writeln('==================================================').

report_failures :-
    writeln('--- FAILED TESTS ---'),
    forall(test_failed(Path, Type, Detail),
           format('~n  - [~w] ~w~n    Reason: ~w~n', [Type, Path, Detail])).

