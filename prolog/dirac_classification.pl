% ============================================================================
% DIRAC CONSTRAINT CLASSIFICATION — Analytical Overlay v1.0
% ============================================================================
% Maps Dirac's constrained Hamiltonian mechanics onto the Deferential
% Realism constraint taxonomy. This module is READ-ONLY with respect to
% existing classification logic — it calls existing predicates but modifies
% nothing in the pipeline. It adds a physics-theoretic lens for analysis.
%
% DIRAC'S FRAMEWORK (two independent axes):
%   Axis 1 — Primary / Secondary:
%     Primary constraints are imposed directly on the system.
%     Secondary constraints are generated by requiring primary constraints
%     to remain consistent under evolution (consistency conditions).
%
%   Axis 2 — First-Class / Second-Class:
%     First-class constraints commute with all other constraints (Poisson
%     brackets vanish weakly). They generate gauge transformations —
%     apparent degrees of freedom that don't correspond to observable
%     differences. Descriptive redundancy, not reality.
%     Second-class constraints don't commute. They represent genuine
%     restrictions on the system's degrees of freedom.
%
% MAPPING TO DR TYPES:
%   mountain           → second_class   (immutable restriction, no gauge freedom)
%   snare              → second_class   (genuine extraction, cannot be gauged away)
%   rope               → first_class    (coordination choice among equivalents)
%   scaffold           → first_class    (temporary coordination, designed for removal)
%   piton              → first_class_degenerate (ossified gauge — alternatives exist
%                                        but switching costs make them inaccessible)
%   tangled_rope       → mixed          (first-class coordination entangled with
%                                        second-class extraction; reform = factoring)
%   indexically_opaque  → undetermined   (constraint algebra unknown)
%
% WHERE THIS ILLUMINATES (vs. merely relabels):
%   1. gauge_orbit/2 and preserved_under_context_shift/2 formalize what
%      perspectival_gap/2 computes but add physical interpretation: the
%      orbit IS the set of observer frames connected by gauge transformations.
%      A non-singleton orbit means the constraint has non-trivial gauge
%      structure that the classification system is correctly differentiating.
%
%   2. gauge_fixed/3 gives check_all_contexts/2 a principled foundation:
%      "don't cut from a gauge-fixed frame" = "don't remove what appears
%      to be coordination choice when some observers are in a frame where
%      the gauge freedom is inaccessible and the constraint appears as
%      genuine restriction."
%
%   3. The tangled_rope decomposition insight: reform IS the problem of
%      separating first-class (coordination) from second-class (extraction)
%      components. separability_factor/2 measures factoring feasibility.
%      Strongly-coupled tangled ropes resist reform because the first-class
%      and second-class parts are entangled.
%
%   4. The piton as degenerate first-class explains why composition_rule
%      (piton, _, piton) contaminates everything — a degenerate gauge
%      symmetry poisons the constraint algebra.
%
% WHERE THIS MERELY RELABELS:
%   - Mountain as "second_class" adds nothing beyond boltzmann_invariant_mountain/2.
%   - The primary/secondary axis is trivially "primary" for most constraints
%     since the system does not systematically track derivation chains.
%
% DROPPED FROM DESIGN (with reasoning):
%   - dr_bracket/4 (Poisson bracket analog): The existing contamination
%     propagation system (type_contamination_strength/2 × type_immunity/2,
%     directional one-hop capped flow) already handles constraint interaction
%     with well-motivated asymmetry. A symmetrized bracket would fight the
%     entropy principle baked into the structural physics. See Task 4 analysis.
%   - Formal composition algebra: composition_rule/3 needs spec-layer
%     documentation before any formal physics layer is built on top.
%
% FUTURE INTEGRATION FLAG:
%   preserved_under_context_shift/2 should eventually inform the validation
%   pipeline (not just analysis). A constraint whose classification is NOT
%   preserved under context shift has non-trivial gauge structure that the
%   validation suite should track.
%
% Integration: Load after drl_modal_logic.pl. No dependencies on load order
%   beyond what drl_modal_logic.pl already establishes.
% ============================================================================

:- module(dirac_classification, [
    % Gauge orbit and consistency (the clearest win)
    gauge_orbit/2,                      % gauge_orbit(C, OrbitPoints)
    preserved_under_context_shift/2,    % preserved_under_context_shift(C, Result)
    consistency_violations/2,           % consistency_violations(C, Violations)
    gauge_fixed/3,                      % gauge_fixed(C, Context, true | false)

    % First-class / second-class decomposition
    dirac_class/3,                      % dirac_class(C, Context, Class)
    dirac_class/2,                      % backward compat (analytical context)
    gauge_freedom/3,                    % gauge_freedom(C, Context, Freedom)

    % Primary / secondary (lightweight annotation)
    derived_from/3,                     % derived_from(Secondary, Primary, Reason)
    constraint_generation_order/2,      % constraint_generation_order(C, Order)

    % Report
    full_dirac_report/3                 % full_dirac_report(C, Context, Report)
]).

:- use_module(drl_core).
:- use_module(drl_modal_logic).
:- use_module(structural_signatures).
:- use_module(constraint_indexing).
:- use_module(narrative_ontology).
:- use_module(config).

% ============================================================================
% STANDARD CONTEXTS (local copy)
% ============================================================================
% Same four canonical contexts as drl_core.pl and drl_modal_logic.pl.
% Defined locally because neither module exports standard_context/1.

standard_context(context(agent_power(powerless),
                        time_horizon(biographical),
                        exit_options(trapped),
                        spatial_scope(local))).

standard_context(context(agent_power(moderate),
                        time_horizon(biographical),
                        exit_options(mobile),
                        spatial_scope(national))).

standard_context(context(agent_power(institutional),
                        time_horizon(generational),
                        exit_options(arbitrage),
                        spatial_scope(national))).

standard_context(context(agent_power(analytical),
                        time_horizon(civilizational),
                        exit_options(analytical),
                        spatial_scope(global))).

/* ================================================================
   SECTION 1: GAUGE ORBIT & CONSISTENCY CONDITION

   The gauge orbit of a constraint is the set of (Type, Context)
   pairs it manifests across standard observer positions. This
   formalizes what perspectival_gap/2 already computes but adds
   physical interpretation: the orbit IS the set of frames
   connected by gauge transformations.

   A singleton orbit (single type across all contexts) means the
   constraint is context-invariant — either purely second-class
   (always mountain) or purely first-class (always rope).

   A multi-type orbit means the constraint has non-trivial gauge
   structure: what appears as genuine restriction from one frame
   appears as coordination choice from another.
   ================================================================ */

%% gauge_orbit(+Constraint, -OrbitPoints)
%  Collects all (Type, Context) pairs across standard contexts.
%  OrbitPoints = [orbit_point(Type, Context), ...]
%  Sorted for stable comparison.
gauge_orbit(C, OrbitPoints) :-
    findall(orbit_point(Type, Ctx),
            (standard_context(Ctx),
             drl_core:dr_type(C, Ctx, Type)),
            Points),
    sort(Points, OrbitPoints).

%% preserved_under_context_shift(+Constraint, -Result)
%  Tests whether classification is invariant under all standard
%  context transformations. This is the analog of Dirac's consistency
%  condition: does the constraint's classification survive evolution
%  (here: observer position shift)?
%
%  Result = preserved(Type) | violated(Transitions)
%  where Transitions = [transition(Type1, Type2, Ctx1, Ctx2), ...]
%
%  preserved(Type) means the constraint classifies as Type from
%  every standard context — it has trivial gauge structure.
%
%  violated(Transitions) means the constraint reclassifies across
%  contexts — it has non-trivial gauge structure. Each transition
%  records a pair of contexts that produce different types.
preserved_under_context_shift(C, Result) :-
    gauge_orbit(C, Orbit),
    findall(T, member(orbit_point(T, _), Orbit), Types),
    sort(Types, UniqueTypes),
    (   UniqueTypes = [SingleType]
    ->  Result = preserved(SingleType)
    ;   findall(transition(T1, T2, Ctx1, Ctx2),
                (member(orbit_point(T1, Ctx1), Orbit),
                 member(orbit_point(T2, Ctx2), Orbit),
                 T1 @< T2),
                Transitions),
        sort(Transitions, Unique),
        Result = violated(Unique)
    ).

%% consistency_violations(+Constraint, -Violations)
%  Convenience accessor. Returns the transition list if violated,
%  empty list if preserved.
consistency_violations(C, Violations) :-
    preserved_under_context_shift(C, violated(Violations)), !.
consistency_violations(_, []).

%% gauge_fixed(+Constraint, +Context, -Fixed)
%  True (Fixed = true) when the observer is in a frame where gauge
%  freedom is inaccessible: the constraint appears as a genuine
%  restriction (mountain or snare) from this context, but at least
%  one other standard context sees it differently.
%
%  This is the safety-critical predicate. gauge_fixed(C, Ctx, true)
%  means: "from Ctx, what you see as immutable reality may be
%  someone else's coordination choice. Do not cut without checking
%  all contexts."
%
%  Gives check_all_contexts/2 a principled foundation: you are in
%  a gauge-fixed frame, so your local classification may not reflect
%  the full constraint structure.
gauge_fixed(C, Context, true) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, LocalType),
    member(LocalType, [mountain, snare]),
    % Verify another standard context sees a different type
    standard_context(AltCtx),
    AltCtx \= Context,
    drl_core:dr_type(C, AltCtx, AltType),
    AltType \= LocalType, !.
gauge_fixed(_, Context, false) :-
    constraint_indexing:valid_context(Context), !.
gauge_fixed(_, _, false).

/* ================================================================
   SECTION 2: FIRST-CLASS / SECOND-CLASS DECOMPOSITION

   Maps each DR type to a Dirac class. The key insight is the
   tangled_rope case: reform IS the problem of separating the
   first-class (coordination) component from the second-class
   (extraction) component. separability_factor/2 and
   reformability_score/3 directly measure this factoring
   feasibility.

   The piton as "degenerate first-class" explains its composition
   behavior: composition_rule(piton, _, piton) contaminates
   everything because a degenerate gauge symmetry (alternatives
   exist but are frozen by switching costs) poisons the constraint
   algebra.
   ================================================================ */

%% dirac_class(+Constraint, +Context, -Class)
%  Determines first-class/second-class status from a specific context.
%
%  Class ∈ { second_class,
%            first_class,
%            first_class_degenerate,
%            mixed(separable | partially_separable | entangled),
%            undetermined }
%
%  For tangled_rope, the Separability sub-classification uses
%  reformability_score/3 (drl_modal_logic.pl:710) which combines:
%    - separability_factor/2 (can coordination be separated from extraction?)
%    - coupling_factor/2 (how entangled are index dimensions?)
%    - excess_extraction_factor/2 (how much above Boltzmann floor?)
%
%  Thresholds:
%    Score > 0.60 → separable (first-class and second-class cleanly factor)
%    Score > 0.30 → partially_separable (some entanglement)
%    Score ≤ 0.30 → entangled (cannot cleanly separate components)
dirac_class(C, Context, Class) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, Type),
    type_to_dirac_class(Type, C, Context, Class).

%% dirac_class(+Constraint, -Class)
%  Backward compatible: uses analytical context.
dirac_class(C, Class) :-
    constraint_indexing:default_context(Ctx),
    dirac_class(C, Ctx, Class).

%% type_to_dirac_class(+DRType, +Constraint, +Context, -DiracClass)
%  Internal mapping from DR type to Dirac class.

% Mountains are always second-class: immutable restriction at every
% power level. type_immunity(mountain, 0.0) — immune to contamination.
% boltzmann_invariant_mountain/2 certifies structural invariance.
type_to_dirac_class(mountain, _, _, second_class).

% Snares are always second-class: genuine extraction that cannot be
% "gauged away" by redescription. composition_rule(rope, snare, snare)
% shows the extraction is real — it corrupts anything it touches.
type_to_dirac_class(snare, _, _, second_class).

% Ropes are first-class: pure coordination. The specific mechanism
% is a choice among equivalent coordination solutions. A CI_Rope
% (coupling_invariant_rope/2) is certified structurally sound.
type_to_dirac_class(rope, C, _, first_class) :-
    structural_signatures:coupling_invariant_rope(C, _), !.
type_to_dirac_class(rope, _, _, first_class).

% Scaffolds are first-class with temporal bound: temporary coordination
% with explicit sunset clause. Even more clearly "gauge" than rope —
% the mechanism is designed to be removed.
type_to_dirac_class(scaffold, _, _, first_class).

% Pitons are degenerate first-class: the gauge freedom (ability to
% choose among alternatives) formally exists but is practically
% inaccessible due to switching costs. No clean Dirac analog for
% degraded gauge — closest is a formalism where the gauge group
% has shrunk. Explains composition_rule(piton, _, piton): degenerate
% gauge poisons the algebra.
type_to_dirac_class(piton, _, _, first_class_degenerate).

% Tangled ropes are mixed: simultaneously first-class (coordination
% component) and second-class (extraction component). The reform
% problem IS the factoring problem — can you separate the gauge
% (coordination) from the genuine restriction (extraction)?
type_to_dirac_class(tangled_rope, C, Context, mixed(Separability)) :-
    drl_modal_logic:reformability_score(C, Context, Score),
    score_to_separability(Score, Separability).

% Indexically opaque constraints have undetermined Dirac class:
% the constraint algebra is unknown. Investigation IS the bracket
% computation.
type_to_dirac_class(indexically_opaque, _, _, undetermined).

% Unknown constraints are undetermined by definition.
type_to_dirac_class(unknown, _, _, undetermined).

%% score_to_separability(+ReformScore, -Separability)
%  Maps reformability_score to separability classification.
%  separable = first-class and second-class components cleanly factor.
%  partially_separable = some entanglement but reform may succeed.
%  entangled = components cannot be cleanly separated.
score_to_separability(Score, separable) :- Score > 0.60, !.
score_to_separability(Score, partially_separable) :- Score > 0.30, !.
score_to_separability(_, entangled).

/* ================================================================
   SECTION 3: GAUGE FREEDOM

   Describes what alternatives (gauge freedom) a constraint has
   from a specific observer context. This is the constructive
   content of the first-class/second-class classification:
   what CAN the observer do?
   ================================================================ */

%% gauge_freedom(+Constraint, +Context, -Freedom)
%  Describes what gauge freedom (if any) the constraint has from
%  this observer context.
%
%  Freedom ∈ { no_freedom,
%              coordination_choice(true | false),
%              frozen_choice(TheaterRatio | unknown),
%              partial_freedom(Separability, EffectiveExtraction),
%              unknown_freedom }
gauge_freedom(C, Context, Freedom) :-
    dirac_class(C, Context, Class),
    describe_freedom(Class, C, Context, Freedom).

%% describe_freedom(+DiracClass, +Constraint, +Context, -Freedom)

% Second-class: no gauge freedom. The restriction is real.
describe_freedom(second_class, _, _, no_freedom).

% First-class: coordination choice. Has viable alternatives?
% (has_viable_alternatives/2 from structural_signatures.pl:186)
describe_freedom(first_class, C, _, coordination_choice(HasAlts)) :-
    structural_signatures:has_viable_alternatives(C, HasAlts).

% Degenerate first-class: gauge frozen by switching costs.
% Theater ratio measures how much activity is performative compliance
% (maintaining the ossified choice) vs. functional.
describe_freedom(first_class_degenerate, C, _, frozen_choice(TheaterRatio)) :-
    config:param(theater_metric_name, TM),
    (   narrative_ontology:constraint_metric(C, TM, TheaterRatio)
    ->  true
    ;   TheaterRatio = unknown
    ).

% Mixed: partial freedom. Coordination exists but is entangled with
% extraction. Report separability and effective extraction level.
describe_freedom(mixed(Separability), C, Context, partial_freedom(Separability, Chi)) :-
    (   constraint_indexing:extractiveness_for_agent(C, Context, Chi)
    ->  true
    ;   Chi = unknown
    ).

% Undetermined: freedom status unknown.
describe_freedom(undetermined, _, _, unknown_freedom).

/* ================================================================
   SECTION 4: PRIMARY / SECONDARY GENERATION ORDER

   Lightweight annotation layer. Testsets with dual-formulation
   notes (epsilon-invariance decomposition) declare derived_from/3
   to record that a constraint was generated by a consistency
   condition applied to a parent constraint.

   Example (from the BGS conjecture decomposition):
     derived_from(bgs_eigenvector_thermalization,
                  bgs_conjecture, epsilon_invariance).

   The epsilon-invariance principle ("epsilon must be invariant for
   a single constraint") is the closest analog to Dirac's consistency
   condition {phi, H} ~ 0. When it fails, the constraint decomposes
   into linked components — secondary constraints.

   No heavy infrastructure. Just a traceable provenance link.
   ================================================================ */

:- multifile derived_from/3.
:- dynamic derived_from/3.

%% derived_from(+Secondary, +Primary, +Reason)
%  Records that Secondary was generated from Primary via a consistency
%  condition. Reason ∈ { epsilon_invariance, temporal_decomposition, ... }
%
%  Declared multifile so testsets can assert derivation chains:
%    dirac_classification:derived_from(child, parent, epsilon_invariance).

%% constraint_generation_order(+Constraint, -Order)
%  Returns primary if no derivation recorded, secondary(Source, Reason)
%  if derived from another constraint.
constraint_generation_order(C, primary) :-
    \+ derived_from(C, _, _), !.
constraint_generation_order(C, secondary(Source, Reason)) :-
    derived_from(C, Source, Reason).

/* ================================================================
   SECTION 5: FULL DIRAC REPORT

   Aggregates all Dirac classification components into a single
   structured term for analysis and report generation.
   ================================================================ */

%% full_dirac_report(+Constraint, +Context, -Report)
%  Generates a complete Dirac classification report.
%
%  Report = dirac_report(
%      constraint(C),
%      dr_type(Type),
%      dirac_class(Class),
%      gauge_freedom(Freedom),
%      generation_order(Order),
%      consistency(ConsistencyResult),
%      gauge_orbit(OrbitPoints),
%      gauge_fixed(Fixed)
%  )
full_dirac_report(C, Context, Report) :-
    constraint_indexing:valid_context(Context),
    drl_core:dr_type(C, Context, DRType),
    dirac_class(C, Context, DiracClass),
    gauge_freedom(C, Context, Freedom),
    constraint_generation_order(C, Order),
    preserved_under_context_shift(C, Consistency),
    gauge_orbit(C, Orbit),
    gauge_fixed(C, Context, Fixed),
    Report = dirac_report(
        constraint(C),
        dr_type(DRType),
        dirac_class(DiracClass),
        gauge_freedom(Freedom),
        generation_order(Order),
        consistency(Consistency),
        gauge_orbit(Orbit),
        gauge_fixed(Fixed)
    ).

/* ================================================================
   COMPOSITION ALGEBRA NOTE (not implemented — documented)

   composition_rule/3 in drl_modal_logic.pl encodes constraint
   interaction algebra. In Dirac's framework, the Poisson bracket
   {phi_i, phi_j} measures whether two constraints commute
   (first-class) or interfere (second-class).

   The existing contamination propagation system
   (type_contamination_strength/2 × type_immunity/2 with
   directional one-hop capped flow) already handles constraint
   interaction with well-motivated asymmetry that respects the
   entropy principle. A symmetrized bracket built on top of
   composition_rule/3 would fight this asymmetry.

   PREREQUISITE: composition_rule/3 needs spec-layer documentation
   following the spec→registry→implementation discipline before
   any formal algebra is built on top. The current rules are
   implementation without specification.

   OBSERVATION for the spec when written:
   - composition_rule(rope, rope, rope) = commuting coordination
   - composition_rule(rope, snare, snare) = extraction dominance
   - composition_rule(mountain, _, mountain) = Casimir invariant
     (absorbs rather than commutes — this is NOT zero bracket)
   - composition_rule(piton, _, piton) = degenerate contamination
   ================================================================ */
